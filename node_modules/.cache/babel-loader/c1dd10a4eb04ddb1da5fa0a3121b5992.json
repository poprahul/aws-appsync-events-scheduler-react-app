{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nexports.getVisitFn = getVisitFn;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar QueryDocumentKeys = exports.QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['name', 'directives'],\n  ObjectTypeDefinition: ['name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['name', 'directives', 'fields'],\n  UnionTypeDefinition: ['name', 'directives', 'types'],\n  EnumTypeDefinition: ['name', 'directives', 'values'],\n  EnumValueDefinition: ['name', 'directives'],\n  InputObjectTypeDefinition: ['name', 'directives', 'fields'],\n  TypeExtensionDefinition: ['definition'],\n  DirectiveDefinition: ['name', 'arguments', 'locations']\n};\nvar BREAK = exports.BREAK = {};\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nfunction visit(root, visitor, keyMap) {\n  var visitorKeys = keyMap || QueryDocumentKeys;\n  var stack = void 0;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var parent = void 0;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var key = void 0;\n    var node = void 0;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (!isLeaving) {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return maybeNode && typeof maybeNode.kind === 'string';\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result = void 0;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\n\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/language/visitor.js"],"names":["Object","defineProperty","exports","value","visit","visitInParallel","visitWithTypeInfo","getVisitFn","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","TypeExtensionDefinition","DirectiveDefinition","BREAK","root","visitor","keyMap","visitorKeys","stack","inArray","Array","isArray","keys","index","edits","parent","path","ancestors","newRoot","isLeaving","length","key","node","isEdited","undefined","pop","slice","clone","k","hasOwnProperty","editOffset","ii","editKey","editValue","splice","prev","push","result","isNode","Error","JSON","stringify","visitFn","kind","call","maybeNode","visitors","skipping","enter","i","fn","apply","arguments","leave","typeInfo","kindVisitor","kindSpecificVisitor","specificVisitor","specificKindVisitor"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nexports.getVisitFn = getVisitFn;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar QueryDocumentKeys = exports.QueryDocumentKeys = {\n  Name: [],\n\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', 'typeCondition', 'directives', 'selectionSet'],\n\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n\n  Directive: ['name', 'arguments'],\n\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n\n  ScalarTypeDefinition: ['name', 'directives'],\n  ObjectTypeDefinition: ['name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['name', 'directives', 'fields'],\n  UnionTypeDefinition: ['name', 'directives', 'types'],\n  EnumTypeDefinition: ['name', 'directives', 'values'],\n  EnumValueDefinition: ['name', 'directives'],\n  InputObjectTypeDefinition: ['name', 'directives', 'fields'],\n\n  TypeExtensionDefinition: ['definition'],\n\n  DirectiveDefinition: ['name', 'arguments', 'locations']\n};\n\nvar BREAK = exports.BREAK = {};\n\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\nfunction visit(root, visitor, keyMap) {\n  var visitorKeys = keyMap || QueryDocumentKeys;\n\n  var stack = void 0;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var parent = void 0;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var key = void 0;\n    var node = void 0;\n    var isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path.pop();\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n          node = clone;\n        }\n        var editOffset = 0;\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n          if (inArray) {\n            editKey -= editOffset;\n          }\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n      if (node === null || node === undefined) {\n        continue;\n      }\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (!isLeaving) {\n      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return maybeNode && typeof maybeNode.kind === 'string';\n}\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n        if (result !== undefined) {\n          typeInfo.leave(node);\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);\n      var result = void 0;\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      var specificKindVisitor = specificVisitor[kind];\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}