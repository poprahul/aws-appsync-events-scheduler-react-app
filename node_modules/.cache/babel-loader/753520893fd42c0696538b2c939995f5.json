{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\nexports.doTypesOverlap = doTypesOverlap;\n\nvar _definition = require('../type/definition');\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n\n\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if (typeA instanceof _definition.GraphQLNonNull && typeB instanceof _definition.GraphQLNonNull) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if (typeA instanceof _definition.GraphQLList && typeB instanceof _definition.GraphQLList) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if (superType instanceof _definition.GraphQLNonNull) {\n    if (maybeSubType instanceof _definition.GraphQLNonNull) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLNonNull) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if (superType instanceof _definition.GraphQLList) {\n    if (maybeSubType instanceof _definition.GraphQLList) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLList) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n\n\n  if ((0, _definition.isAbstractType)(superType) && maybeSubType instanceof _definition.GraphQLObjectType && schema.isPossibleType(superType, maybeSubType)) {\n    return true;\n  } // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return false;\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // So flow is aware this is constant\n  var _typeB = typeB; // Equivalent types overlap\n\n  if (typeA === _typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(_typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isPossibleType(_typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isPossibleType(typeA, _typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(_typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(_typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/utilities/typeComparators.js"],"names":["Object","defineProperty","exports","value","isEqualType","isTypeSubTypeOf","doTypesOverlap","_definition","require","typeA","typeB","GraphQLNonNull","ofType","GraphQLList","schema","maybeSubType","superType","isAbstractType","GraphQLObjectType","isPossibleType","_typeB","getPossibleTypes","some","type"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\nexports.doTypesOverlap = doTypesOverlap;\n\nvar _definition = require('../type/definition');\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  }\n\n  // If either type is non-null, the other must also be non-null.\n  if (typeA instanceof _definition.GraphQLNonNull && typeB instanceof _definition.GraphQLNonNull) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // If either type is a list, the other must also be a list.\n  if (typeA instanceof _definition.GraphQLList && typeB instanceof _definition.GraphQLList) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // Otherwise the types are not equal.\n  return false;\n}\n\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  }\n\n  // If superType is non-null, maybeSubType must also be non-null.\n  if (superType instanceof _definition.GraphQLNonNull) {\n    if (maybeSubType instanceof _definition.GraphQLNonNull) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLNonNull) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  }\n\n  // If superType type is a list, maybeSubType type must also be a list.\n  if (superType instanceof _definition.GraphQLList) {\n    if (maybeSubType instanceof _definition.GraphQLList) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLList) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  }\n\n  // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n  if ((0, _definition.isAbstractType)(superType) && maybeSubType instanceof _definition.GraphQLObjectType && schema.isPossibleType(superType, maybeSubType)) {\n    return true;\n  }\n\n  // Otherwise, the child type is not a valid subtype of the parent type.\n  return false;\n}\n\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // So flow is aware this is constant\n  var _typeB = typeB;\n\n  // Equivalent types overlap\n  if (typeA === _typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(_typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isPossibleType(_typeB, type);\n      });\n    }\n    // Determine if the latter type is a possible concrete type of the former.\n    return schema.isPossibleType(typeA, _typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(_typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(_typeB, typeA);\n  }\n\n  // Otherwise the types do not overlap.\n  return false;\n}"]},"metadata":{},"sourceType":"script"}