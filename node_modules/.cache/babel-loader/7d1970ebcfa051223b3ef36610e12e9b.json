{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLSchema = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _definition = require('./definition');\n\nvar _directives = require('./directives');\n\nvar _introspection = require('./introspection');\n\nvar _find = require('../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _typeComparators = require('../utilities/typeComparators');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\n\nvar GraphQLSchema = exports.GraphQLSchema = function () {\n  function GraphQLSchema(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLSchema);\n\n    !((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') ? (0, _invariant2.default)(0, 'Must provide configuration object.') : void 0;\n    !(config.query instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema query must be Object Type but got: ' + String(config.query) + '.') : void 0;\n    this._queryType = config.query;\n    !(!config.mutation || config.mutation instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema mutation must be Object Type if provided but got: ' + String(config.mutation) + '.') : void 0;\n    this._mutationType = config.mutation;\n    !(!config.subscription || config.subscription instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema subscription must be Object Type if provided but got: ' + String(config.subscription) + '.') : void 0;\n    this._subscriptionType = config.subscription;\n    !(!config.types || Array.isArray(config.types)) ? (0, _invariant2.default)(0, 'Schema types must be Array if provided but got: ' + String(config.types) + '.') : void 0;\n    !(!config.directives || Array.isArray(config.directives) && config.directives.every(function (directive) {\n      return directive instanceof _directives.GraphQLDirective;\n    })) ? (0, _invariant2.default)(0, 'Schema directives must be Array<GraphQLDirective> if provided but got: ' + String(config.directives) + '.') : void 0; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || _directives.specifiedDirectives;\n    this.astNode = config.astNode || null; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), _introspection.__Schema];\n    var types = config.types;\n\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    }\n\n    this._typeMap = initialTypes.reduce(typeMapReducer, Object.create(null)); // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n\n      if (type instanceof _definition.GraphQLObjectType) {\n        type.getInterfaces().forEach(function (iface) {\n          var impls = _this._implementations[iface.name];\n\n          if (impls) {\n            impls.push(type);\n          } else {\n            _this._implementations[iface.name] = [type];\n          }\n        });\n      }\n    }); // Enforce correct interface implementations.\n\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n\n      if (type instanceof _definition.GraphQLObjectType) {\n        type.getInterfaces().forEach(function (iface) {\n          return assertObjectImplementsInterface(_this, type, iface);\n        });\n      }\n    });\n  }\n\n  GraphQLSchema.prototype.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  GraphQLSchema.prototype.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  GraphQLSchema.prototype.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (abstractType instanceof _definition.GraphQLUnionType) {\n      return abstractType.getTypes();\n    }\n\n    !(abstractType instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0) : void 0;\n    return this._implementations[abstractType.name];\n  };\n\n  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      !Array.isArray(possibleTypes) ? (0, _invariant2.default)(0, 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.') : void 0;\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  GraphQLSchema.prototype.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  GraphQLSchema.prototype.getDirective = function getDirective(name) {\n    return (0, _find2.default)(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}();\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  if (type instanceof _definition.GraphQLList || type instanceof _definition.GraphQLNonNull) {\n    return typeMapReducer(map, type.ofType);\n  }\n\n  if (map[type.name]) {\n    !(map[type.name] === type) ? (0, _invariant2.default)(0, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type.name + '\".')) : void 0;\n    return map;\n  }\n\n  map[type.name] = type;\n  var reducedMap = map;\n\n  if (type instanceof _definition.GraphQLUnionType) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (type instanceof _definition.GraphQLObjectType) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {\n    var fieldMap = type.getFields();\n    Object.keys(fieldMap).forEach(function (fieldName) {\n      var field = fieldMap[fieldName];\n\n      if (field.args) {\n        var fieldArgTypes = field.args.map(function (arg) {\n          return arg.type;\n        });\n        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      }\n\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  if (type instanceof _definition.GraphQLInputObjectType) {\n    var _fieldMap = type.getFields();\n\n    Object.keys(_fieldMap).forEach(function (fieldName) {\n      var field = _fieldMap[fieldName];\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  return reducedMap;\n}\n\nfunction assertObjectImplementsInterface(schema, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  Object.keys(ifaceFieldMap).forEach(function (fieldName) {\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    !objectField ? (0, _invariant2.default)(0, '\"' + iface.name + '\" expects field \"' + fieldName + '\" but \"' + object.name + '\" ' + 'does not provide it.') : void 0; // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n    !(0, _typeComparators.isTypeSubTypeOf)(schema, objectField.type, ifaceField.type) ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + ' expects type \"' + String(ifaceField.type) + '\" ' + 'but ' + (object.name + '.' + fieldName + ' provides type \"' + String(objectField.type) + '\".')) : void 0; // Assert each interface field arg is implemented.\n\n    ifaceField.args.forEach(function (ifaceArg) {\n      var argName = ifaceArg.name;\n      var objectArg = (0, _find2.default)(objectField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      !objectArg ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + ' expects argument \"' + argName + '\" but ' + (object.name + '.' + fieldName + ' does not provide it.')) : void 0; // Assert interface field arg type matches object field arg type.\n      // (invariant)\n\n      !(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type) ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + '(' + argName + ':) expects type ' + ('\"' + String(ifaceArg.type) + '\" but ') + (object.name + '.' + fieldName + '(' + argName + ':) provides type ') + ('\"' + String(objectArg.type) + '\".')) : void 0;\n    }); // Assert additional arguments must not be required.\n\n    objectField.args.forEach(function (objectArg) {\n      var argName = objectArg.name;\n      var ifaceArg = (0, _find2.default)(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg) {\n        !!(objectArg.type instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, object.name + '.' + fieldName + '(' + argName + ':) is of required type ' + ('\"' + String(objectArg.type) + '\" but is not also provided by the ') + ('interface ' + iface.name + '.' + fieldName + '.')) : void 0;\n      }\n    });\n  });\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/type/schema.js"],"names":["Object","defineProperty","exports","value","GraphQLSchema","undefined","_typeof","Symbol","iterator","obj","constructor","prototype","_definition","require","_directives","_introspection","_find","_find2","_interopRequireDefault","_invariant","_invariant2","_typeComparators","__esModule","default","_classCallCheck","instance","Constructor","TypeError","config","_this","query","GraphQLObjectType","String","_queryType","mutation","_mutationType","subscription","_subscriptionType","types","Array","isArray","directives","every","directive","GraphQLDirective","specifiedDirectives","astNode","initialTypes","getQueryType","getMutationType","getSubscriptionType","__Schema","concat","_typeMap","reduce","typeMapReducer","create","_implementations","keys","forEach","typeName","type","getInterfaces","iface","impls","name","push","assertObjectImplementsInterface","getTypeMap","getType","getPossibleTypes","abstractType","GraphQLUnionType","getTypes","GraphQLInterfaceType","isPossibleType","possibleType","possibleTypeMap","_possibleTypeMap","possibleTypes","map","Boolean","getDirectives","getDirective","GraphQLList","GraphQLNonNull","ofType","reducedMap","fieldMap","getFields","fieldName","field","args","fieldArgTypes","arg","GraphQLInputObjectType","_fieldMap","schema","object","objectFieldMap","ifaceFieldMap","objectField","ifaceField","isTypeSubTypeOf","ifaceArg","argName","objectArg","isEqualType"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLSchema = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _definition = require('./definition');\n\nvar _directives = require('./directives');\n\nvar _introspection = require('./introspection');\n\nvar _find = require('../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _typeComparators = require('../utilities/typeComparators');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           * \n                                                                                                                                                           */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\nvar GraphQLSchema = exports.GraphQLSchema = function () {\n  function GraphQLSchema(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLSchema);\n\n    !((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') ? (0, _invariant2.default)(0, 'Must provide configuration object.') : void 0;\n\n    !(config.query instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema query must be Object Type but got: ' + String(config.query) + '.') : void 0;\n    this._queryType = config.query;\n\n    !(!config.mutation || config.mutation instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema mutation must be Object Type if provided but got: ' + String(config.mutation) + '.') : void 0;\n    this._mutationType = config.mutation;\n\n    !(!config.subscription || config.subscription instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Schema subscription must be Object Type if provided but got: ' + String(config.subscription) + '.') : void 0;\n    this._subscriptionType = config.subscription;\n\n    !(!config.types || Array.isArray(config.types)) ? (0, _invariant2.default)(0, 'Schema types must be Array if provided but got: ' + String(config.types) + '.') : void 0;\n\n    !(!config.directives || Array.isArray(config.directives) && config.directives.every(function (directive) {\n      return directive instanceof _directives.GraphQLDirective;\n    })) ? (0, _invariant2.default)(0, 'Schema directives must be Array<GraphQLDirective> if provided but got: ' + String(config.directives) + '.') : void 0;\n    // Provide specified directives (e.g. @include and @skip) by default.\n    this._directives = config.directives || _directives.specifiedDirectives;\n    this.astNode = config.astNode || null;\n\n    // Build type map now to detect any errors within this schema.\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), _introspection.__Schema];\n\n    var types = config.types;\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    }\n\n    this._typeMap = initialTypes.reduce(typeMapReducer, Object.create(null));\n\n    // Keep track of all implementations by interface name.\n    this._implementations = Object.create(null);\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n      if (type instanceof _definition.GraphQLObjectType) {\n        type.getInterfaces().forEach(function (iface) {\n          var impls = _this._implementations[iface.name];\n          if (impls) {\n            impls.push(type);\n          } else {\n            _this._implementations[iface.name] = [type];\n          }\n        });\n      }\n    });\n\n    // Enforce correct interface implementations.\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n      if (type instanceof _definition.GraphQLObjectType) {\n        type.getInterfaces().forEach(function (iface) {\n          return assertObjectImplementsInterface(_this, type, iface);\n        });\n      }\n    });\n  }\n\n  GraphQLSchema.prototype.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  GraphQLSchema.prototype.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  GraphQLSchema.prototype.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (abstractType instanceof _definition.GraphQLUnionType) {\n      return abstractType.getTypes();\n    }\n    !(abstractType instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0) : void 0;\n    return this._implementations[abstractType.name];\n  };\n\n  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      !Array.isArray(possibleTypes) ? (0, _invariant2.default)(0, 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.') : void 0;\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  GraphQLSchema.prototype.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  GraphQLSchema.prototype.getDirective = function getDirective(name) {\n    return (0, _find2.default)(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}();\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n  if (type instanceof _definition.GraphQLList || type instanceof _definition.GraphQLNonNull) {\n    return typeMapReducer(map, type.ofType);\n  }\n  if (map[type.name]) {\n    !(map[type.name] === type) ? (0, _invariant2.default)(0, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type.name + '\".')) : void 0;\n    return map;\n  }\n  map[type.name] = type;\n\n  var reducedMap = map;\n\n  if (type instanceof _definition.GraphQLUnionType) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (type instanceof _definition.GraphQLObjectType) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (type instanceof _definition.GraphQLObjectType || type instanceof _definition.GraphQLInterfaceType) {\n    var fieldMap = type.getFields();\n    Object.keys(fieldMap).forEach(function (fieldName) {\n      var field = fieldMap[fieldName];\n\n      if (field.args) {\n        var fieldArgTypes = field.args.map(function (arg) {\n          return arg.type;\n        });\n        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      }\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  if (type instanceof _definition.GraphQLInputObjectType) {\n    var _fieldMap = type.getFields();\n    Object.keys(_fieldMap).forEach(function (fieldName) {\n      var field = _fieldMap[fieldName];\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  return reducedMap;\n}\n\nfunction assertObjectImplementsInterface(schema, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields();\n\n  // Assert each interface field is implemented.\n  Object.keys(ifaceFieldMap).forEach(function (fieldName) {\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName];\n\n    // Assert interface field exists on object.\n    !objectField ? (0, _invariant2.default)(0, '\"' + iface.name + '\" expects field \"' + fieldName + '\" but \"' + object.name + '\" ' + 'does not provide it.') : void 0;\n\n    // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n    !(0, _typeComparators.isTypeSubTypeOf)(schema, objectField.type, ifaceField.type) ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + ' expects type \"' + String(ifaceField.type) + '\" ' + 'but ' + (object.name + '.' + fieldName + ' provides type \"' + String(objectField.type) + '\".')) : void 0;\n\n    // Assert each interface field arg is implemented.\n    ifaceField.args.forEach(function (ifaceArg) {\n      var argName = ifaceArg.name;\n      var objectArg = (0, _find2.default)(objectField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      // Assert interface field arg exists on object field.\n      !objectArg ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + ' expects argument \"' + argName + '\" but ' + (object.name + '.' + fieldName + ' does not provide it.')) : void 0;\n\n      // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      !(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type) ? (0, _invariant2.default)(0, iface.name + '.' + fieldName + '(' + argName + ':) expects type ' + ('\"' + String(ifaceArg.type) + '\" but ') + (object.name + '.' + fieldName + '(' + argName + ':) provides type ') + ('\"' + String(objectArg.type) + '\".')) : void 0;\n    });\n\n    // Assert additional arguments must not be required.\n    objectField.args.forEach(function (objectArg) {\n      var argName = objectArg.name;\n      var ifaceArg = (0, _find2.default)(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n      if (!ifaceArg) {\n        !!(objectArg.type instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, object.name + '.' + fieldName + '(' + argName + ':) is of required type ' + ('\"' + String(objectArg.type) + '\" but is not also provided by the ') + ('interface ' + iface.name + '.' + fieldName + '.')) : void 0;\n      }\n    });\n  });\n}"]},"metadata":{},"sourceType":"script"}