{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType } from '../type/definition';\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0; // Collect the type definitions and extensions found in the document.\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n\n        if (schema.getType(typeName)) {\n          throw new GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n\n        typeDefinitionMap[typeName] = def;\n        break;\n\n      case Kind.OBJECT_TYPE_EXTENSION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.name.value;\n        var existingType = schema.getType(extendedTypeName);\n\n        if (!existingType) {\n          throw new GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def]);\n        }\n\n        if (!isObjectType(existingType)) {\n          throw new GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def]);\n        }\n\n        var extensions = typeExtensionsMap[extendedTypeName];\n\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n\n        if (existingDirective) {\n          throw new GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n\n        directiveDefinitions.push(def);\n        break;\n\n      case Kind.SCALAR_TYPE_EXTENSION:\n      case Kind.INTERFACE_TYPE_EXTENSION:\n      case Kind.UNION_TYPE_EXTENSION:\n      case Kind.ENUM_TYPE_EXTENSION:\n      case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        throw new Error('The ' + def.kind + ' kind is not yet supported by extendSchema().');\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  var definitionBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeName, node) {\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendType(existingType);\n    }\n\n    if (node) {\n      throw new GraphQLError('Unknown type: \"' + typeName + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n\n    throw GraphQLError('Missing type from schema');\n  }); // Get the root Query, Mutation, and Subscription object types.\n  // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n  var existingQueryType = schema.getQueryType();\n  var queryType = existingQueryType ? definitionBuilder.buildType(existingQueryType.name) : null;\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? definitionBuilder.buildType(existingMutationType.name) : null;\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? definitionBuilder.buildType(existingSubscriptionType.name) : null; // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return definitionBuilder.buildType(typeName);\n  }); // Do the same with new types, appending to the list of defined types.\n\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(definitionBuilder.buildType(typeName));\n  }); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    allowedLegacyNames: schema.__allowedLegacyNames && schema.__allowedLegacyNames.slice()\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return definitionBuilder.buildDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = definitionBuilder.buildType(typeDef.name);\n    return type;\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function extendType(type) {\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.interfaces.forEach(function (namedType) {\n          // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n          interfaces.push(definitionBuilder.buildType(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: keyMap(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    }); // If there are any extensions to the fields, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n\n          if (oldFieldMap[fieldName]) {\n            throw new GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n\n          newFieldMap[fieldName] = definitionBuilder.buildField(field);\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendFieldType(typeDef.ofType));\n    }\n\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n\n    return getTypeFromDef(typeDef);\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/extendSchema.js"],"names":["invariant","keyMap","ASTDefinitionBuilder","GraphQLError","isSchema","GraphQLSchema","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLList","GraphQLNonNull","GraphQLDirective","Kind","extendSchema","schema","documentAST","options","kind","DOCUMENT","typeDefinitionMap","Object","create","typeExtensionsMap","directiveDefinitions","i","definitions","length","def","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","typeName","name","value","getType","OBJECT_TYPE_EXTENSION","extendedTypeName","existingType","extensions","push","DIRECTIVE_DEFINITION","directiveName","existingDirective","getDirective","SCALAR_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","Error","keys","definitionBuilder","node","extendType","existingQueryType","getQueryType","queryType","buildType","existingMutationType","getMutationType","mutationType","existingSubscriptionType","getSubscriptionType","subscriptionType","typeMap","getTypeMap","types","map","forEach","query","mutation","subscription","directives","getMergedDirectives","astNode","allowedLegacyNames","__allowedLegacyNames","slice","existingDirectives","getDirectives","newDirectives","directiveNode","buildDirective","concat","getTypeFromDef","typeDef","type","extendObjectType","extendInterfaceType","extendUnionType","extensionASTNodes","description","interfaces","extendImplementedInterfaces","fields","extendFieldMap","isTypeOf","resolveType","getTypes","getInterfaces","extension","namedType","newFieldMap","oldFieldMap","getFields","fieldName","field","deprecationReason","extendFieldType","args","arg","resolve","buildField","ofType"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\n\nimport { isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType } from '../type/definition';\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\n\nimport { GraphQLDirective } from '../type/directives';\n\nimport { Kind } from '../language/kinds';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null);\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n        if (schema.getType(typeName)) {\n          throw new GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n        typeDefinitionMap[typeName] = def;\n        break;\n      case Kind.OBJECT_TYPE_EXTENSION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.name.value;\n        var existingType = schema.getType(extendedTypeName);\n        if (!existingType) {\n          throw new GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def]);\n        }\n        if (!isObjectType(existingType)) {\n          throw new GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def]);\n        }\n        var extensions = typeExtensionsMap[extendedTypeName];\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n        if (existingDirective) {\n          throw new GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n        directiveDefinitions.push(def);\n        break;\n      case Kind.SCALAR_TYPE_EXTENSION:\n      case Kind.INTERFACE_TYPE_EXTENSION:\n      case Kind.UNION_TYPE_EXTENSION:\n      case Kind.ENUM_TYPE_EXTENSION:\n      case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        throw new Error('The ' + def.kind + ' kind is not yet supported by extendSchema().');\n    }\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  var definitionBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeName, node) {\n    var existingType = schema.getType(typeName);\n    if (existingType) {\n      return extendType(existingType);\n    }\n\n    if (node) {\n      throw new GraphQLError('Unknown type: \"' + typeName + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n    throw GraphQLError('Missing type from schema');\n  });\n\n  // Get the root Query, Mutation, and Subscription object types.\n  // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n  var existingQueryType = schema.getQueryType();\n  var queryType = existingQueryType ? definitionBuilder.buildType(existingQueryType.name) : null;\n\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? definitionBuilder.buildType(existingMutationType.name) : null;\n\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? definitionBuilder.buildType(existingSubscriptionType.name) : null;\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return definitionBuilder.buildType(typeName);\n  });\n\n  // Do the same with new types, appending to the list of defined types.\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(definitionBuilder.buildType(typeName));\n  });\n\n  // Then produce and return a Schema with these types.\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    allowedLegacyNames: schema.__allowedLegacyNames && schema.__allowedLegacyNames.slice()\n  });\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return definitionBuilder.buildDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = definitionBuilder.buildType(typeDef.name);\n    return type;\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function extendType(type) {\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef);\n\n    // If there are any extensions to the interfaces, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.interfaces.forEach(function (namedType) {\n          // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n          interfaces.push(definitionBuilder.buildType(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: keyMap(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    });\n\n    // If there are any extensions to the fields, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n          if (oldFieldMap[fieldName]) {\n            throw new GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n          newFieldMap[fieldName] = definitionBuilder.buildField(field);\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendFieldType(typeDef.ofType));\n    }\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n    return getTypeFromDef(typeDef);\n  }\n}"]},"metadata":{},"sourceType":"module"}