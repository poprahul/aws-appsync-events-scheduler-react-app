{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { FetchType } from '../core/types';\nimport { ObservableQuery } from '../core/ObservableQuery';\nimport { NetworkStatus } from '../core/networkStatus';\n\nvar QueryScheduler = function () {\n  function QueryScheduler(_a) {\n    var queryManager = _a.queryManager,\n        ssrMode = _a.ssrMode;\n    this.inFlightQueries = {};\n    this.registeredQueries = {};\n    this.intervalQueries = {};\n    this.pollingTimers = {};\n    this.ssrMode = false;\n    this.queryManager = queryManager;\n    this.ssrMode = ssrMode || false;\n  }\n\n  QueryScheduler.prototype.checkInFlight = function (queryId) {\n    var query = this.queryManager.queryStore.get(queryId);\n    return query && query.networkStatus !== NetworkStatus.ready && query.networkStatus !== NetworkStatus.error;\n  };\n\n  QueryScheduler.prototype.fetchQuery = function (queryId, options, fetchType) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.queryManager.fetchQuery(queryId, options, fetchType).then(function (result) {\n        resolve(result);\n      }).catch(function (error) {\n        reject(error);\n      });\n    });\n  };\n\n  QueryScheduler.prototype.startPollingQuery = function (options, queryId, listener) {\n    if (!options.pollInterval) {\n      throw new Error('Attempted to start a polling query without a polling interval.');\n    }\n\n    if (this.ssrMode) return queryId;\n    this.registeredQueries[queryId] = options;\n\n    if (listener) {\n      this.queryManager.addQueryListener(queryId, listener);\n    }\n\n    this.addQueryOnInterval(queryId, options);\n    return queryId;\n  };\n\n  QueryScheduler.prototype.stopPollingQuery = function (queryId) {\n    delete this.registeredQueries[queryId];\n  };\n\n  QueryScheduler.prototype.fetchQueriesOnInterval = function (interval) {\n    var _this = this;\n\n    this.intervalQueries[interval] = this.intervalQueries[interval].filter(function (queryId) {\n      if (!(_this.registeredQueries.hasOwnProperty(queryId) && _this.registeredQueries[queryId].pollInterval === interval)) {\n        return false;\n      }\n\n      if (_this.checkInFlight(queryId)) {\n        return true;\n      }\n\n      var queryOptions = _this.registeredQueries[queryId];\n\n      var pollingOptions = __assign({}, queryOptions);\n\n      pollingOptions.fetchPolicy = 'network-only';\n\n      _this.fetchQuery(queryId, pollingOptions, FetchType.poll).catch(function () {});\n\n      return true;\n    });\n\n    if (this.intervalQueries[interval].length === 0) {\n      clearInterval(this.pollingTimers[interval]);\n      delete this.intervalQueries[interval];\n    }\n  };\n\n  QueryScheduler.prototype.addQueryOnInterval = function (queryId, queryOptions) {\n    var _this = this;\n\n    var interval = queryOptions.pollInterval;\n\n    if (!interval) {\n      throw new Error(\"A poll interval is required to start polling query with id '\" + queryId + \"'.\");\n    }\n\n    if (this.intervalQueries.hasOwnProperty(interval.toString()) && this.intervalQueries[interval].length > 0) {\n      this.intervalQueries[interval].push(queryId);\n    } else {\n      this.intervalQueries[interval] = [queryId];\n      this.pollingTimers[interval] = setInterval(function () {\n        _this.fetchQueriesOnInterval(interval);\n      }, interval);\n    }\n  };\n\n  QueryScheduler.prototype.registerPollingQuery = function (queryOptions) {\n    if (!queryOptions.pollInterval) {\n      throw new Error('Attempted to register a non-polling query with the scheduler.');\n    }\n\n    return new ObservableQuery({\n      scheduler: this,\n      options: queryOptions\n    });\n  };\n\n  return QueryScheduler;\n}();\n\nexport { QueryScheduler };","map":{"version":3,"sources":["../../src/scheduler/scheduler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { FetchType } from '../core/types';\nimport { ObservableQuery } from '../core/ObservableQuery';\nimport { NetworkStatus } from '../core/networkStatus';\nvar QueryScheduler = (function () {\n    function QueryScheduler(_a) {\n        var queryManager = _a.queryManager, ssrMode = _a.ssrMode;\n        this.inFlightQueries = {};\n        this.registeredQueries = {};\n        this.intervalQueries = {};\n        this.pollingTimers = {};\n        this.ssrMode = false;\n        this.queryManager = queryManager;\n        this.ssrMode = ssrMode || false;\n    }\n    QueryScheduler.prototype.checkInFlight = function (queryId) {\n        var query = this.queryManager.queryStore.get(queryId);\n        return (query &&\n            query.networkStatus !== NetworkStatus.ready &&\n            query.networkStatus !== NetworkStatus.error);\n    };\n    QueryScheduler.prototype.fetchQuery = function (queryId, options, fetchType) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.queryManager\n                .fetchQuery(queryId, options, fetchType)\n                .then(function (result) {\n                resolve(result);\n            })\n                .catch(function (error) {\n                reject(error);\n            });\n        });\n    };\n    QueryScheduler.prototype.startPollingQuery = function (options, queryId, listener) {\n        if (!options.pollInterval) {\n            throw new Error('Attempted to start a polling query without a polling interval.');\n        }\n        if (this.ssrMode)\n            return queryId;\n        this.registeredQueries[queryId] = options;\n        if (listener) {\n            this.queryManager.addQueryListener(queryId, listener);\n        }\n        this.addQueryOnInterval(queryId, options);\n        return queryId;\n    };\n    QueryScheduler.prototype.stopPollingQuery = function (queryId) {\n        delete this.registeredQueries[queryId];\n    };\n    QueryScheduler.prototype.fetchQueriesOnInterval = function (interval) {\n        var _this = this;\n        this.intervalQueries[interval] = this.intervalQueries[interval].filter(function (queryId) {\n            if (!(_this.registeredQueries.hasOwnProperty(queryId) &&\n                _this.registeredQueries[queryId].pollInterval === interval)) {\n                return false;\n            }\n            if (_this.checkInFlight(queryId)) {\n                return true;\n            }\n            var queryOptions = _this.registeredQueries[queryId];\n            var pollingOptions = __assign({}, queryOptions);\n            pollingOptions.fetchPolicy = 'network-only';\n            _this.fetchQuery(queryId, pollingOptions, FetchType.poll).catch(function () { });\n            return true;\n        });\n        if (this.intervalQueries[interval].length === 0) {\n            clearInterval(this.pollingTimers[interval]);\n            delete this.intervalQueries[interval];\n        }\n    };\n    QueryScheduler.prototype.addQueryOnInterval = function (queryId, queryOptions) {\n        var _this = this;\n        var interval = queryOptions.pollInterval;\n        if (!interval) {\n            throw new Error(\"A poll interval is required to start polling query with id '\" + queryId + \"'.\");\n        }\n        if (this.intervalQueries.hasOwnProperty(interval.toString()) &&\n            this.intervalQueries[interval].length > 0) {\n            this.intervalQueries[interval].push(queryId);\n        }\n        else {\n            this.intervalQueries[interval] = [queryId];\n            this.pollingTimers[interval] = setInterval(function () {\n                _this.fetchQueriesOnInterval(interval);\n            }, interval);\n        }\n    };\n    QueryScheduler.prototype.registerPollingQuery = function (queryOptions) {\n        if (!queryOptions.pollInterval) {\n            throw new Error('Attempted to register a non-polling query with the scheduler.');\n        }\n        return new ObservableQuery({\n            scheduler: this,\n            options: queryOptions,\n        });\n    };\n    return QueryScheduler;\n}());\nexport { QueryScheduler };\n//# sourceMappingURL=scheduler.js.map"]},"metadata":{},"sourceType":"module"}