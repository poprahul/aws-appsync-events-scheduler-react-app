{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cycleErrorMessage = cycleErrorMessage;\nexports.NoFragmentCycles = NoFragmentCycles;\n\nvar _error = require('../../error');\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n}\n\nfunction NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      if (!visitedFrags[node.name.value]) {\n        detectCycleRecursive(node);\n      }\n\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n\n      if (cycleIndex === undefined) {\n        spreadPath.push(spreadNode);\n\n        if (!visitedFrags[spreadName]) {\n          var spreadFragment = context.getFragment(spreadName);\n\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        }\n\n        spreadPath.pop();\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n          return s.name.value;\n        })), cyclePath.concat(spreadNode)));\n      }\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/validation/rules/NoFragmentCycles.js"],"names":["Object","defineProperty","exports","value","cycleErrorMessage","NoFragmentCycles","_error","require","fragName","spreadNames","via","length","join","context","visitedFrags","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","name","detectCycleRecursive","fragment","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","i","spreadNode","spreadName","cycleIndex","undefined","push","spreadFragment","getFragment","pop","cyclePath","slice","reportError","GraphQLError","map","s","concat"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cycleErrorMessage = cycleErrorMessage;\nexports.NoFragmentCycles = NoFragmentCycles;\n\nvar _error = require('../../error');\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n}\n\nfunction NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null);\n\n  // Array of AST nodes used to produce meaningful errors\n  var spreadPath = [];\n\n  // Position in the spread path\n  var spreadPathIndexByName = Object.create(null);\n\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      if (!visitedFrags[node.name.value]) {\n        detectCycleRecursive(node);\n      }\n      return false;\n    }\n  };\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  function detectCycleRecursive(fragment) {\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n\n      if (cycleIndex === undefined) {\n        spreadPath.push(spreadNode);\n        if (!visitedFrags[spreadName]) {\n          var spreadFragment = context.getFragment(spreadName);\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        }\n        spreadPath.pop();\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n          return s.name.value;\n        })), cyclePath.concat(spreadNode)));\n      }\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}"]},"metadata":{},"sourceType":"script"}