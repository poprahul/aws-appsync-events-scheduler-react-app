{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOfflineMiddleware = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _actions = require(\"./actions\");\n\nvar _send = _interopRequireDefault(require(\"./send\"));\n\nvar after = function after() {\n  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n};\n\nvar createOfflineMiddleware = function createOfflineMiddleware(config) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        // allow other middleware to do their things\n        var result = next(action);\n        var promise; // find any actions to send, if any\n\n        var state = store.getState();\n        var offline = config.offlineStateLens(state).get;\n        var context = {\n          offline: offline\n        };\n        var offlineAction = config.queue.peek(offline.outbox, action, context); // create promise to return on enqueue offline action\n\n        if (action.meta && action.meta.offline) {\n          var registerAction = config.offlineActionTracker.registerAction;\n          promise = registerAction(offline.lastTransaction);\n        } // if there are any actions in the queue that we are not\n        // yet processing, send those actions\n\n\n        if (offlineAction && !offline.busy && !offline.retryScheduled && offline.online) {\n          (0, _send.default)(offlineAction, store.dispatch, config, offline.retryCount);\n        }\n\n        if (action.type === _constants.OFFLINE_SCHEDULE_RETRY) {\n          after(action.payload.delay).then(function () {\n            store.dispatch((0, _actions.completeRetry)(offlineAction));\n          });\n        }\n\n        if (action.type === _constants.OFFLINE_SEND && offlineAction && !offline.busy) {\n          (0, _send.default)(offlineAction, store.dispatch, config, offline.retryCount);\n        }\n\n        return promise || result;\n      };\n    };\n  };\n};\n\nexports.createOfflineMiddleware = createOfflineMiddleware;","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/@redux-offline/redux-offline/lib/middleware.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createOfflineMiddleware","_constants","_actions","_send","after","timeout","arguments","length","undefined","Promise","resolve","setTimeout","config","store","next","action","result","promise","state","getState","offline","offlineStateLens","get","context","offlineAction","queue","peek","outbox","meta","registerAction","offlineActionTracker","lastTransaction","busy","retryScheduled","online","default","dispatch","retryCount","type","OFFLINE_SCHEDULE_RETRY","payload","delay","then","completeRetry","OFFLINE_SEND"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOfflineMiddleware = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _actions = require(\"./actions\");\n\nvar _send = _interopRequireDefault(require(\"./send\"));\n\nvar after = function after() {\n  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n};\n\nvar createOfflineMiddleware = function createOfflineMiddleware(config) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        // allow other middleware to do their things\n        var result = next(action);\n        var promise; // find any actions to send, if any\n\n        var state = store.getState();\n        var offline = config.offlineStateLens(state).get;\n        var context = {\n          offline: offline\n        };\n        var offlineAction = config.queue.peek(offline.outbox, action, context); // create promise to return on enqueue offline action\n\n        if (action.meta && action.meta.offline) {\n          var registerAction = config.offlineActionTracker.registerAction;\n          promise = registerAction(offline.lastTransaction);\n        } // if there are any actions in the queue that we are not\n        // yet processing, send those actions\n\n\n        if (offlineAction && !offline.busy && !offline.retryScheduled && offline.online) {\n          (0, _send.default)(offlineAction, store.dispatch, config, offline.retryCount);\n        }\n\n        if (action.type === _constants.OFFLINE_SCHEDULE_RETRY) {\n          after(action.payload.delay).then(function () {\n            store.dispatch((0, _actions.completeRetry)(offlineAction));\n          });\n        }\n\n        if (action.type === _constants.OFFLINE_SEND && offlineAction && !offline.busy) {\n          (0, _send.default)(offlineAction, store.dispatch, config, offline.retryCount);\n        }\n\n        return promise || result;\n      };\n    };\n  };\n};\n\nexports.createOfflineMiddleware = createOfflineMiddleware;"]},"metadata":{},"sourceType":"script"}