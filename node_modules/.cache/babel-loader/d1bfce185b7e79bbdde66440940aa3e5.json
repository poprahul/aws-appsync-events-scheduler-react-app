{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));\n  }\n\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\n\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\n\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n/**\n * Converts a name lex token into a name parse node.\n */\n\n\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n} // Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\n\n\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SOF);\n  var definitions = [];\n\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.DOCUMENT,\n    definitions: definitions,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Definition :\n *   - OperationDefinition\n *   - FragmentDefinition\n *   - TypeSystemDefinition\n */\n\n\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      // Note: subscription is an experimental non-spec addition.\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n      // Note: the Type System IDL is an experimental non-spec addition.\n\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive':\n        return parseTypeSystemDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n} // Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\n\n\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.OPERATION_DEFINITION,\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n\n  var operation = parseOperationType(lexer);\n  var name = void 0;\n\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n\n  return {\n    kind: _kinds.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * OperationType : one of query mutation subscription\n */\n\n\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n\n    case 'mutation':\n      return 'mutation';\n    // Note: subscription is an experimental non-spec addition.\n\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\n\n\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\n\n\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : null,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Variable : $ Name\n */\n\n\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * SelectionSet : { Selection+ }\n */\n\n\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\n\n\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\n\n\nfunction parseField(lexer) {\n  var start = lexer.token;\n  var nameOrAlias = parseName(lexer);\n  var alias = void 0;\n  var name = void 0;\n\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    alias = null;\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : null,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Arguments : ( Argument+ )\n */\n\n\nfunction parseArguments(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];\n}\n/**\n * Argument : Name : Value\n */\n\n\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\n\n\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n\n  var typeCondition = null;\n\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n\n  return {\n    kind: _kinds.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\n\n\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  return {\n    kind: _kinds.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * FragmentName : Name but not `on`\n */\n\n\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n\n  return parseName(lexer);\n} // Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\n\n\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.STRING:\n      lexer.advance();\n      return {\n        kind: _kinds.STRING,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n\n      lexer.advance();\n      return {\n        kind: _kinds.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n\n      break;\n  }\n\n  throw unexpected(lexer);\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\n\n\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\n\n\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n\n  return {\n    kind: _kinds.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\n\n\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Directives section.\n\n/**\n * Directives : Directive+\n */\n\n\nfunction parseDirectives(lexer) {\n  var directives = [];\n\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer));\n  }\n\n  return directives;\n}\n/**\n * Directive : @ Name Arguments?\n */\n\n\nfunction parseDirective(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\n\n\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type = void 0;\n\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n\n  return type;\n}\n/**\n * NamedType : Name\n */\n\n\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtensionDefinition\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\n\n\nfunction parseTypeSystemDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n\n      case 'extend':\n        return parseTypeExtensionDefinition(lexer);\n\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n/**\n * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }\n *\n * OperationTypeDefinition : OperationType : NamedType\n */\n\n\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ScalarTypeDefinition : scalar Name Directives?\n */\n\n\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.SCALAR_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectTypeDefinition :\n *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }\n */\n\n\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.OBJECT_TYPE_DEFINITION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ImplementsInterfaces : implements NamedType+\n */\n\n\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n\n    do {\n      types.push(parseNamedType(lexer));\n    } while (peek(lexer, _lexer.TokenKind.NAME));\n  }\n\n  return types;\n}\n/**\n * FieldDefinition : Name ArgumentsDefinition? : Type Directives?\n */\n\n\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.FIELD_DEFINITION,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\n\n\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n/**\n * InputValueDefinition : Name : Type DefaultValue? Directives?\n */\n\n\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue = null;\n\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.INPUT_VALUE_DEFINITION,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }\n */\n\n\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * UnionTypeDefinition : union Name Directives? = UnionMembers\n */\n\n\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  expect(lexer, _lexer.TokenKind.EQUALS);\n  var types = parseUnionMembers(lexer);\n  return {\n    kind: _kinds.UNION_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * UnionMembers :\n *   - `|`? NamedType\n *   - UnionMembers | NamedType\n */\n\n\nfunction parseUnionMembers(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var members = [];\n\n  do {\n    members.push(parseNamedType(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n\n  return members;\n}\n/**\n * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }\n */\n\n\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var values = many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.ENUM_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * EnumValueDefinition : EnumValue Directives?\n *\n * EnumValue : Name\n */\n\n\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.ENUM_VALUE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }\n */\n\n\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * TypeExtensionDefinition : extend ObjectTypeDefinition\n */\n\n\nfunction parseTypeExtensionDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  var definition = parseObjectTypeDefinition(lexer);\n  return {\n    kind: _kinds.TYPE_EXTENSION_DEFINITION,\n    definition: definition,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * DirectiveDefinition :\n *   - directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\n\n\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.DIRECTIVE_DEFINITION,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * DirectiveLocations :\n *   - `|`? Name\n *   - DirectiveLocations | Name\n */\n\n\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n\n  do {\n    locations.push(parseName(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n\n  return locations;\n} // Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\n\n\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return {\n    start: this.start,\n    end: this.end\n  };\n};\n/**\n * Determines if the next token is of a given kind\n */\n\n\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\n\n\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n\n  if (match) {\n    lexer.advance();\n  }\n\n  return match;\n}\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\n\n\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\n\n\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\n\n\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\n\n\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n\n  return nodes;\n}\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\n\n\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/language/parser.js"],"names":["Object","defineProperty","exports","value","parse","parseValue","parseType","parseConstValue","parseTypeReference","parseNamedType","_source","require","_error","_lexer","_kinds","source","options","sourceObj","Source","TypeError","String","lexer","createLexer","parseDocument","expect","TokenKind","SOF","parseValueLiteral","EOF","type","parseName","token","NAME","kind","loc","start","definitions","push","parseDefinition","skip","DOCUMENT","peek","BRACE_L","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","unexpected","OPERATION_DEFINITION","operation","name","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","PAREN_L","many","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","EQUALS","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","parseArgument","ARGUMENT","FRAGMENT_SPREAD","parseFragmentName","typeCondition","advance","INLINE_FRAGMENT","expectKeyword","FRAGMENT_DEFINITION","isConst","BRACKET_L","parseList","parseObject","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","parseValueValue","item","LIST","values","any","BRACKET_R","fields","parseObjectField","OBJECT","OBJECT_FIELD","AT","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseTypeExtensionDefinition","parseDirectiveDefinition","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldDefinition","OBJECT_TYPE_DEFINITION","types","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMembers","UNION_TYPE_DEFINITION","PIPE","members","parseEnumValueDefinition","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","definition","TYPE_EXTENSION_DEFINITION","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","startToken","noLocation","Loc","lastToken","endToken","end","prototype","toJSON","inspect","match","syntaxError","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n\n/**\n * Configuration options to control parser behavior\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));\n  }\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SOF);\n  var definitions = [];\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.DOCUMENT,\n    definitions: definitions,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Definition :\n *   - OperationDefinition\n *   - FragmentDefinition\n *   - TypeSystemDefinition\n */\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      // Note: subscription is an experimental non-spec addition.\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n\n      // Note: the Type System IDL is an experimental non-spec addition.\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive':\n        return parseTypeSystemDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.OPERATION_DEFINITION,\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  var operation = parseOperationType(lexer);\n  var name = void 0;\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n  return {\n    kind: _kinds.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationType : one of query mutation subscription\n */\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n    case 'mutation':\n      return 'mutation';\n    // Note: subscription is an experimental non-spec addition.\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : null,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(lexer) {\n  var start = lexer.token;\n\n  var nameOrAlias = parseName(lexer);\n  var alias = void 0;\n  var name = void 0;\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    alias = null;\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : null,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Arguments : ( Argument+ )\n */\nfunction parseArguments(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * Argument : Name : Value\n */\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  var typeCondition = null;\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n  return {\n    kind: _kinds.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  return {\n    kind: _kinds.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n  return parseName(lexer);\n}\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.STRING:\n      lexer.advance();\n      return {\n        kind: _kinds.STRING,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n      lexer.advance();\n      return {\n        kind: _kinds.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n      break;\n  }\n  throw unexpected(lexer);\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n  return {\n    kind: _kinds.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives : Directive+\n */\nfunction parseDirectives(lexer) {\n  var directives = [];\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer));\n  }\n  return directives;\n}\n\n/**\n * Directive : @ Name Arguments?\n */\nfunction parseDirective(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type = void 0;\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtensionDefinition\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeSystemDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n      case 'extend':\n        return parseTypeExtensionDefinition(lexer);\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n\n/**\n * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }\n *\n * OperationTypeDefinition : OperationType : NamedType\n */\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ScalarTypeDefinition : scalar Name Directives?\n */\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.SCALAR_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeDefinition :\n *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }\n */\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.OBJECT_TYPE_DEFINITION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ImplementsInterfaces : implements NamedType+\n */\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n    do {\n      types.push(parseNamedType(lexer));\n    } while (peek(lexer, _lexer.TokenKind.NAME));\n  }\n  return types;\n}\n\n/**\n * FieldDefinition : Name ArgumentsDefinition? : Type Directives?\n */\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.FIELD_DEFINITION,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition : Name : Type DefaultValue? Directives?\n */\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue = null;\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.INPUT_VALUE_DEFINITION,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }\n */\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeDefinition : union Name Directives? = UnionMembers\n */\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  expect(lexer, _lexer.TokenKind.EQUALS);\n  var types = parseUnionMembers(lexer);\n  return {\n    kind: _kinds.UNION_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionMembers :\n *   - `|`? NamedType\n *   - UnionMembers | NamedType\n */\nfunction parseUnionMembers(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var members = [];\n  do {\n    members.push(parseNamedType(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n  return members;\n}\n\n/**\n * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }\n */\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var values = many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.ENUM_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumValueDefinition : EnumValue Directives?\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.ENUM_VALUE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }\n */\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * TypeExtensionDefinition : extend ObjectTypeDefinition\n */\nfunction parseTypeExtensionDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  var definition = parseObjectTypeDefinition(lexer);\n  return {\n    kind: _kinds.TYPE_EXTENSION_DEFINITION,\n    definition: definition,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveDefinition :\n *   - directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.DIRECTIVE_DEFINITION,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveLocations :\n *   - `|`? Name\n *   - DirectiveLocations | Name\n */\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n  do {\n    locations.push(parseName(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n  return locations;\n}\n\n// Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return { start: this.start, end: this.end };\n};\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n  if (match) {\n    lexer.advance();\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}"]},"metadata":{},"sourceType":"script"}