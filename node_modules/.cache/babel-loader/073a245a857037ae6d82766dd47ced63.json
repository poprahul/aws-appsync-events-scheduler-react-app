{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport isInvalid from '../jsutils/isInvalid';\nimport { Kind } from '../language/kinds';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped';\nimport { GraphQLList, GraphQLNonNull } from './wrappers'; // Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\n\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  !isType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL type.') : void 0;\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  !isScalarType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Scalar type.') : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  !isObjectType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Object type.') : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  !isInterfaceType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Interface type.') : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  !isUnionType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Union type.') : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  !isEnumType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Enum type.') : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  !isInputObjectType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Input Object type.') : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  !isListType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL List type.') : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  !isNonNullType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Non-Null type.') : void 0;\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  !isInputType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL input type.') : void 0;\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  !isOutputType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL output type.') : void 0;\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  !isLeafType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL leaf type.') : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  !isCompositeType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL composite type.') : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  !isAbstractType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL abstract type.') : void 0;\n  return type;\n}\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  !isWrappingType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL wrapping type.') : void 0;\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  !isNullableType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL nullable type.') : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  !isNamedType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL named type.') : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType = function () {\n  function GraphQLScalarType(config) {\n    _classCallCheck(this, GraphQLScalarType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._scalarConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(typeof config.serialize === 'function') ? invariant(0, this.name + ' must provide \"serialize\" function. If this custom Scalar ' + 'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.') : void 0;\n\n    if (config.parseValue || config.parseLiteral) {\n      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? invariant(0, this.name + ' must provide both \"parseValue\" and \"parseLiteral\" ' + 'functions.') : void 0;\n    }\n  } // Serializes an internal value to include in a response.\n\n\n  GraphQLScalarType.prototype.serialize = function serialize(value) {\n    var serializer = this._scalarConfig.serialize;\n    return serializer(value);\n  }; // Parses an externally provided value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseValue = function parseValue(value) {\n    var parser = this._scalarConfig.parseValue;\n\n    if (isInvalid(value)) {\n      return undefined;\n    }\n\n    return parser ? parser(value) : value;\n  }; // Parses an externally provided literal value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseLiteral = function parseLiteral(valueNode, variables) {\n    var parser = this._scalarConfig.parseLiteral;\n    return parser ? parser(valueNode, variables) : valueFromASTUntyped(valueNode, variables);\n  };\n\n  GraphQLScalarType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\nGraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect = GraphQLScalarType.prototype.toString;\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\n\nexport var GraphQLObjectType = function () {\n  function GraphQLObjectType(config) {\n    _classCallCheck(this, GraphQLObjectType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.isTypeOf = config.isTypeOf;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n\n    if (config.isTypeOf) {\n      !(typeof config.isTypeOf === 'function') ? invariant(0, this.name + ' must provide \"isTypeOf\" as a function.') : void 0;\n    }\n  }\n\n  GraphQLObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLObjectType.prototype.getInterfaces = function getInterfaces() {\n    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));\n  };\n\n  GraphQLObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\nGraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect = GraphQLObjectType.prototype.toString;\n\nfunction defineInterfaces(type, interfacesThunk) {\n  var interfaces = resolveThunk(interfacesThunk) || [];\n  !Array.isArray(interfaces) ? invariant(0, type.name + ' interfaces must be an Array or a function which returns ' + 'an Array.') : void 0;\n  return interfaces;\n}\n\nfunction defineFieldMap(type, fieldsThunk) {\n  var fieldMap = resolveThunk(fieldsThunk) || {};\n  !isPlainObj(fieldMap) ? invariant(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n  Object.keys(fieldMap).forEach(function (fieldName) {\n    var fieldConfig = fieldMap[fieldName];\n    !isPlainObj(fieldConfig) ? invariant(0, type.name + '.' + fieldName + ' field config must be an object') : void 0;\n    !!fieldConfig.hasOwnProperty('isDeprecated') ? invariant(0, type.name + '.' + fieldName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n\n    var field = _extends({}, fieldConfig, {\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      name: fieldName\n    });\n\n    !isValidResolver(field.resolve) ? invariant(0, type.name + '.' + fieldName + ' field resolver must be a function if ' + ('provided, but got: ' + String(field.resolve) + '.')) : void 0;\n    var argsConfig = fieldConfig.args;\n\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      !isPlainObj(argsConfig) ? invariant(0, type.name + '.' + fieldName + ' args must be an object with argument ' + 'names as keys.') : void 0;\n      field.args = Object.keys(argsConfig).map(function (argName) {\n        var arg = argsConfig[argName];\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n\n    resultFieldMap[fieldName] = field;\n  });\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);\n} // If a resolver is defined, it must be a function.\n\n\nfunction isValidResolver(resolver) {\n  return resolver == null || typeof resolver === 'function';\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLInterfaceType = function () {\n  function GraphQLInterfaceType(config) {\n    _classCallCheck(this, GraphQLInterfaceType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? invariant(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n  }\n\n  GraphQLInterfaceType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLInterfaceType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\nGraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect = GraphQLInterfaceType.prototype.toString;\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\n\nexport var GraphQLUnionType = function () {\n  function GraphQLUnionType(config) {\n    _classCallCheck(this, GraphQLUnionType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? invariant(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n  }\n\n  GraphQLUnionType.prototype.getTypes = function getTypes() {\n    return this._types || (this._types = defineTypes(this, this._typeConfig.types));\n  };\n\n  GraphQLUnionType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\nGraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect = GraphQLUnionType.prototype.toString;\n\nfunction defineTypes(unionType, typesThunk) {\n  var types = resolveThunk(typesThunk) || [];\n  !Array.isArray(types) ? invariant(0, 'Must provide Array of types or a function which returns ' + ('such an array for Union ' + unionType.name + '.')) : void 0;\n  return types;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\n\nexport var GraphQLEnumType\n/* <T> */\n= function () {\n  function GraphQLEnumType(config\n  /* <T> */\n  ) {\n    _classCallCheck(this, GraphQLEnumType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._enumConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  GraphQLEnumType.prototype.getValues = function getValues() {\n    return this._values || (this._values = defineEnumValues(this, this._enumConfig.values));\n  };\n\n  GraphQLEnumType.prototype.getValue = function getValue(name) {\n    return this._getNameLookup()[name];\n  };\n\n  GraphQLEnumType.prototype.serialize = function serialize(value\n  /* T */\n  ) {\n    var enumValue = this._getValueLookup().get(value);\n\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  GraphQLEnumType.prototype.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this._getNameLookup()[value];\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this._getNameLookup()[valueNode.value];\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype._getValueLookup = function _getValueLookup() {\n    if (!this._valueLookup) {\n      var lookup = new Map();\n      this.getValues().forEach(function (value) {\n        lookup.set(value.value, value);\n      });\n      this._valueLookup = lookup;\n    }\n\n    return this._valueLookup;\n  };\n\n  GraphQLEnumType.prototype._getNameLookup = function _getNameLookup() {\n    if (!this._nameLookup) {\n      var lookup = Object.create(null);\n      this.getValues().forEach(function (value) {\n        lookup[value.name] = value;\n      });\n      this._nameLookup = lookup;\n    }\n\n    return this._nameLookup;\n  };\n\n  GraphQLEnumType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\nGraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect = GraphQLEnumType.prototype.toString;\n\nfunction defineEnumValues(type, valueMap\n/* <T> */\n) {\n  !isPlainObj(valueMap) ? invariant(0, type.name + ' values must be an object with value names as keys.') : void 0;\n  return Object.keys(valueMap).map(function (valueName) {\n    var value = valueMap[valueName];\n    !isPlainObj(value) ? invariant(0, type.name + '.' + valueName + ' must refer to an object with a \"value\" key ' + ('representing an internal value but got: ' + String(value) + '.')) : void 0;\n    !!value.hasOwnProperty('isDeprecated') ? invariant(0, type.name + '.' + valueName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n    return {\n      name: valueName,\n      description: value.description,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      astNode: value.astNode,\n      value: value.hasOwnProperty('value') ? value.value : valueName\n    };\n  });\n}\n/* <T> */\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLInputObjectType = function () {\n  function GraphQLInputObjectType(config) {\n    _classCallCheck(this, GraphQLInputObjectType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  GraphQLInputObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = this._defineFieldMap());\n  };\n\n  GraphQLInputObjectType.prototype._defineFieldMap = function _defineFieldMap() {\n    var _this = this;\n\n    var fieldMap = resolveThunk(this._typeConfig.fields) || {};\n    !isPlainObj(fieldMap) ? invariant(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n    var resultFieldMap = Object.create(null);\n    Object.keys(fieldMap).forEach(function (fieldName) {\n      var field = _extends({}, fieldMap[fieldName], {\n        name: fieldName\n      });\n\n      !!field.hasOwnProperty('resolve') ? invariant(0, _this.name + '.' + fieldName + ' field type has a resolve property, but ' + 'Input Types cannot define resolvers.') : void 0;\n      resultFieldMap[fieldName] = field;\n    });\n    return resultFieldMap;\n  };\n\n  GraphQLInputObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\nGraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.toString;\nGraphQLInputObjectType.prototype.inspect = GraphQLInputObjectType.prototype.toString;","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/type/definition.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","_classCallCheck","instance","Constructor","TypeError","instanceOf","invariant","isInvalid","Kind","valueFromASTUntyped","GraphQLList","GraphQLNonNull","isType","type","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isListType","isNonNullType","assertType","String","GraphQLScalarType","assertScalarType","GraphQLObjectType","assertObjectType","GraphQLInterfaceType","assertInterfaceType","GraphQLUnionType","assertUnionType","GraphQLEnumType","assertEnumType","GraphQLInputObjectType","assertInputObjectType","assertListType","assertNonNullType","isInputType","isWrappingType","ofType","assertInputType","isOutputType","assertOutputType","isLeafType","assertLeafType","isCompositeType","assertCompositeType","isAbstractType","assertAbstractType","assertWrappingType","isNullableType","assertNullableType","getNullableType","isNamedType","assertNamedType","getNamedType","unwrappedType","resolveThunk","thunk","config","name","description","astNode","_scalarConfig","serialize","parseValue","parseLiteral","value","serializer","parser","undefined","valueNode","variables","toString","toJSON","inspect","extensionASTNodes","isTypeOf","_typeConfig","getFields","_fields","defineFieldMap","fields","getInterfaces","_interfaces","defineInterfaces","interfaces","interfacesThunk","Array","isArray","fieldsThunk","fieldMap","isPlainObj","resultFieldMap","create","keys","forEach","fieldName","fieldConfig","field","isDeprecated","Boolean","deprecationReason","isValidResolver","resolve","argsConfig","args","map","argName","arg","defaultValue","resolver","resolveType","getTypes","_types","defineTypes","types","unionType","typesThunk","_enumConfig","getValues","_values","defineEnumValues","values","getValue","_getNameLookup","enumValue","_getValueLookup","get","_variables","kind","ENUM","_valueLookup","lookup","Map","set","_nameLookup","valueMap","valueName","_defineFieldMap","_this"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport isInvalid from '../jsutils/isInvalid';\n\nimport { Kind } from '../language/kinds';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped';\n\nimport { GraphQLList, GraphQLNonNull } from './wrappers';\n\n// Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\n\n\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\n\nexport function assertType(type) {\n  !isType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL type.') : void 0;\n  return type;\n}\n\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\n\nexport function assertScalarType(type) {\n  !isScalarType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Scalar type.') : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\n\nexport function assertObjectType(type) {\n  !isObjectType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Object type.') : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\n\nexport function assertInterfaceType(type) {\n  !isInterfaceType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Interface type.') : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\n\nexport function assertUnionType(type) {\n  !isUnionType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Union type.') : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\n\nexport function assertEnumType(type) {\n  !isEnumType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Enum type.') : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\n\nexport function assertInputObjectType(type) {\n  !isInputObjectType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Input Object type.') : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\n\nexport function assertListType(type) {\n  !isListType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL List type.') : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\n\nexport function assertNonNullType(type) {\n  !isNonNullType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL Non-Null type.') : void 0;\n  return type;\n}\n\n/**\n * These types may be used as input types for arguments and directives.\n */\n\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\n\nexport function assertInputType(type) {\n  !isInputType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL input type.') : void 0;\n  return type;\n}\n\n/**\n * These types may be used as output types as the result of fields.\n */\n\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\n\nexport function assertOutputType(type) {\n  !isOutputType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL output type.') : void 0;\n  return type;\n}\n\n/**\n * These types may describe types which may be leaf values.\n */\n\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\n\nexport function assertLeafType(type) {\n  !isLeafType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL leaf type.') : void 0;\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\n\nexport function assertCompositeType(type) {\n  !isCompositeType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL composite type.') : void 0;\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\n\nexport function assertAbstractType(type) {\n  !isAbstractType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL abstract type.') : void 0;\n  return type;\n}\n\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\n\nexport function assertWrappingType(type) {\n  !isWrappingType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL wrapping type.') : void 0;\n  return type;\n}\n\n/**\n * These types can all accept null as a value.\n */\n\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\n\nexport function assertNullableType(type) {\n  !isNullableType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL nullable type.') : void 0;\n  return type;\n}\n\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\n\nexport function assertNamedType(type) {\n  !isNamedType(type) ? invariant(0, 'Expected ' + String(type) + ' to be a GraphQL named type.') : void 0;\n  return type;\n}\n\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n    return unwrappedType;\n  }\n}\n\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\n\nfunction resolveThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\nexport var GraphQLScalarType = function () {\n  function GraphQLScalarType(config) {\n    _classCallCheck(this, GraphQLScalarType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._scalarConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(typeof config.serialize === 'function') ? invariant(0, this.name + ' must provide \"serialize\" function. If this custom Scalar ' + 'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.') : void 0;\n    if (config.parseValue || config.parseLiteral) {\n      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? invariant(0, this.name + ' must provide both \"parseValue\" and \"parseLiteral\" ' + 'functions.') : void 0;\n    }\n  }\n\n  // Serializes an internal value to include in a response.\n\n\n  GraphQLScalarType.prototype.serialize = function serialize(value) {\n    var serializer = this._scalarConfig.serialize;\n    return serializer(value);\n  };\n\n  // Parses an externally provided value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseValue = function parseValue(value) {\n    var parser = this._scalarConfig.parseValue;\n    if (isInvalid(value)) {\n      return undefined;\n    }\n    return parser ? parser(value) : value;\n  };\n\n  // Parses an externally provided literal value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseLiteral = function parseLiteral(valueNode, variables) {\n    var parser = this._scalarConfig.parseLiteral;\n    return parser ? parser(valueNode, variables) : valueFromASTUntyped(valueNode, variables);\n  };\n\n  GraphQLScalarType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\nGraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect = GraphQLScalarType.prototype.toString;\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nexport var GraphQLObjectType = function () {\n  function GraphQLObjectType(config) {\n    _classCallCheck(this, GraphQLObjectType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.isTypeOf = config.isTypeOf;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    if (config.isTypeOf) {\n      !(typeof config.isTypeOf === 'function') ? invariant(0, this.name + ' must provide \"isTypeOf\" as a function.') : void 0;\n    }\n  }\n\n  GraphQLObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLObjectType.prototype.getInterfaces = function getInterfaces() {\n    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));\n  };\n\n  GraphQLObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\nGraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect = GraphQLObjectType.prototype.toString;\n\nfunction defineInterfaces(type, interfacesThunk) {\n  var interfaces = resolveThunk(interfacesThunk) || [];\n  !Array.isArray(interfaces) ? invariant(0, type.name + ' interfaces must be an Array or a function which returns ' + 'an Array.') : void 0;\n  return interfaces;\n}\n\nfunction defineFieldMap(type, fieldsThunk) {\n  var fieldMap = resolveThunk(fieldsThunk) || {};\n  !isPlainObj(fieldMap) ? invariant(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n\n  var resultFieldMap = Object.create(null);\n  Object.keys(fieldMap).forEach(function (fieldName) {\n    var fieldConfig = fieldMap[fieldName];\n    !isPlainObj(fieldConfig) ? invariant(0, type.name + '.' + fieldName + ' field config must be an object') : void 0;\n    !!fieldConfig.hasOwnProperty('isDeprecated') ? invariant(0, type.name + '.' + fieldName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n    var field = _extends({}, fieldConfig, {\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      name: fieldName\n    });\n    !isValidResolver(field.resolve) ? invariant(0, type.name + '.' + fieldName + ' field resolver must be a function if ' + ('provided, but got: ' + String(field.resolve) + '.')) : void 0;\n    var argsConfig = fieldConfig.args;\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      !isPlainObj(argsConfig) ? invariant(0, type.name + '.' + fieldName + ' args must be an object with argument ' + 'names as keys.') : void 0;\n      field.args = Object.keys(argsConfig).map(function (argName) {\n        var arg = argsConfig[argName];\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n    resultFieldMap[fieldName] = field;\n  });\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);\n}\n\n// If a resolver is defined, it must be a function.\nfunction isValidResolver(resolver) {\n  return resolver == null || typeof resolver === 'function';\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nexport var GraphQLInterfaceType = function () {\n  function GraphQLInterfaceType(config) {\n    _classCallCheck(this, GraphQLInterfaceType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? invariant(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n  }\n\n  GraphQLInterfaceType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLInterfaceType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\nGraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect = GraphQLInterfaceType.prototype.toString;\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nexport var GraphQLUnionType = function () {\n  function GraphQLUnionType(config) {\n    _classCallCheck(this, GraphQLUnionType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? invariant(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n  }\n\n  GraphQLUnionType.prototype.getTypes = function getTypes() {\n    return this._types || (this._types = defineTypes(this, this._typeConfig.types));\n  };\n\n  GraphQLUnionType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\nGraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect = GraphQLUnionType.prototype.toString;\n\nfunction defineTypes(unionType, typesThunk) {\n  var types = resolveThunk(typesThunk) || [];\n  !Array.isArray(types) ? invariant(0, 'Must provide Array of types or a function which returns ' + ('such an array for Union ' + unionType.name + '.')) : void 0;\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport var GraphQLEnumType /* <T> */ = function () {\n  function GraphQLEnumType(config /* <T> */) {\n    _classCallCheck(this, GraphQLEnumType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._enumConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  GraphQLEnumType.prototype.getValues = function getValues() {\n    return this._values || (this._values = defineEnumValues(this, this._enumConfig.values));\n  };\n\n  GraphQLEnumType.prototype.getValue = function getValue(name) {\n    return this._getNameLookup()[name];\n  };\n\n  GraphQLEnumType.prototype.serialize = function serialize(value /* T */) {\n    var enumValue = this._getValueLookup().get(value);\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  GraphQLEnumType.prototype.parseValue = function parseValue(value) /* T */{\n    if (typeof value === 'string') {\n      var enumValue = this._getNameLookup()[value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype.parseLiteral = function parseLiteral(valueNode, _variables) /* T */{\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this._getNameLookup()[valueNode.value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype._getValueLookup = function _getValueLookup() {\n    if (!this._valueLookup) {\n      var lookup = new Map();\n      this.getValues().forEach(function (value) {\n        lookup.set(value.value, value);\n      });\n      this._valueLookup = lookup;\n    }\n    return this._valueLookup;\n  };\n\n  GraphQLEnumType.prototype._getNameLookup = function _getNameLookup() {\n    if (!this._nameLookup) {\n      var lookup = Object.create(null);\n      this.getValues().forEach(function (value) {\n        lookup[value.name] = value;\n      });\n      this._nameLookup = lookup;\n    }\n    return this._nameLookup;\n  };\n\n  GraphQLEnumType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\nGraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect = GraphQLEnumType.prototype.toString;\n\nfunction defineEnumValues(type, valueMap /* <T> */\n) {\n  !isPlainObj(valueMap) ? invariant(0, type.name + ' values must be an object with value names as keys.') : void 0;\n  return Object.keys(valueMap).map(function (valueName) {\n    var value = valueMap[valueName];\n    !isPlainObj(value) ? invariant(0, type.name + '.' + valueName + ' must refer to an object with a \"value\" key ' + ('representing an internal value but got: ' + String(value) + '.')) : void 0;\n    !!value.hasOwnProperty('isDeprecated') ? invariant(0, type.name + '.' + valueName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n    return {\n      name: valueName,\n      description: value.description,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      astNode: value.astNode,\n      value: value.hasOwnProperty('value') ? value.value : valueName\n    };\n  });\n} /* <T> */\n\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nexport var GraphQLInputObjectType = function () {\n  function GraphQLInputObjectType(config) {\n    _classCallCheck(this, GraphQLInputObjectType);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._typeConfig = config;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  GraphQLInputObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = this._defineFieldMap());\n  };\n\n  GraphQLInputObjectType.prototype._defineFieldMap = function _defineFieldMap() {\n    var _this = this;\n\n    var fieldMap = resolveThunk(this._typeConfig.fields) || {};\n    !isPlainObj(fieldMap) ? invariant(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n    var resultFieldMap = Object.create(null);\n    Object.keys(fieldMap).forEach(function (fieldName) {\n      var field = _extends({}, fieldMap[fieldName], {\n        name: fieldName\n      });\n      !!field.hasOwnProperty('resolve') ? invariant(0, _this.name + '.' + fieldName + ' field type has a resolve property, but ' + 'Input Types cannot define resolvers.') : void 0;\n      resultFieldMap[fieldName] = field;\n    });\n    return resultFieldMap;\n  };\n\n  GraphQLInputObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\nGraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.toString;\nGraphQLInputObjectType.prototype.inspect = GraphQLInputObjectType.prototype.toString;"]},"metadata":{},"sourceType":"module"}