{"ast":null,"code":"import { createContext, createElement, Component } from 'react';\nimport { object, func, node, string, bool, number, oneOfType, arrayOf, any } from 'prop-types';\nimport { InvariantError, invariant } from 'ts-invariant';\nimport { __extends, __assign, __rest } from 'tslib';\nimport { ApolloError, NetworkStatus } from 'apollo-client';\nimport isEqual from 'lodash.isequal';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nvar ApolloContext = createContext && createContext(undefined);\n\nvar ApolloConsumer = function (props, legacyContext) {\n  function finish(context) {\n    if (!context || !context.client) {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError() : new InvariantError('Could not find \"client\" in the context of ApolloConsumer. ' + 'Wrap the root component in an <ApolloProvider>.');\n    }\n\n    return props.children(context.client);\n  }\n\n  return ApolloContext ? createElement(ApolloContext.Consumer, null, finish) : finish(legacyContext);\n};\n\nApolloConsumer.contextTypes = {\n  client: object.isRequired\n};\nApolloConsumer.propTypes = {\n  children: func.isRequired\n};\n\nvar ApolloProvider = function (_super) {\n  __extends(ApolloProvider, _super);\n\n  function ApolloProvider(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.operations = new Map();\n    process.env.NODE_ENV === \"production\" ? invariant(props.client) : invariant(props.client, 'ApolloProvider was not passed a client instance. Make ' + 'sure you pass in your client via the \"client\" prop.');\n\n    if (!props.client.__operations_cache__) {\n      props.client.__operations_cache__ = _this.operations;\n    }\n\n    return _this;\n  }\n\n  ApolloProvider.prototype.getChildContext = function () {\n    return {\n      client: this.props.client,\n      operations: this.props.client.__operations_cache__\n    };\n  };\n\n  ApolloProvider.prototype.render = function () {\n    return ApolloContext ? createElement(ApolloContext.Provider, {\n      value: this.getChildContext()\n    }, this.props.children) : this.props.children;\n  };\n\n  ApolloProvider.propTypes = {\n    client: object.isRequired,\n    children: node.isRequired\n  };\n  ApolloProvider.childContextTypes = {\n    client: object.isRequired,\n    operations: object\n  };\n  return ApolloProvider;\n}(Component);\n\nvar DocumentType;\n\n(function (DocumentType) {\n  DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n  DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n  DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\n\nvar cache = new Map();\n\nfunction parser(document) {\n  var cached = cache.get(document);\n  if (cached) return cached;\n  var variables, type, name;\n  process.env.NODE_ENV === \"production\" ? invariant(!!document && !!document.kind) : invariant(!!document && !!document.kind, \"Argument of \" + document + \" passed to parser was not a valid GraphQL \" + \"DocumentNode. You may need to use 'graphql-tag' or another method \" + \"to convert your operation into a document\");\n  var fragments = document.definitions.filter(function (x) {\n    return x.kind === 'FragmentDefinition';\n  });\n  var queries = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'query';\n  });\n  var mutations = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'mutation';\n  });\n  var subscriptions = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'subscription';\n  });\n  process.env.NODE_ENV === \"production\" ? invariant(!fragments.length || queries.length || mutations.length || subscriptions.length) : invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, \"Passing only a fragment to 'graphql' is not yet supported. \" + \"You must include a query, subscription or mutation as well\");\n  process.env.NODE_ENV === \"production\" ? invariant(queries.length + mutations.length + subscriptions.length <= 1) : invariant(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" + (document + \" had \" + queries.length + \" queries, \" + subscriptions.length + \" \") + (\"subscriptions and \" + mutations.length + \" mutations. \") + \"You can use 'compose' to join multiple operation types to a component\");\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;\n  process.env.NODE_ENV === \"production\" ? invariant(definitions.length === 1) : invariant(definitions.length === 1, \"react-apollo only supports one definition per HOC. \" + document + \" had \" + (definitions.length + \" definitions. \") + \"You can use 'compose' to join multiple operation types to a component\");\n  var definition = definitions[0];\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data';\n  }\n\n  var payload = {\n    name: name,\n    type: type,\n    variables: variables\n  };\n  cache.set(document, payload);\n  return payload;\n}\n\nfunction getClient(props, context) {\n  var client = props.client || context.client;\n  process.env.NODE_ENV === \"production\" ? invariant(!!client) : invariant(!!client, 'Could not find \"client\" in the context or passed in as a prop. ' + 'Wrap the root component in an <ApolloProvider>, or pass an ' + 'ApolloClient instance in via props.');\n  return client;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  }\n\n  return x !== x && y !== y;\n}\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\n\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (!isObject(objA) || !isObject(objB)) {\n    return false;\n  }\n\n  var keys = Object.keys(objA);\n\n  if (keys.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keys.every(function (key) {\n    return hasOwnProperty.call(objB, key) && is(objA[key], objB[key]);\n  });\n}\n\nfunction observableQueryFields(observable) {\n  var fields = {\n    variables: observable.variables,\n    refetch: observable.refetch.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable)\n  };\n  return fields;\n}\n\nvar Query = function (_super) {\n  __extends(Query, _super);\n\n  function Query(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.hasMounted = false;\n    _this.lastRenderedResult = null;\n\n    _this.startQuerySubscription = function () {\n      if (_this.querySubscription) return;\n      _this.querySubscription = _this.queryObservable.subscribe({\n        next: function (result) {\n          if (_this.lastRenderedResult && _this.lastRenderedResult.loading === result.loading && _this.lastRenderedResult.networkStatus === result.networkStatus && shallowEqual(_this.lastRenderedResult.data, result.data)) {\n            return;\n          }\n\n          _this.updateCurrentData();\n        },\n        error: function (error) {\n          _this.resubscribeToQuery();\n\n          if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n          _this.updateCurrentData();\n        }\n      });\n    };\n\n    _this.removeQuerySubscription = function () {\n      if (_this.querySubscription) {\n        _this.querySubscription.unsubscribe();\n\n        delete _this.lastRenderedResult;\n        delete _this.querySubscription;\n      }\n    };\n\n    _this.updateCurrentData = function () {\n      _this.handleErrorOrCompleted();\n\n      if (_this.hasMounted) _this.forceUpdate();\n    };\n\n    _this.handleErrorOrCompleted = function () {\n      var result = _this.queryObservable.currentResult();\n\n      var data = result.data,\n          loading = result.loading,\n          error = result.error;\n      var _a = _this.props,\n          onCompleted = _a.onCompleted,\n          onError = _a.onError;\n\n      if (onCompleted && !loading && !error) {\n        onCompleted(data);\n      } else if (onError && !loading && error) {\n        onError(error);\n      }\n    };\n\n    _this.getQueryResult = function () {\n      var result = {\n        data: Object.create(null)\n      };\n      Object.assign(result, observableQueryFields(_this.queryObservable));\n\n      if (_this.props.skip) {\n        result = __assign({}, result, {\n          data: undefined,\n          error: undefined,\n          loading: false\n        });\n      } else {\n        var currentResult = _this.queryObservable.currentResult();\n\n        var loading = currentResult.loading,\n            partial = currentResult.partial,\n            networkStatus = currentResult.networkStatus,\n            errors = currentResult.errors;\n        var error = currentResult.error;\n\n        if (errors && errors.length > 0) {\n          error = new ApolloError({\n            graphQLErrors: errors\n          });\n        }\n\n        var fetchPolicy = _this.queryObservable.options.fetchPolicy;\n        Object.assign(result, {\n          loading: loading,\n          networkStatus: networkStatus,\n          error: error\n        });\n        var previousData = _this.lastRenderedResult ? _this.lastRenderedResult.data : {};\n\n        if (loading) {\n          Object.assign(result.data, previousData, currentResult.data);\n        } else if (error) {\n          Object.assign(result, {\n            data: (_this.queryObservable.getLastResult() || {}).data\n          });\n        } else if (fetchPolicy === 'no-cache' && Object.keys(currentResult.data).length === 0) {\n          result.data = previousData;\n        } else {\n          var partialRefetch = _this.props.partialRefetch;\n\n          if (partialRefetch && currentResult.data !== null && typeof currentResult.data === 'object' && Object.keys(currentResult.data).length === 0 && partial && fetchPolicy !== 'cache-only') {\n            Object.assign(result, {\n              loading: true,\n              networkStatus: NetworkStatus.loading\n            });\n            result.refetch();\n            _this.lastRenderedResult = result;\n            return result;\n          }\n\n          Object.assign(result.data, currentResult.data);\n        }\n      }\n\n      if (!_this.querySubscription) {\n        var oldRefetch_1 = result.refetch;\n\n        result.refetch = function (args) {\n          if (_this.querySubscription) {\n            return oldRefetch_1(args);\n          } else {\n            return new Promise(function (r, f) {\n              _this.refetcherQueue = {\n                resolve: r,\n                reject: f,\n                args: args\n              };\n            });\n          }\n        };\n      }\n\n      setTimeout(function () {\n        if (_this.queryObservable.resetQueryStoreErrors) {\n          _this.queryObservable.resetQueryStoreErrors();\n        } else {\n          var _a = _this.queryObservable,\n              queryManager = _a.queryManager,\n              queryId = _a.queryId;\n          var queryStore = queryManager.queryStore.get(queryId);\n\n          if (queryStore) {\n            queryStore.networkError = null;\n            queryStore.graphQLErrors = [];\n          }\n        }\n      });\n      result.client = _this.client;\n      _this.lastRenderedResult = result;\n      return result;\n    };\n\n    _this.client = getClient(props, context);\n\n    _this.initializeQueryObservable(props);\n\n    return _this;\n  }\n\n  Query.prototype.fetchData = function () {\n    if (this.props.skip) return false;\n\n    var _a = this.props,\n        children = _a.children,\n        ssr = _a.ssr,\n        displayName = _a.displayName,\n        skip = _a.skip,\n        client = _a.client,\n        onCompleted = _a.onCompleted,\n        onError = _a.onError,\n        partialRefetch = _a.partialRefetch,\n        opts = __rest(_a, [\"children\", \"ssr\", \"displayName\", \"skip\", \"client\", \"onCompleted\", \"onError\", \"partialRefetch\"]);\n\n    var fetchPolicy = opts.fetchPolicy;\n    if (ssr === false) return false;\n\n    if (fetchPolicy === 'network-only' || fetchPolicy === 'cache-and-network') {\n      fetchPolicy = 'cache-first';\n    }\n\n    var observable = this.client.watchQuery(__assign({}, opts, {\n      fetchPolicy: fetchPolicy\n    }));\n\n    if (this.context && this.context.renderPromises) {\n      this.context.renderPromises.registerSSRObservable(this, observable);\n    }\n\n    var result = this.queryObservable.currentResult();\n    return result.loading ? observable.result() : false;\n  };\n\n  Query.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n    if (this.props.skip) return;\n    this.startQuerySubscription();\n\n    if (this.refetcherQueue) {\n      var _a = this.refetcherQueue,\n          args = _a.args,\n          resolve = _a.resolve,\n          reject = _a.reject;\n      this.queryObservable.refetch(args).then(resolve).catch(reject);\n    }\n  };\n\n  Query.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    if (nextProps.skip && !this.props.skip) {\n      this.queryObservable.resetLastResults();\n      this.removeQuerySubscription();\n      return;\n    }\n\n    var nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.removeQuerySubscription();\n      this.queryObservable = null;\n    }\n\n    if (this.props.query !== nextProps.query) {\n      this.queryObservable.resetLastResults();\n      this.removeQuerySubscription();\n    }\n\n    this.updateQuery(nextProps);\n    if (nextProps.skip) return;\n    this.startQuerySubscription();\n  };\n\n  Query.prototype.componentWillUnmount = function () {\n    this.removeQuerySubscription();\n    this.hasMounted = false;\n  };\n\n  Query.prototype.componentDidUpdate = function (prevProps) {\n    var isDiffRequest = !isEqual(prevProps.query, this.props.query) || !isEqual(prevProps.variables, this.props.variables);\n\n    if (isDiffRequest) {\n      this.handleErrorOrCompleted();\n    }\n  };\n\n  Query.prototype.render = function () {\n    var _this = this;\n\n    var context = this.context;\n\n    var finish = function () {\n      return _this.props.children(_this.getQueryResult());\n    };\n\n    if (context && context.renderPromises) {\n      return context.renderPromises.addQueryPromise(this, finish);\n    }\n\n    return finish();\n  };\n\n  Query.prototype.extractOptsFromProps = function (props) {\n    this.operation = parser(props.query);\n    process.env.NODE_ENV === \"production\" ? invariant(this.operation.type === DocumentType.Query) : invariant(this.operation.type === DocumentType.Query, \"The <Query /> component requires a graphql query, but got a \" + (this.operation.type === DocumentType.Mutation ? 'mutation' : 'subscription') + \".\");\n    var displayName = props.displayName || 'Query';\n    return __assign({}, props, {\n      displayName: displayName,\n      context: props.context || {},\n      metadata: {\n        reactComponent: {\n          displayName: displayName\n        }\n      }\n    });\n  };\n\n  Query.prototype.initializeQueryObservable = function (props) {\n    var opts = this.extractOptsFromProps(props);\n    this.setOperations(opts);\n\n    if (this.context && this.context.renderPromises) {\n      this.queryObservable = this.context.renderPromises.getSSRObservable(this);\n    }\n\n    if (!this.queryObservable) {\n      this.queryObservable = this.client.watchQuery(opts);\n    }\n  };\n\n  Query.prototype.setOperations = function (props) {\n    if (this.context.operations) {\n      this.context.operations.set(this.operation.name, {\n        query: props.query,\n        variables: props.variables\n      });\n    }\n  };\n\n  Query.prototype.updateQuery = function (props) {\n    if (!this.queryObservable) {\n      this.initializeQueryObservable(props);\n    } else {\n      this.setOperations(props);\n    }\n\n    this.queryObservable.setOptions(this.extractOptsFromProps(props)).catch(function () {\n      return null;\n    });\n  };\n\n  Query.prototype.resubscribeToQuery = function () {\n    this.removeQuerySubscription();\n    var lastError = this.queryObservable.getLastError();\n    var lastResult = this.queryObservable.getLastResult();\n    this.queryObservable.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.queryObservable, {\n      lastError: lastError,\n      lastResult: lastResult\n    });\n  };\n\n  Query.contextTypes = {\n    client: object,\n    operations: object,\n    renderPromises: object\n  };\n  Query.propTypes = {\n    client: object,\n    children: func.isRequired,\n    fetchPolicy: string,\n    notifyOnNetworkStatusChange: bool,\n    onCompleted: func,\n    onError: func,\n    pollInterval: number,\n    query: object.isRequired,\n    variables: object,\n    ssr: bool,\n    partialRefetch: bool,\n    returnPartialData: bool\n  };\n  return Query;\n}(Component);\n\nvar initialState = {\n  loading: false,\n  called: false,\n  error: undefined,\n  data: undefined\n};\n\nvar Mutation = function (_super) {\n  __extends(Mutation, _super);\n\n  function Mutation(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.hasMounted = false;\n\n    _this.runMutation = function (options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      _this.onMutationStart();\n\n      var mutationId = _this.generateNewMutationId();\n\n      return _this.mutate(options).then(function (response) {\n        _this.onMutationCompleted(response, mutationId);\n\n        return response;\n      }).catch(function (e) {\n        _this.onMutationError(e, mutationId);\n\n        if (!_this.props.onError) throw e;\n      });\n    };\n\n    _this.mutate = function (options) {\n      var _a = _this.props,\n          mutation = _a.mutation,\n          variables = _a.variables,\n          optimisticResponse = _a.optimisticResponse,\n          update = _a.update,\n          _b = _a.context,\n          context = _b === void 0 ? {} : _b,\n          _c = _a.awaitRefetchQueries,\n          awaitRefetchQueries = _c === void 0 ? false : _c,\n          fetchPolicy = _a.fetchPolicy;\n\n      var mutateOptions = __assign({}, options);\n\n      var refetchQueries = mutateOptions.refetchQueries || _this.props.refetchQueries;\n\n      if (refetchQueries && refetchQueries.length && Array.isArray(refetchQueries)) {\n        refetchQueries = refetchQueries.map(function (x) {\n          if (typeof x === 'string' && _this.context.operations) return _this.context.operations.get(x) || x;\n          return x;\n        });\n        delete mutateOptions.refetchQueries;\n      }\n\n      var mutateVariables = Object.assign({}, variables, mutateOptions.variables);\n      delete mutateOptions.variables;\n      return _this.client.mutate(__assign({\n        mutation: mutation,\n        optimisticResponse: optimisticResponse,\n        refetchQueries: refetchQueries,\n        awaitRefetchQueries: awaitRefetchQueries,\n        update: update,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        variables: mutateVariables\n      }, mutateOptions));\n    };\n\n    _this.onMutationStart = function () {\n      if (!_this.state.loading && !_this.props.ignoreResults) {\n        _this.setState({\n          loading: true,\n          error: undefined,\n          data: undefined,\n          called: true\n        });\n      }\n    };\n\n    _this.onMutationCompleted = function (response, mutationId) {\n      var _a = _this.props,\n          onCompleted = _a.onCompleted,\n          ignoreResults = _a.ignoreResults;\n      var data = response.data,\n          errors = response.errors;\n      var error = errors && errors.length > 0 ? new ApolloError({\n        graphQLErrors: errors\n      }) : undefined;\n\n      var callOncomplete = function () {\n        return onCompleted ? onCompleted(data) : null;\n      };\n\n      if (_this.hasMounted && _this.isMostRecentMutation(mutationId) && !ignoreResults) {\n        _this.setState({\n          loading: false,\n          data: data,\n          error: error\n        }, callOncomplete);\n      } else {\n        callOncomplete();\n      }\n    };\n\n    _this.onMutationError = function (error, mutationId) {\n      var onError = _this.props.onError;\n\n      var callOnError = function () {\n        return onError ? onError(error) : null;\n      };\n\n      if (_this.hasMounted && _this.isMostRecentMutation(mutationId)) {\n        _this.setState({\n          loading: false,\n          error: error\n        }, callOnError);\n      } else {\n        callOnError();\n      }\n    };\n\n    _this.generateNewMutationId = function () {\n      _this.mostRecentMutationId = _this.mostRecentMutationId + 1;\n      return _this.mostRecentMutationId;\n    };\n\n    _this.isMostRecentMutation = function (mutationId) {\n      return _this.mostRecentMutationId === mutationId;\n    };\n\n    _this.verifyDocumentIsMutation = function (mutation) {\n      var operation = parser(mutation);\n      process.env.NODE_ENV === \"production\" ? invariant(operation.type === DocumentType.Mutation) : invariant(operation.type === DocumentType.Mutation, \"The <Mutation /> component requires a graphql mutation, but got a \" + (operation.type === DocumentType.Query ? 'query' : 'subscription') + \".\");\n    };\n\n    _this.client = getClient(props, context);\n\n    _this.verifyDocumentIsMutation(props.mutation);\n\n    _this.mostRecentMutationId = 0;\n    _this.state = initialState;\n    return _this;\n  }\n\n  Mutation.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  Mutation.prototype.componentWillUnmount = function () {\n    this.hasMounted = false;\n  };\n\n  Mutation.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    var nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.props.mutation !== nextProps.mutation) {\n      this.verifyDocumentIsMutation(nextProps.mutation);\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.setState(initialState);\n    }\n  };\n\n  Mutation.prototype.render = function () {\n    var children = this.props.children;\n    var _a = this.state,\n        loading = _a.loading,\n        data = _a.data,\n        error = _a.error,\n        called = _a.called;\n    var result = {\n      called: called,\n      loading: loading,\n      data: data,\n      error: error,\n      client: this.client\n    };\n    return children(this.runMutation, result);\n  };\n\n  Mutation.contextTypes = {\n    client: object,\n    operations: object\n  };\n  Mutation.propTypes = {\n    mutation: object.isRequired,\n    variables: object,\n    optimisticResponse: object,\n    refetchQueries: oneOfType([arrayOf(oneOfType([string, object])), func]),\n    awaitRefetchQueries: bool,\n    update: func,\n    children: func.isRequired,\n    onCompleted: func,\n    onError: func,\n    fetchPolicy: string\n  };\n  return Mutation;\n}(Component);\n\nvar Subscription = function (_super) {\n  __extends(Subscription, _super);\n\n  function Subscription(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.initialize = function (props) {\n      if (_this.queryObservable) return;\n      _this.queryObservable = _this.client.subscribe({\n        query: props.subscription,\n        variables: props.variables,\n        fetchPolicy: props.fetchPolicy\n      });\n    };\n\n    _this.startSubscription = function () {\n      if (_this.querySubscription) return;\n      _this.querySubscription = _this.queryObservable.subscribe({\n        next: _this.updateCurrentData,\n        error: _this.updateError,\n        complete: _this.completeSubscription\n      });\n    };\n\n    _this.getInitialState = function () {\n      return {\n        loading: true,\n        error: undefined,\n        data: undefined\n      };\n    };\n\n    _this.updateCurrentData = function (result) {\n      var _a = _this,\n          client = _a.client,\n          onSubscriptionData = _a.props.onSubscriptionData;\n\n      _this.setState({\n        data: result.data,\n        loading: false,\n        error: undefined\n      });\n\n      if (onSubscriptionData) onSubscriptionData({\n        client: client,\n        subscriptionData: result\n      });\n    };\n\n    _this.updateError = function (error) {\n      _this.setState({\n        error: error,\n        loading: false\n      });\n    };\n\n    _this.completeSubscription = function () {\n      var onSubscriptionComplete = _this.props.onSubscriptionComplete;\n      if (onSubscriptionComplete) onSubscriptionComplete();\n\n      _this.endSubscription();\n    };\n\n    _this.endSubscription = function () {\n      if (_this.querySubscription) {\n        _this.querySubscription.unsubscribe();\n\n        delete _this.querySubscription;\n      }\n    };\n\n    _this.client = getClient(props, context);\n\n    _this.initialize(props);\n\n    _this.state = _this.getInitialState();\n    return _this;\n  }\n\n  Subscription.prototype.componentDidMount = function () {\n    this.startSubscription();\n  };\n\n  Subscription.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    var nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props.variables, nextProps.variables) && this.client === nextClient && this.props.subscription === nextProps.subscription) {\n      return;\n    }\n\n    var shouldResubscribe = nextProps.shouldResubscribe;\n\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.props, nextProps);\n    }\n\n    var shouldNotResubscribe = shouldResubscribe === false;\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n    }\n\n    if (!shouldNotResubscribe) {\n      this.endSubscription();\n      delete this.queryObservable;\n      this.initialize(nextProps);\n      this.startSubscription();\n      this.setState(this.getInitialState());\n      return;\n    }\n\n    this.initialize(nextProps);\n    this.startSubscription();\n  };\n\n  Subscription.prototype.componentWillUnmount = function () {\n    this.endSubscription();\n  };\n\n  Subscription.prototype.render = function () {\n    var renderFn = this.props.children;\n    if (!renderFn) return null;\n    var result = Object.assign({}, this.state, {\n      variables: this.props.variables\n    });\n    return renderFn(result);\n  };\n\n  Subscription.contextTypes = {\n    client: object\n  };\n  Subscription.propTypes = {\n    subscription: object.isRequired,\n    variables: object,\n    children: func,\n    onSubscriptionData: func,\n    onSubscriptionComplete: func,\n    shouldResubscribe: oneOfType([func, bool])\n  };\n  return Subscription;\n}(Component);\n\nvar defaultMapPropsToOptions = function () {\n  return {};\n};\n\nvar defaultMapPropsToSkip = function () {\n  return false;\n};\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction calculateVariablesFromProps(operation, props) {\n  var variables = {};\n\n  for (var _i = 0, _a = operation.variables; _i < _a.length; _i++) {\n    var _b = _a[_i],\n        variable = _b.variable,\n        type = _b.type;\n    if (!variable.name || !variable.name.value) continue;\n    var variableName = variable.name.value;\n    var variableProp = props[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n\n  return variables;\n}\n\nvar GraphQLBase = function (_super) {\n  __extends(GraphQLBase, _super);\n\n  function GraphQLBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.withRef = false;\n    _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n    return _this;\n  }\n\n  GraphQLBase.prototype.getWrappedInstance = function () {\n    process.env.NODE_ENV === \"production\" ? invariant(this.withRef) : invariant(this.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n    return this.wrappedInstance;\n  };\n\n  GraphQLBase.prototype.setWrappedInstance = function (ref) {\n    this.wrappedInstance = ref;\n  };\n\n  return GraphQLBase;\n}(Component);\n\nfunction withQuery(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.skip,\n      skip = _b === void 0 ? defaultMapPropsToSkip : _b,\n      _c = operationOptions.alias,\n      alias = _c === void 0 ? 'Apollo' : _c;\n  var mapPropsToOptions = options;\n\n  if (typeof mapPropsToOptions !== 'function') {\n    mapPropsToOptions = function () {\n      return options;\n    };\n  }\n\n  var mapPropsToSkip = skip;\n\n  if (typeof mapPropsToSkip !== 'function') {\n    mapPropsToSkip = function () {\n      return skip;\n    };\n  }\n\n  var lastResultProps;\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var _this = this;\n\n        var props = this.props;\n        var shouldSkip = mapPropsToSkip(props);\n        var opts = shouldSkip ? Object.create(null) : __assign({}, mapPropsToOptions(props));\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return createElement(Query, __assign({}, opts, {\n          displayName: graphQLDisplayName,\n          skip: shouldSkip,\n          query: document,\n          warnUnhandledError: true\n        }), function (_a) {\n          var _b, _c;\n\n          var _ = _a.client,\n              data = _a.data,\n              r = __rest(_a, [\"client\", \"data\"]);\n\n          if (operationOptions.withRef) {\n            _this.withRef = true;\n            props = Object.assign({}, props, {\n              ref: _this.setWrappedInstance\n            });\n          }\n\n          if (shouldSkip) {\n            return createElement(WrappedComponent, __assign({}, props, {}));\n          }\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'data';\n          var childProps = (_b = {}, _b[name] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = result, _c.ownProps = props, _c);\n            lastResultProps = operationOptions.props(newResult, lastResultProps);\n            childProps = lastResultProps;\n          }\n\n          return createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction withMutation(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.alias,\n      alias = _b === void 0 ? 'Apollo' : _b;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function () {\n    return options;\n  };\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var props = this.props;\n        var opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return createElement(Mutation, __assign({}, opts, {\n          mutation: document,\n          ignoreResults: true\n        }), function (mutate, _a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'mutate';\n          var resultName = operationOptions.name ? name + \"Result\" : 'result';\n          var childProps = (_b = {}, _b[name] = mutate, _b[resultName] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = mutate, _c[resultName] = result, _c.ownProps = props, _c);\n            childProps = operationOptions.props(newResult);\n          }\n\n          return createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction withSubscription(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.skip,\n      skip = _b === void 0 ? defaultMapPropsToSkip : _b,\n      _c = operationOptions.alias,\n      alias = _c === void 0 ? 'Apollo' : _c,\n      shouldResubscribe = operationOptions.shouldResubscribe;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function () {\n    return options;\n  };\n  var mapPropsToSkip = skip;\n  if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = function () {\n    return skip;\n  };\n  var lastResultProps;\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL(props) {\n        var _this = _super.call(this, props) || this;\n\n        _this.state = {\n          resubscribe: false\n        };\n        return _this;\n      }\n\n      GraphQL.prototype.componentWillReceiveProps = function (nextProps) {\n        if (!shouldResubscribe) return;\n        this.setState({\n          resubscribe: shouldResubscribe(this.props, nextProps)\n        });\n      };\n\n      GraphQL.prototype.render = function () {\n        var _this = this;\n\n        var props = this.props;\n        var shouldSkip = mapPropsToSkip(props);\n        var opts = shouldSkip ? Object.create(null) : mapPropsToOptions(props);\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return createElement(Subscription, __assign({}, opts, {\n          displayName: graphQLDisplayName,\n          skip: shouldSkip,\n          subscription: document,\n          shouldResubscribe: this.state.resubscribe\n        }), function (_a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          if (operationOptions.withRef) {\n            _this.withRef = true;\n            props = Object.assign({}, props, {\n              ref: _this.setWrappedInstance\n            });\n          }\n\n          if (shouldSkip) {\n            return createElement(WrappedComponent, __assign({}, props, {}));\n          }\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'data';\n          var childProps = (_b = {}, _b[name] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = result, _c.ownProps = props, _c);\n            lastResultProps = operationOptions.props(newResult, lastResultProps);\n            childProps = lastResultProps;\n          }\n\n          return createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction graphql(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  switch (parser(document).type) {\n    case DocumentType.Mutation:\n      return withMutation(document, operationOptions);\n\n    case DocumentType.Subscription:\n      return withSubscription(document, operationOptions);\n\n    case DocumentType.Query:\n    default:\n      return withQuery(document, operationOptions);\n  }\n}\n\nfunction getDisplayName$1(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction withApollo(WrappedComponent, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var withDisplayName = \"withApollo(\" + getDisplayName$1(WrappedComponent) + \")\";\n\n  var WithApollo = function (_super) {\n    __extends(WithApollo, _super);\n\n    function WithApollo(props) {\n      var _this = _super.call(this, props) || this;\n\n      _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n      return _this;\n    }\n\n    WithApollo.prototype.getWrappedInstance = function () {\n      process.env.NODE_ENV === \"production\" ? invariant(operationOptions.withRef) : invariant(operationOptions.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n      return this.wrappedInstance;\n    };\n\n    WithApollo.prototype.setWrappedInstance = function (ref) {\n      this.wrappedInstance = ref;\n    };\n\n    WithApollo.prototype.render = function () {\n      var _this = this;\n\n      return createElement(ApolloConsumer, null, function (client) {\n        var props = Object.assign({}, _this.props, {\n          client: client,\n          ref: operationOptions.withRef ? _this.setWrappedInstance : undefined\n        });\n        return createElement(WrappedComponent, __assign({}, props));\n      });\n    };\n\n    WithApollo.displayName = withDisplayName;\n    WithApollo.WrappedComponent = WrappedComponent;\n    return WithApollo;\n  }(Component);\n\n  return hoistNonReactStatics(WithApollo, WrappedComponent, {});\n}\n\nfunction makeDefaultQueryInfo() {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nvar RenderPromises = function () {\n  function RenderPromises() {\n    this.queryPromises = new Map();\n    this.queryInfoTrie = new Map();\n  }\n\n  RenderPromises.prototype.registerSSRObservable = function (queryInstance, observable) {\n    this.lookupQueryInfo(queryInstance).observable = observable;\n  };\n\n  RenderPromises.prototype.getSSRObservable = function (queryInstance) {\n    return this.lookupQueryInfo(queryInstance).observable;\n  };\n\n  RenderPromises.prototype.addQueryPromise = function (queryInstance, finish) {\n    var info = this.lookupQueryInfo(queryInstance);\n\n    if (!info.seen) {\n      this.queryPromises.set(queryInstance, new Promise(function (resolve) {\n        resolve(queryInstance.fetchData());\n      }));\n      return null;\n    }\n\n    return finish();\n  };\n\n  RenderPromises.prototype.hasPromises = function () {\n    return this.queryPromises.size > 0;\n  };\n\n  RenderPromises.prototype.consumeAndAwaitPromises = function () {\n    var _this = this;\n\n    var promises = [];\n    this.queryPromises.forEach(function (promise, queryInstance) {\n      _this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  };\n\n  RenderPromises.prototype.lookupQueryInfo = function (queryInstance) {\n    var queryInfoTrie = this.queryInfoTrie;\n    var _a = queryInstance.props,\n        query = _a.query,\n        variables = _a.variables;\n    var varMap = queryInfoTrie.get(query) || new Map();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    var variablesString = JSON.stringify(variables);\n    var info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  };\n\n  return RenderPromises;\n}();\n\nfunction getDataFromTree(tree, context) {\n  if (context === void 0) {\n    context = {};\n  }\n\n  return getMarkupFromTree({\n    tree: tree,\n    context: context,\n    renderFunction: require(\"react-dom/server\").renderToStaticMarkup\n  });\n}\n\nfunction getMarkupFromTree(_a) {\n  var tree = _a.tree,\n      _b = _a.context,\n      context = _b === void 0 ? {} : _b,\n      _c = _a.renderFunction,\n      renderFunction = _c === void 0 ? require(\"react-dom/server\").renderToStaticMarkup : _c;\n  var renderPromises = new RenderPromises();\n\n  var RenderPromisesProvider = function (_super) {\n    __extends(RenderPromisesProvider, _super);\n\n    function RenderPromisesProvider() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    RenderPromisesProvider.prototype.getChildContext = function () {\n      return __assign({}, context, {\n        renderPromises: renderPromises\n      });\n    };\n\n    RenderPromisesProvider.prototype.render = function () {\n      return tree;\n    };\n\n    RenderPromisesProvider.childContextTypes = {\n      renderPromises: object\n    };\n    return RenderPromisesProvider;\n  }(Component);\n\n  Object.keys(context).forEach(function (key) {\n    RenderPromisesProvider.childContextTypes[key] = any;\n  });\n\n  function process() {\n    var html = renderFunction(createElement(RenderPromisesProvider));\n    return renderPromises.hasPromises() ? renderPromises.consumeAndAwaitPromises().then(process) : html;\n  }\n\n  return Promise.resolve().then(process);\n}\n\nfunction renderToStringWithData(component) {\n  return getMarkupFromTree({\n    tree: component,\n    renderFunction: require(\"react-dom/server\").renderToString\n  });\n}\n\nfunction compose() {\n  var funcs = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    funcs[_i] = arguments[_i];\n  }\n\n  var functions = funcs.reverse();\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var firstFunction = functions[0],\n        restFunctions = functions.slice(1);\n    var result = firstFunction.apply(null, args);\n    restFunctions.forEach(function (fnc) {\n      result = fnc.call(null, result);\n    });\n    return result;\n  };\n}\n\nexport { ApolloConsumer, ApolloContext, ApolloProvider, Mutation, Query, RenderPromises, Subscription, compose, getDataFromTree, getMarkupFromTree, graphql, renderToStringWithData, withApollo, withMutation, withQuery, withSubscription };","map":{"version":3,"sources":["../src/ApolloContext.ts","../src/ApolloConsumer.tsx","../src/ApolloProvider.tsx","../src/parser.ts","../src/component-utils.tsx","../src/utils/shallowEqual.ts","../src/Query.tsx","../src/Mutation.tsx","../src/Subscriptions.tsx","../src/hoc-utils.tsx","../src/query-hoc.tsx","../src/mutation-hoc.tsx","../src/subscription-hoc.tsx","../src/graphql.tsx","../src/withApollo.tsx","../src/getDataFromTree.ts","../src/renderToStringWithData.ts","../src/utils/flowRight.ts"],"names":["React.createContext","React.createElement","PropTypes.object","PropTypes.func","PropTypes.node","React.Component","PropTypes.string","PropTypes.bool","PropTypes.number","PropTypes.oneOfType","PropTypes.arrayOf","getDisplayName","PropTypes.any"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport ApolloClient from 'apollo-client';\nimport { DocumentNode } from 'graphql';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<Object>;\n  operations?: Map<string, { query: DocumentNode; variables: any }>;\n}\n\nexport const ApolloContext = React.createContext &&\n  React.createContext<ApolloContextValue | undefined>(undefined)\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient from 'apollo-client';\nimport { ApolloContext } from './ApolloContext';\nimport { InvariantError } from 'ts-invariant';\n\nexport interface ApolloConsumerProps {\n  children: (client: ApolloClient<any>) => React.ReactElement<any> | null;\n}\n\nconst ApolloConsumer: React.StatelessComponent<ApolloConsumerProps> =\n  (props, legacyContext) => {\n    function finish(context: any) {\n      if (!context || !context.client) {\n        throw new InvariantError(\n          'Could not find \"client\" in the context of ApolloConsumer. ' +\n          'Wrap the root component in an <ApolloProvider>.'\n        );\n      }\n      return props.children(context.client);\n    }\n\n    return ApolloContext ? (\n      <ApolloContext.Consumer>\n        {finish}\n      </ApolloContext.Consumer>\n    ) : (\n      // Fall back to legacy context API if React.createContext not available.\n      finish(legacyContext)\n    );\n  };\n\nApolloConsumer.contextTypes = {\n  client: PropTypes.object.isRequired,\n};\n\nApolloConsumer.propTypes = {\n  children: PropTypes.func.isRequired,\n};\n\nexport default ApolloConsumer;\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { Component } from 'react';\nimport ApolloClient from 'apollo-client';\nimport { DocumentNode } from 'graphql';\nimport { ApolloContext } from './ApolloContext';\n\nimport { invariant } from 'ts-invariant';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode;\n}\n\nexport default class ApolloProvider<TCache> extends Component<ApolloProviderProps<TCache>> {\n  static propTypes = {\n    client: PropTypes.object.isRequired,\n    children: PropTypes.node.isRequired,\n  };\n\n  static childContextTypes = {\n    client: PropTypes.object.isRequired,\n    operations: PropTypes.object,\n  };\n\n  private operations: Map<string, { query: DocumentNode; variables: any }> = new Map();\n\n  constructor(props: ApolloProviderProps<TCache>, context: any) {\n    super(props, context);\n\n    invariant(\n      props.client,\n      'ApolloProvider was not passed a client instance. Make ' +\n        'sure you pass in your client via the \"client\" prop.',\n    );\n\n    // we have to attach to the client since you could have multiple\n    // providers\n    // XXX this is backwards compat and will be removed in 3.0\n    if (!(props.client as any).__operations_cache__) {\n      (props.client as any).__operations_cache__ = this.operations;\n    }\n  }\n\n  getChildContext() {\n    return {\n      client: this.props.client,\n      operations: (this.props.client as any).__operations_cache__,\n    };\n  }\n\n  render() {\n    return ApolloContext ? (\n      <ApolloContext.Provider value={this.getChildContext()}>\n        {this.props.children}\n      </ApolloContext.Provider>\n    ) : (\n      this.props.children\n    );\n  }\n}\n","import {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n} from 'graphql';\n\nimport { invariant } from 'ts-invariant';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription,\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\n// the parser is mainly a safety check for the HOC\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n  // variables\n  let variables, type, name;\n\n  /*\n\n    Saftey checks for proper usage of react-apollo\n\n  */\n  invariant(\n    !!document && !!document.kind,\n    // tslint:disable-line\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`,\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition',\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'query',\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'mutation',\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'subscription',\n  );\n\n  invariant(\n    !fragments.length || (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`,\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    // tslint:disable-line\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    // tslint:disable-line\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n","import ApolloClient from 'apollo-client';\nimport { invariant } from 'ts-invariant';\n\nexport interface CommonComponentProps {\n  client?: ApolloClient<Object>;\n}\n\nexport interface CommonComponentContext {\n  client?: ApolloClient<Object>;\n}\n\nexport function getClient(\n  props: CommonComponentProps,\n  context: CommonComponentContext,\n): ApolloClient<Object> {\n  const client = props.client || context.client;\n\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as a prop. ' +\n      'Wrap the root component in an <ApolloProvider>, or pass an ' +\n      'ApolloClient instance in via props.',\n  );\n\n  return client as ApolloClient<Object>;\n}\n","const { hasOwnProperty } = Object.prototype;\n\nfunction is(x: any, y: any) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  }\n  return x !== x && y !== y;\n}\n\nfunction isObject(obj: any): obj is { [key: string]: any } {\n  return obj !== null && typeof obj === \"object\";\n}\n\nexport default function shallowEqual(objA: any, objB: any) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (!isObject(objA) || !isObject(objB)) {\n    return false;\n  }\n\n  const keys = Object.keys(objA);\n\n  if (keys.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keys.every(\n    key => hasOwnProperty.call(objB, key) && is(objA[key], objB[key]),\n  );\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient, {\n  ObservableQuery,\n  ApolloError,\n  ApolloQueryResult,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  ApolloCurrentResult\n} from 'apollo-client';\nimport { DocumentNode } from 'graphql';\nimport { ZenObservable } from 'zen-observable-ts';\nimport { OperationVariables, QueryControls, QueryOpts } from './types';\nimport { parser, DocumentType, IDocumentDefinition } from './parser';\nimport { getClient } from './component-utils';\nimport { RenderPromises } from './getDataFromTree';\n\nimport isEqual from 'lodash.isequal';\nimport shallowEqual from './utils/shallowEqual';\nimport { invariant } from 'ts-invariant';\n\nexport type ObservableQueryFields<TData, TVariables> = Pick<\n  ObservableQuery<TData, TVariables>,\n  'startPolling' | 'stopPolling' | 'subscribeToMore' | 'updateQuery' | 'refetch' | 'variables'\n> & {\n  fetchMore: (<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> & FetchMoreOptions<TData, TVariables>,\n  ) => Promise<ApolloQueryResult<TData>>) &\n    (<TData2, TVariables2, K extends keyof TVariables2>(\n      fetchMoreOptions: { query?: DocumentNode } & FetchMoreQueryOptions<TVariables2, K> &\n        FetchMoreOptions<TData2, TVariables2>,\n    ) => Promise<ApolloQueryResult<TData2>>);\n};\n\nfunction observableQueryFields<TData, TVariables>(\n  observable: ObservableQuery<TData, TVariables>,\n): ObservableQueryFields<TData, TVariables> {\n  const fields = {\n    variables: observable.variables,\n    refetch: observable.refetch.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable),\n  };\n  // TODO: Need to cast this because we improved the type of `updateQuery` to be parametric\n  // on variables, while the type in Apollo client just has object.\n  // Consider removing this when that is properly typed\n  return fields as ObservableQueryFields<TData, TVariables>;\n}\n\nexport interface QueryResult<TData = any, TVariables = OperationVariables>\n  extends ObservableQueryFields<TData, TVariables> {\n  client: ApolloClient<any>;\n  // we create an empty object to make checking for data\n  // easier for consumers (i.e. instead of data && data.user\n  // you can just check data.user) this also makes destructring\n  // easier (i.e. { data: { user } })\n  // however, this isn't realy possible with TypeScript that\n  // I'm aware of. So intead we enforce checking for data\n  // like so result.data!.user. This tells TS to use TData\n  // XXX is there a better way to do this?\n  data: TData | undefined;\n  error?: ApolloError;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n}\n\nexport interface QueryProps<TData = any, TVariables = OperationVariables> extends QueryOpts<TVariables> {\n  children: (result: QueryResult<TData, TVariables>) => React.ReactNode;\n  query: DocumentNode;\n  displayName?: string;\n  skip?: boolean;\n  onCompleted?: (data: TData) => void;\n  onError?: (error: ApolloError) => void;\n}\n\nexport interface QueryContext {\n  client?: ApolloClient<Object>;\n  operations?: Map<string, { query: DocumentNode; variables: any }>;\n  renderPromises?: RenderPromises;\n}\n\nexport default class Query<TData = any, TVariables = OperationVariables> extends React.Component<\n  QueryProps<TData, TVariables>\n> {\n  static contextTypes = {\n    client: PropTypes.object,\n    operations: PropTypes.object,\n    renderPromises: PropTypes.object,\n  };\n\n  static propTypes = {\n    client: PropTypes.object,\n    children: PropTypes.func.isRequired,\n    fetchPolicy: PropTypes.string,\n    notifyOnNetworkStatusChange: PropTypes.bool,\n    onCompleted: PropTypes.func,\n    onError: PropTypes.func,\n    pollInterval: PropTypes.number,\n    query: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    ssr: PropTypes.bool,\n    partialRefetch: PropTypes.bool,\n    returnPartialData: PropTypes.bool,\n  };\n\n  context: QueryContext | undefined;\n\n  private client: ApolloClient<Object>;\n\n  // request / action storage. Note that we delete querySubscription if we\n  // unsubscribe but never delete queryObservable once it is created. We\n  // only delete queryObservable when we unmount the component.\n  private queryObservable?: ObservableQuery<TData, TVariables> | null;\n  private querySubscription?: ZenObservable.Subscription;\n  private refetcherQueue?: {\n    args: any;\n    resolve: (value?: any | PromiseLike<any>) => void;\n    reject: (reason?: any) => void;\n  };\n\n  private hasMounted: boolean = false;\n  private operation?: IDocumentDefinition;\n  private lastRenderedResult: ApolloQueryResult<TData> | null = null;\n\n  constructor(props: QueryProps<TData, TVariables>, context: QueryContext) {\n    super(props, context);\n\n    this.client = getClient(props, context);\n    this.initializeQueryObservable(props);\n  }\n\n  // For server-side rendering (see getDataFromTree.ts)\n  fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    if (this.props.skip) return false;\n\n    // pull off react options\n    const {\n      children,\n      ssr,\n      displayName,\n      skip,\n      client,\n      onCompleted,\n      onError,\n      partialRefetch,\n      ...opts\n    } = this.props;\n\n    let { fetchPolicy } = opts;\n    if (ssr === false) return false;\n    if (fetchPolicy === 'network-only' || fetchPolicy === 'cache-and-network') {\n      fetchPolicy = 'cache-first'; // ignore force fetch in SSR;\n    }\n\n    const observable = this.client.watchQuery({\n      ...opts,\n      fetchPolicy,\n    });\n\n    // Register the SSR observable, so it can be re-used once the value comes back.\n    if (this.context && this.context.renderPromises) {\n      this.context.renderPromises.registerSSRObservable(this, observable);\n    }\n\n    const result = this.queryObservable!.currentResult();\n\n    return result.loading ? observable.result() : false;\n  }\n\n  componentDidMount() {\n    this.hasMounted = true;\n    if (this.props.skip) return;\n\n    this.startQuerySubscription();\n    if (this.refetcherQueue) {\n      const { args, resolve, reject } = this.refetcherQueue;\n      this.queryObservable!.refetch(args)\n        .then(resolve)\n        .catch(reject);\n    }\n  }\n\n  componentWillReceiveProps(nextProps: QueryProps<TData, TVariables>, nextContext: QueryContext) {\n    // the next render wants to skip\n    if (nextProps.skip && !this.props.skip) {\n      this.queryObservable!.resetLastResults();\n      this.removeQuerySubscription();\n      return;\n    }\n\n    const nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.removeQuerySubscription();\n      this.queryObservable = null;\n    }\n\n    if (this.props.query !== nextProps.query) {\n      this.queryObservable!.resetLastResults();\n      this.removeQuerySubscription();\n    }\n\n    this.updateQuery(nextProps);\n    if (nextProps.skip) return;\n    this.startQuerySubscription();\n  }\n\n  componentWillUnmount() {\n    this.removeQuerySubscription();\n    this.hasMounted = false;\n  }\n\n  componentDidUpdate(prevProps: QueryProps<TData, TVariables>) {\n    const isDiffRequest =\n      !isEqual(prevProps.query, this.props.query) ||\n      !isEqual(prevProps.variables, this.props.variables);\n    if (isDiffRequest) {\n      // If specified, `onError` / `onCompleted` callbacks are called here\n      // after local cache results are loaded.\n      this.handleErrorOrCompleted();\n    }\n  }\n\n  render(): React.ReactNode {\n    const { context } = this;\n    const finish = () => this.props.children(this.getQueryResult());\n    if (context && context.renderPromises) {\n      return context.renderPromises.addQueryPromise(this, finish);\n    }\n    return finish();\n  }\n\n  private extractOptsFromProps(props: QueryProps<TData, TVariables>) {\n    this.operation = parser(props.query);\n\n    invariant(\n      this.operation.type === DocumentType.Query,\n      `The <Query /> component requires a graphql query, but got a ${\n        this.operation.type === DocumentType.Mutation ? 'mutation' : 'subscription'\n      }.`,\n    );\n\n    const displayName = props.displayName || 'Query';\n\n    return {\n      ...props,\n      displayName,\n      context: props.context || {},\n      metadata: { reactComponent: { displayName }},\n    };\n  }\n\n  private initializeQueryObservable(props: QueryProps<TData, TVariables>) {\n    const opts = this.extractOptsFromProps(props);\n    // save for backwards compat of refetcherQueries without a recycler\n    this.setOperations(opts);\n\n    // See if there is an existing observable that was used to fetch the same data and\n    // if so, use it instead since it will contain the proper queryId to fetch\n    // the result set. This is used during SSR.\n    if (this.context && this.context.renderPromises) {\n      this.queryObservable = this.context.renderPromises.getSSRObservable(this);\n    }\n    if (!this.queryObservable) {\n      this.queryObservable = this.client.watchQuery(opts);\n    }\n  }\n\n  private setOperations(props: QueryProps<TData, TVariables>) {\n    if (this.context!.operations) {\n      this.context!.operations!.set(this.operation!.name, {\n        query: props.query,\n        variables: props.variables,\n      });\n    }\n  }\n\n  private updateQuery(props: QueryProps<TData, TVariables>) {\n    // if we skipped initially, we may not have yet created the observable\n    if (!this.queryObservable) {\n      this.initializeQueryObservable(props);\n    } else {\n      this.setOperations(props);\n    }\n\n    this.queryObservable!.setOptions(this.extractOptsFromProps(props))\n      // The error will be passed to the child container, so we don't\n      // need to log it here. We could conceivably log something if\n      // an option was set. OTOH we don't log errors w/ the original\n      // query. See https://github.com/apollostack/react-apollo/issues/404\n      .catch(() => null);\n  }\n\n  private startQuerySubscription = () => {\n    // When the `Query` component receives new props, or when we explicitly\n    // re-subscribe to a query using `resubscribeToQuery`, we start a new\n    // subscription in this method. To avoid un-necessary re-renders when\n    // receiving new props or re-subscribing, we track the full last\n    // observable result so it can be compared against incoming new data.\n    // We only trigger a re-render if the incoming result is different than\n    // the stored `lastRenderedResult`.\n\n    if (this.querySubscription) return;\n\n    this.querySubscription = this.queryObservable!.subscribe({\n      next: (result) => {\n        if (\n          this.lastRenderedResult &&\n          this.lastRenderedResult.loading === result.loading &&\n          this.lastRenderedResult.networkStatus === result.networkStatus &&\n          shallowEqual(this.lastRenderedResult.data, result.data)\n        ) {\n          return;\n        }\n\n        this.updateCurrentData();\n      },\n      error: error => {\n        this.resubscribeToQuery();\n\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n        this.updateCurrentData();\n      },\n    });\n  };\n\n  private removeQuerySubscription = () => {\n    if (this.querySubscription) {\n      this.querySubscription.unsubscribe();\n      delete this.lastRenderedResult;\n      delete this.querySubscription;\n    }\n  };\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `queryObservable` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `queryObservable` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.queryObservable!.getLastError();\n    const lastResult = this.queryObservable!.getLastResult();\n    this.queryObservable!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.queryObservable!, { lastError, lastResult });\n  }\n\n  private updateCurrentData = () => {\n    // If specified, `onError` / `onCompleted` callbacks are called here\n    // after a network based Query result has been received.\n    this.handleErrorOrCompleted();\n\n    // Force a rerender that goes through shouldComponentUpdate.\n    if (this.hasMounted) this.forceUpdate();\n  };\n\n  private handleErrorOrCompleted = () => {\n    const result = this.queryObservable!.currentResult();\n    const { data, loading, error } = result;\n    const { onCompleted, onError } = this.props;\n    if (onCompleted && !loading && !error) {\n      onCompleted(data as TData);\n    } else if (onError && !loading && error) {\n      onError(error);\n    }\n  }\n\n  private getQueryResult = (): QueryResult<TData, TVariables> => {\n    let result = { data: Object.create(null) as TData } as any;\n    // Attach bound methods\n    Object.assign(result, observableQueryFields(this.queryObservable!));\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (this.props.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n      };\n    } else {\n      const currentResult = this.queryObservable!.currentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error props.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      const { fetchPolicy } = this.queryObservable!.options;\n      Object.assign(result, { loading, networkStatus, error });\n\n      const previousData =\n        this.lastRenderedResult ? this.lastRenderedResult.data : {};\n\n      if (loading) {\n        Object.assign(result.data, previousData, currentResult.data);\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.queryObservable!.getLastResult() || {}).data,\n        });\n      } else if (\n        fetchPolicy === 'no-cache' &&\n        Object.keys(currentResult.data).length === 0\n      ) {\n        // Make sure data pulled in by a `no-cache` query is preserved\n        // when the components parent tree is re-rendered.\n        result.data = previousData;\n      } else {\n        const { partialRefetch } = this.props;\n        if (\n          partialRefetch &&\n          currentResult.data !== null &&\n          typeof currentResult.data === 'object' &&\n          Object.keys(currentResult.data).length === 0 &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as an empty Object since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, { loading: true, networkStatus: NetworkStatus.loading });\n          result.refetch();\n          this.lastRenderedResult = result;\n          return result;\n        }\n\n        Object.assign(result.data, currentResult.data);\n      }\n    }\n\n    // Handle race condition where refetch is called on child mount or later\n    // Normal execution model:\n    // render(loading) -> mount -> start subscription -> get data -> render(with data)\n    //\n    // SSR with synchronous refetch:\n    // render(with data) -> refetch -> mount -> start subscription\n    //\n    // SSR with asynchronous refetch:\n    // render(with data) -> mount -> start subscription -> refetch\n    //\n    // If a subscription has not started, then the synchronous call to refetch\n    // must be made at a time when an active network request is being made, so\n    // we ensure that the network requests are deduped, to avoid an\n    // inconsistent UI state that displays different data for the current query\n    // alongside a refetched query.\n    //\n    // Once the Query component is mounted and the subscription is made, we\n    // always hit the network with refetch, since the components data will be\n    // updated and a network request is not currently active.\n    if (!this.querySubscription) {\n      const oldRefetch = (result as QueryControls<TData, TVariables>).refetch;\n\n      (result as QueryControls<TData, TVariables>).refetch = args => {\n        if (this.querySubscription) {\n          return oldRefetch(args);\n        } else {\n          return new Promise((r, f) => {\n            this.refetcherQueue = { resolve: r, reject: f, args };\n          });\n        }\n      };\n    }\n\n    // When the component is done rendering stored query errors, we'll\n    // remove those errors from the `ObservableQuery` query store, so they\n    // aren't re-displayed on subsequent (potentially error free)\n    // requests/responses.\n    //\n    // NOTE: Resetting query store errors is handled in 2 different ways here,\n    // since the `resetQueryStoreErrors` wasn't available until\n    // `apollo-client` 2.6.3. If a previous version of `apollo-client` is\n    // being used, errors are reset by reaching into `ObservableQuery`'s\n    // internals. This hack is temporary, as React Apollo 3 will be\n    // released shortly, and will enforce `apollo-client` 2.6.3 as the\n    // minimum.\n    setTimeout(() => {\n      if ((this.queryObservable! as any).resetQueryStoreErrors) {\n        // Apollo Client >= 2.6.3\n        (this.queryObservable! as any).resetQueryStoreErrors();\n      } else {\n        // Apollo Client < 2.6.3\n        const { queryManager, queryId } = (this.queryObservable! as any);\n        const queryStore = queryManager.queryStore.get(queryId);\n        if (queryStore) {\n          queryStore.networkError = null;\n          queryStore.graphQLErrors = [];\n        }\n      }\n    });\n\n    result.client = this.client;\n    this.lastRenderedResult = result;\n    return result;\n  };\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient, { PureQueryOptions, ApolloError, FetchPolicy } from 'apollo-client';\nimport { DataProxy } from 'apollo-cache';\nimport { invariant } from 'ts-invariant';\nimport { DocumentNode, GraphQLError } from 'graphql';\nimport shallowEqual from './utils/shallowEqual';\n\nimport { OperationVariables, RefetchQueriesProviderFn } from './types';\nimport { parser, DocumentType } from './parser';\nimport { getClient } from './component-utils';\n\nexport interface MutationResult<TData = Record<string, any>> {\n  data?: TData;\n  error?: ApolloError;\n  loading: boolean;\n  called: boolean;\n  client: ApolloClient<Object>;\n}\nexport interface MutationContext {\n  client?: ApolloClient<Object>;\n  operations: Map<string, { query: DocumentNode; variables: any }>;\n}\n\nexport interface ExecutionResult<T = Record<string, any>> {\n  data?: T;\n  extensions?: Record<string, any>;\n  errors?: GraphQLError[];\n}\n\n// Improved MutationUpdaterFn type, need to port them back to Apollo Client\nexport declare type MutationUpdaterFn<\n  T = {\n    [key: string]: any;\n  }\n> = (proxy: DataProxy, mutationResult: FetchResult<T>) => void;\n\nexport declare type FetchResult<\n  TData = Record<string, any>,\n  C = Record<string, any>,\n  E = Record<string, any>\n> = ExecutionResult<TData> & {\n  extensions?: E;\n  context?: C;\n};\n\nexport declare type MutationOptions<\n  TData = Record<string, any>,\n  TVariables = OperationVariables\n> = {\n  variables?: TVariables;\n  optimisticResponse?: TData;\n  refetchQueries?: Array<string | PureQueryOptions> | RefetchQueriesProviderFn;\n  awaitRefetchQueries?: boolean;\n  update?: MutationUpdaterFn<TData>;\n  context?: Record<string, any>;\n  fetchPolicy?: FetchPolicy;\n};\n\nexport declare type MutationFn<TData = any, TVariables = OperationVariables> = (\n  options?: MutationOptions<TData, TVariables>,\n) => Promise<void | FetchResult<TData>>;\n\nexport interface MutationProps<TData = any, TVariables = OperationVariables> {\n  client?: ApolloClient<Object>;\n  mutation: DocumentNode;\n  ignoreResults?: boolean;\n  optimisticResponse?: TData;\n  variables?: TVariables;\n  refetchQueries?: Array<string | PureQueryOptions> | RefetchQueriesProviderFn;\n  awaitRefetchQueries?: boolean;\n  update?: MutationUpdaterFn<TData>;\n  children: (\n    mutateFn: MutationFn<TData, TVariables>,\n    result: MutationResult<TData>,\n  ) => React.ReactNode;\n  onCompleted?: (data: TData) => void;\n  onError?: (error: ApolloError) => void;\n  context?: Record<string, any>;\n  fetchPolicy?: FetchPolicy;\n}\n\nexport interface MutationState<TData = any> {\n  called: boolean;\n  error?: ApolloError;\n  data?: TData;\n  loading: boolean;\n}\n\nconst initialState = {\n  loading: false,\n  called: false,\n  error: undefined,\n  data: undefined,\n};\n\nclass Mutation<TData = any, TVariables = OperationVariables> extends React.Component<\n  MutationProps<TData, TVariables>,\n  MutationState<TData>\n> {\n  static contextTypes = {\n    client: PropTypes.object,\n    operations: PropTypes.object,\n  };\n\n  static propTypes = {\n    mutation: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    optimisticResponse: PropTypes.object,\n    refetchQueries: PropTypes.oneOfType([\n      PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.object])),\n      PropTypes.func,\n    ]),\n    awaitRefetchQueries: PropTypes.bool,\n    update: PropTypes.func,\n    children: PropTypes.func.isRequired,\n    onCompleted: PropTypes.func,\n    onError: PropTypes.func,\n    fetchPolicy: PropTypes.string,\n  };\n\n  private client: ApolloClient<any>;\n  private mostRecentMutationId: number;\n\n  private hasMounted: boolean = false;\n\n  constructor(props: MutationProps<TData, TVariables>, context: any) {\n    super(props, context);\n    this.client = getClient(props, context);\n    this.verifyDocumentIsMutation(props.mutation);\n    this.mostRecentMutationId = 0;\n    this.state = initialState;\n  }\n\n  componentDidMount() {\n    this.hasMounted = true;\n  }\n\n  componentWillUnmount() {\n    this.hasMounted = false;\n  }\n\n  componentWillReceiveProps(\n    nextProps: MutationProps<TData, TVariables>,\n    nextContext: MutationContext,\n  ) {\n    const nextClient = getClient(nextProps, nextContext);\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.props.mutation !== nextProps.mutation) {\n      this.verifyDocumentIsMutation(nextProps.mutation);\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.setState(initialState);\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const { loading, data, error, called } = this.state;\n\n    const result = {\n      called,\n      loading,\n      data,\n      error,\n      client: this.client,\n    };\n\n    return children(this.runMutation, result);\n  }\n\n  private runMutation = (options: MutationOptions<TData, TVariables> = {}) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(options)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((e: ApolloError) => {\n        this.onMutationError(e, mutationId);\n        if (!this.props.onError) throw e;\n      });\n  };\n\n  private mutate = (options: MutationOptions<TData, TVariables>) => {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context = {},\n      awaitRefetchQueries = false,\n      fetchPolicy,\n    } = this.props;\n    const mutateOptions = { ...options };\n\n    let refetchQueries = mutateOptions.refetchQueries || this.props.refetchQueries;\n    // XXX this will be removed in the 3.0 of Apollo Client. Currently, we\n    // support refectching of named queries which just pulls the latest\n    // variables to match. This forces us to either a) keep all queries around\n    // to be able to iterate over and refetch, or b) [new in 2.1] keep a map of\n    // operations on the client where operation name => { query, variables }\n    //\n    // Going forward, we should only allow using the full operation + variables to\n    // refetch.\n    if (refetchQueries && refetchQueries.length && Array.isArray(refetchQueries)) {\n      refetchQueries = (refetchQueries as any).map((x: string | PureQueryOptions) => {\n        if (typeof x === 'string' && this.context.operations)\n          return this.context.operations.get(x) || x;\n        return x;\n      });\n      delete mutateOptions.refetchQueries;\n    }\n\n    const mutateVariables = Object.assign({}, variables, mutateOptions.variables);\n    delete mutateOptions.variables;\n\n    return this.client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions,\n    });\n  };\n\n  private onMutationStart = () => {\n    if (!this.state.loading && !this.props.ignoreResults) {\n      this.setState({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true,\n      });\n    }\n  };\n\n  private onMutationCompleted = (response: ExecutionResult<TData>, mutationId: number) => {\n    const { onCompleted, ignoreResults } = this.props;\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0 ? new ApolloError({ graphQLErrors: errors }) : undefined;\n\n    const callOncomplete = () => (onCompleted ? onCompleted(data as TData) : null);\n\n    if (this.hasMounted && this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.setState({ loading: false, data, error }, callOncomplete);\n    } else {\n      callOncomplete();\n    }\n  };\n\n  private onMutationError = (error: ApolloError, mutationId: number) => {\n    const { onError } = this.props;\n    const callOnError = () => (onError ? onError(error) : null);\n\n    if (this.hasMounted && this.isMostRecentMutation(mutationId)) {\n      this.setState({ loading: false, error }, callOnError);\n    } else {\n      callOnError();\n    }\n  };\n\n  private generateNewMutationId = (): number => {\n    this.mostRecentMutationId = this.mostRecentMutationId + 1;\n    return this.mostRecentMutationId;\n  };\n\n  private isMostRecentMutation = (mutationId: number) => {\n    return this.mostRecentMutationId === mutationId;\n  };\n\n  private verifyDocumentIsMutation = (mutation: DocumentNode) => {\n    const operation = parser(mutation);\n    invariant(\n      operation.type === DocumentType.Mutation,\n      `The <Mutation /> component requires a graphql mutation, but got a ${\n        operation.type === DocumentType.Query ? 'query' : 'subscription'\n      }.`,\n    );\n  };\n}\n\nexport default Mutation;\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient, { ApolloError, FetchPolicy } from 'apollo-client';\nimport { Observable } from 'apollo-link';\nimport { DocumentNode } from 'graphql';\nimport { ZenObservable } from 'zen-observable-ts';\n\nimport { OperationVariables } from './types';\nimport { getClient } from './component-utils';\n\nimport shallowEqual from './utils/shallowEqual';\nimport { invariant } from 'ts-invariant';\n\nexport interface SubscriptionResult<TData = any> {\n  loading: boolean;\n  data?: TData;\n  error?: ApolloError;\n}\n\nexport interface OnSubscriptionDataOptions<TData = any> {\n  client: ApolloClient<Object>;\n  subscriptionData: SubscriptionResult<TData>;\n}\n\nexport interface SubscriptionProps<TData = any, TVariables = OperationVariables> {\n  subscription: DocumentNode;\n  variables?: TVariables;\n  fetchPolicy?: FetchPolicy;\n  shouldResubscribe?: any;\n  client?: ApolloClient<Object>;\n  onSubscriptionData?: (options: OnSubscriptionDataOptions<TData>) => any;\n  onSubscriptionComplete?: () => void;\n  children?: (result: SubscriptionResult<TData>) => React.ReactNode;\n}\n\nexport interface SubscriptionState<TData = any> {\n  loading: boolean;\n  data?: TData;\n  error?: ApolloError;\n}\n\nexport interface SubscriptionContext {\n  client?: ApolloClient<Object>;\n}\n\nclass Subscription<TData = any, TVariables = any> extends React.Component<\n  SubscriptionProps<TData, TVariables>,\n  SubscriptionState<TData>\n> {\n  static contextTypes = {\n    client: PropTypes.object,\n  };\n\n  static propTypes = {\n    subscription: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    children: PropTypes.func,\n    onSubscriptionData: PropTypes.func,\n    onSubscriptionComplete: PropTypes.func,\n    shouldResubscribe: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  };\n\n  private client: ApolloClient<any>;\n  private queryObservable?: Observable<any>;\n  private querySubscription?: ZenObservable.Subscription;\n\n  constructor(props: SubscriptionProps<TData, TVariables>, context: SubscriptionContext) {\n    super(props, context);\n\n    this.client = getClient(props, context);\n    this.initialize(props);\n    this.state = this.getInitialState();\n  }\n\n  componentDidMount() {\n    this.startSubscription();\n  }\n\n  componentWillReceiveProps(\n    nextProps: SubscriptionProps<TData, TVariables>,\n    nextContext: SubscriptionContext,\n  ) {\n    const nextClient = getClient(nextProps, nextContext);\n\n    if (\n      shallowEqual(this.props.variables, nextProps.variables) &&\n      this.client === nextClient &&\n      this.props.subscription === nextProps.subscription\n    ) {\n      return;\n    }\n\n    let shouldResubscribe = nextProps.shouldResubscribe;\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.props, nextProps);\n    }\n    const shouldNotResubscribe = shouldResubscribe === false;\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n    }\n\n    if (!shouldNotResubscribe) {\n      this.endSubscription();\n      delete this.queryObservable;\n      this.initialize(nextProps);\n      this.startSubscription();\n      this.setState(this.getInitialState());\n      return;\n    }\n    this.initialize(nextProps);\n    this.startSubscription();\n  }\n\n  componentWillUnmount() {\n    this.endSubscription();\n  }\n\n  render() {\n    const renderFn: any = this.props.children;\n    if (!renderFn) return null;\n    const result = Object.assign({}, this.state, {\n      variables: this.props.variables,\n    });\n    return renderFn(result);\n  }\n\n  private initialize = (props: SubscriptionProps<TData, TVariables>) => {\n    if (this.queryObservable) return;\n    this.queryObservable = this.client.subscribe({\n      query: props.subscription,\n      variables: props.variables,\n      fetchPolicy: props.fetchPolicy,\n    });\n  };\n\n  private startSubscription = () => {\n    if (this.querySubscription) return;\n    this.querySubscription = this.queryObservable!.subscribe({\n      next: this.updateCurrentData,\n      error: this.updateError,\n      complete: this.completeSubscription\n    });\n  };\n\n  private getInitialState = () => ({\n    loading: true,\n    error: undefined,\n    data: undefined,\n  });\n\n  private updateCurrentData = (result: SubscriptionResult<TData>) => {\n    const {\n      client,\n      props: { onSubscriptionData },\n    } = this;\n    this.setState({\n      data: result.data,\n      loading: false,\n      error: undefined,\n    });\n    if (onSubscriptionData) onSubscriptionData({ client, subscriptionData: result });\n  };\n\n  private updateError = (error: any) => {\n    this.setState({\n      error,\n      loading: false,\n    });\n  };\n\n  private completeSubscription = () => {\n    const { onSubscriptionComplete } = this.props;\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  };\n\n  private endSubscription = () => {\n    if (this.querySubscription) {\n      this.querySubscription.unsubscribe();\n      delete this.querySubscription;\n    }\n  };\n}\n\nexport default Subscription;\n","import * as React from 'react';\nimport { invariant } from 'ts-invariant';\n\nimport { OperationVariables } from './types';\nimport { DocumentType, IDocumentDefinition } from './parser';\n\nexport const defaultMapPropsToOptions = () => ({});\nexport const defaultMapResultToProps: <P>(props: P) => P = props => props;\nexport const defaultMapPropsToSkip = () => false;\n\nexport function getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport function calculateVariablesFromProps<TProps>(operation: IDocumentDefinition, props: TProps) {\n  let variables: OperationVariables = {};\n  for (let { variable, type } of operation.variables) {\n    if (!variable.name || !variable.name.value) continue;\n\n    const variableName = variable.name.value;\n    const variableProp = (props as any)[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    // Allow optional props\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n  return variables;\n}\n\nexport type RefSetter<TChildProps> = (ref: React.ComponentClass<TChildProps>) => void | void;\n\n// base class for hocs to easily manage refs\nexport class GraphQLBase<TProps, TChildProps, TState = any> extends React.Component<\n  TProps,\n  TState\n> {\n  public withRef: boolean = false;\n  // wrapped instance\n  private wrappedInstance?: React.ComponentClass<TChildProps>;\n\n  constructor(props: TProps) {\n    super(props);\n    this.setWrappedInstance = this.setWrappedInstance.bind(this);\n  }\n\n  getWrappedInstance() {\n    invariant(\n      this.withRef,\n      `To access the wrapped instance, you need to specify ` + `{ withRef: true } in the options`,\n    );\n\n    return this.wrappedInstance;\n  }\n\n  setWrappedInstance(ref: React.ComponentClass<TChildProps>) {\n    this.wrappedInstance = ref;\n  }\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from './parser';\nimport { OperationOption, QueryOpts, OptionProps, DataProps } from './types';\nimport { default as Query } from './Query';\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip,\n} from './hoc-utils';\n\nexport function withQuery<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo',\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => QueryOpts;\n  if (typeof mapPropsToOptions !== 'function') {\n    mapPropsToOptions = () => options as QueryOpts;\n  }\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') {\n    mapPropsToSkip = () => skip as any;\n  }\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>,\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip ? Object.create(null) : { ...mapPropsToOptions(props) };\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(\n            operation,\n            props,\n          );\n        }\n        return (\n          <Query\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            query={document}\n            warnUnhandledError\n          >\n            {({ client: _, data, ...r }) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance,\n                });\n              }\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...props as TProps}\n                    {...{} as TChildProps}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<TProps, TData, TGraphQLVariables> = {\n                  [name]: result,\n                  ownProps: props as TProps,\n                };\n                lastResultProps = operationOptions.props(newResult, lastResultProps);\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Query>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from './parser';\nimport { MutationOpts, OperationOption, OptionProps, MutateProps } from './types';\nimport { default as Mutation } from './Mutation';\nimport {\n  defaultMapPropsToOptions,\n  getDisplayName,\n  calculateVariablesFromProps,\n  GraphQLBase,\n} from './hoc-utils';\n\nexport function withMutation<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = MutateProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n\n  const { options = defaultMapPropsToOptions, alias = 'Apollo' } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => MutationOpts;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = () => options as MutationOpts;\n\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>,\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      render() {\n        let props = this.props;\n        const opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance,\n          });\n        }\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(\n            operation,\n            props,\n          );\n        }\n\n        return (\n          <Mutation {...opts} mutation={document} ignoreResults>\n            {(mutate, { data, ...r }) => {\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Mutation component's shape here to replicate that\n              // this matches the query HoC\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'mutate';\n              const resultName = operationOptions.name ? `${name}Result` : 'result';\n              let childProps = { [name]: mutate, [resultName]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<TProps, TData, TGraphQLVariables> = {\n                  [name]: mutate,\n                  [resultName]: result,\n                  ownProps: props,\n                };\n                childProps = operationOptions.props(newResult) as any;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Mutation>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from './parser';\nimport { OperationOption, QueryOpts, OptionProps, DataProps } from './types';\nimport { default as Subscription } from './Subscriptions';\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip,\n} from './hoc-utils';\n\nexport function withSubscription<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo',\n    shouldResubscribe,\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => QueryOpts;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = () => options as QueryOpts;\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = () => skip as any;\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>,\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps, { resubscribe: boolean }> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      constructor(props: TProps) {\n        super(props);\n        this.state = { resubscribe: false };\n      }\n      componentWillReceiveProps(nextProps: TProps) {\n        if (!shouldResubscribe) return;\n        this.setState({\n          resubscribe: shouldResubscribe(this.props, nextProps),\n        });\n      }\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip ? Object.create(null) : mapPropsToOptions(props);\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(\n            operation,\n            props,\n          );\n        }\n        return (\n          <Subscription\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            subscription={document}\n            shouldResubscribe={this.state.resubscribe}\n          >\n            {({ data, ...r }) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance,\n                });\n              }\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...props as TProps}\n                    {...{} as TChildProps}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<TProps, TData, TGraphQLVariables> = {\n                  [name]: result,\n                  ownProps: props as TProps,\n                };\n                lastResultProps = operationOptions.props(newResult, lastResultProps);\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Subscription>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport { parser, DocumentType } from './parser';\nimport { OperationOption, DataProps, MutateProps } from './types';\n\nimport { withQuery } from './query-hoc';\nimport { withMutation } from './mutation-hoc';\nimport { withSubscription } from './subscription-hoc';\n\nexport function graphql<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = Partial<DataProps<TData, TGraphQLVariables>> &\n    Partial<MutateProps<TData, TGraphQLVariables>>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  switch (parser(document).type) {\n    case DocumentType.Mutation:\n      return withMutation(document, operationOptions);\n    case DocumentType.Subscription:\n      return withSubscription(document, operationOptions);\n    // case DocumentType.Fragment:\n    //   throw new Error('fragments cannont currently be used on their own');\n    case DocumentType.Query:\n    default:\n      return withQuery(document, operationOptions);\n  }\n}\n","import * as React from 'react';\nimport { OperationOption } from './types';\nimport ApolloConsumer from './ApolloConsumer';\nimport { ApolloClient } from 'apollo-client';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { invariant } from 'ts-invariant';\n\nfunction getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport type WithApolloClient<P> = P & { client: ApolloClient<any> };\n\nexport default function withApollo<TProps, TResult = any>(\n  WrappedComponent: React.ComponentType<WithApolloClient<TProps>>,\n  operationOptions: OperationOption<TProps, TResult> = {},\n): React.ComponentClass<TProps> {\n  const withDisplayName = `withApollo(${getDisplayName(WrappedComponent)})`;\n\n  class WithApollo extends React.Component<TProps> {\n    static displayName = withDisplayName;\n    static WrappedComponent = WrappedComponent;\n\n    // wrapped instance\n    private wrappedInstance: any;\n\n    constructor(props: TProps) {\n      super(props);\n      this.setWrappedInstance = this.setWrappedInstance.bind(this);\n    }\n\n    getWrappedInstance() {\n      invariant(\n        operationOptions.withRef,\n        `To access the wrapped instance, you need to specify ` + `{ withRef: true } in the options`,\n      );\n\n      return this.wrappedInstance;\n    }\n\n    setWrappedInstance(ref: React.ComponentType<WithApolloClient<TProps>>) {\n      this.wrappedInstance = ref;\n    }\n\n    render() {\n      return (\n        <ApolloConsumer>\n          {client => {\n            const props = Object.assign({}, this.props, {\n              client,\n              ref: operationOptions.withRef ? this.setWrappedInstance : undefined,\n            });\n            return <WrappedComponent {...props} />;\n          }}\n        </ApolloConsumer>\n      );\n    }\n  }\n\n  // Make sure we preserve any custom statics on the original component.\n  return hoistNonReactStatics(WithApollo, WrappedComponent, {});\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport Query from './Query';\nimport { ObservableQuery } from 'apollo-client';\nimport { DocumentNode } from 'graphql';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n}\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null,\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<Query<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    queryInstance: Query<TData, TVariables>,\n    observable: ObservableQuery<any, TVariables>,\n  ) {\n    this.lookupQueryInfo(queryInstance).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(queryInstance: Query<TData, TVariables>) {\n    return this.lookupQueryInfo(queryInstance).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: Query<TData, TVariables>,\n    finish: () => React.ReactNode,\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance);\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance,\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        }),\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    queryInstance: Query<TData, TVariables>,\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = queryInstance.props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n\nexport default function getDataFromTree(\n  tree: React.ReactNode,\n  context: { [key: string]: any } = {},\n) {\n  return getMarkupFromTree({\n    tree,\n    context,\n    // If you need to configure this renderFunction, call getMarkupFromTree\n    // directly instead of getDataFromTree.\n    renderFunction: require(\"react-dom/server\").renderToStaticMarkup,\n  });\n}\n\nexport type GetMarkupFromTreeOptions = {\n  tree: React.ReactNode;\n  context?: { [key: string]: any };\n  renderFunction?: (tree: React.ReactElement<any>) => string;\n};\n\nexport function getMarkupFromTree({\n  tree,\n  context = {},\n  // The rendering function is configurable! We use renderToStaticMarkup as\n  // the default, because it's a little less expensive than renderToString,\n  // and legacy usage of getDataFromTree ignores the return value anyway.\n  renderFunction = require(\"react-dom/server\").renderToStaticMarkup,\n}: GetMarkupFromTreeOptions): Promise<string> {\n  const renderPromises = new RenderPromises();\n\n  class RenderPromisesProvider extends React.Component {\n    static childContextTypes: { [key: string]: any } = {\n      renderPromises: PropTypes.object,\n    };\n\n    getChildContext() {\n      return { ...context, renderPromises };\n    }\n\n    render() {\n      // Always re-render from the rootElement, even though it might seem\n      // better to render the children of the component responsible for the\n      // promise, because it is not possible to reconstruct the full context\n      // of the original rendering (including all unknown context provider\n      // elements) for a subtree of the orginal component tree.\n      return tree;\n    }\n  }\n\n  Object.keys(context).forEach(key => {\n    RenderPromisesProvider.childContextTypes[key] = PropTypes.any;\n  });\n\n  function process(): Promise<string> | string {\n    const html = renderFunction(React.createElement(RenderPromisesProvider));\n    return renderPromises.hasPromises()\n      ? renderPromises.consumeAndAwaitPromises().then(process)\n      : html;\n  }\n\n  return Promise.resolve().then(process);\n}\n","import { ReactElement } from 'react';\nimport { getMarkupFromTree } from './getDataFromTree';\n\nexport function renderToStringWithData(component: ReactElement<any>): Promise<string> {\n  return getMarkupFromTree({\n    tree: component,\n    renderFunction: require(\"react-dom/server\").renderToString,\n  });\n}\n","export function compose(...funcs: Function[]) {\n  const functions = funcs.reverse();\n  return function (...args: any[]) {\n    const [firstFunction, ...restFunctions] = functions\n    let result = firstFunction.apply(null, args);\n    restFunctions.forEach((fnc) => {\n      result = fnc.call(null, result)\n    });\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}