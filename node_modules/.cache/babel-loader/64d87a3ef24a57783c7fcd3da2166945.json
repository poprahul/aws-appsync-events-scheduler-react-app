{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribe = subscribe;\nexports.createSourceEventStream = createSourceEventStream;\n\nvar _iterall = require('iterall');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _locatedError = require('../error/locatedError');\n\nvar _execute = require('../execution/execute');\n\nvar _schema = require('../type/schema');\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _mapAsyncIterator = require('./mapAsyncIterator');\n\nvar _mapAsyncIterator2 = _interopRequireDefault(_mapAsyncIterator);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (client error). The promise will be rejected if a\n * server error occurs.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\n/* eslint-disable no-redeclare */\n\n\nfunction subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  // Extract arguments from object args if provided.\n  var args = arguments.length === 1 ? argsOrSchema : undefined;\n  var schema = args ? args.schema : argsOrSchema;\n  return args ? subscribeImpl(schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.subscribeFieldResolver) : subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\n/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction reportGraphQLError(error) {\n  if (error instanceof _GraphQLError.GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return (0, _execute.execute)(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (sourceStream) {\n    return (0, _mapAsyncIterator2.default)(sourceStream, mapSourceToResponse, reportGraphQLError);\n  }, reportGraphQLError);\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise<AsyncIterable>.\n *\n * If the client-provided invalid arguments, the source stream could not be\n * created, or the resolver did not return an AsyncIterable, this function will\n * will throw an error, which should be caught and handled by the caller.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nfunction createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);\n  return new Promise(function (resolve, reject) {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = (0, _execute.buildExecutionContext)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n    var type = (0, _execute.getOperationRootType)(schema, exeContext.operation);\n    var fields = (0, _execute.collectFields)(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldNode.name.value);\n    !fieldDef ? (0, _invariant2.default)(0, 'This subscription is not defined by the schema.') : void 0; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n    var path = (0, _execute.addPath)(undefined, responseName);\n    var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    Promise.resolve((0, _execute.resolveFieldValueOrError)(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info)).then(function (subscription) {\n      // Reject with a located GraphQLError if subscription source fails\n      // to resolve.\n      if (subscription instanceof Error) {\n        var error = (0, _locatedError.locatedError)(subscription, fieldNodes, (0, _execute.responsePathAsArray)(path));\n        reject(error);\n      }\n\n      if (!(0, _iterall.isAsyncIterable)(subscription)) {\n        reject(new Error('Subscription must return Async Iterable. ' + 'Received: ' + String(subscription)));\n      }\n\n      resolve(subscription);\n    }).catch(reject);\n  });\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/subscription/subscribe.js"],"names":["Object","defineProperty","exports","value","subscribe","createSourceEventStream","_iterall","require","_GraphQLError","_locatedError","_execute","_schema","_invariant","_invariant2","_interopRequireDefault","_mapAsyncIterator","_mapAsyncIterator2","obj","__esModule","default","argsOrSchema","document","rootValue","contextValue","variableValues","operationName","fieldResolver","subscribeFieldResolver","args","arguments","length","undefined","schema","subscribeImpl","reportGraphQLError","error","GraphQLError","errors","sourcePromise","mapSourceToResponse","payload","execute","then","sourceStream","assertValidExecutionArguments","Promise","resolve","reject","exeContext","buildExecutionContext","type","getOperationRootType","operation","fields","collectFields","selectionSet","create","responseNames","keys","responseName","fieldNodes","fieldNode","fieldDef","getFieldDef","name","resolveFn","path","addPath","info","buildResolveInfo","resolveFieldValueOrError","subscription","Error","locatedError","responsePathAsArray","isAsyncIterable","String","catch"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,SAAR,GAAoBA,SAApB;AACAF,OAAO,CAACG,uBAAR,GAAkCA,uBAAlC;;AAEA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AAEA,IAAIC,aAAa,GAAGD,OAAO,CAAC,uBAAD,CAA3B;;AAEA,IAAIE,aAAa,GAAGF,OAAO,CAAC,uBAAD,CAA3B;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,sBAAD,CAAtB;;AAEA,IAAII,OAAO,GAAGJ,OAAO,CAAC,gBAAD,CAArB;;AAEA,IAAIK,UAAU,GAAGL,OAAO,CAAC,sBAAD,CAAxB;;AAEA,IAAIM,WAAW,GAAGC,sBAAsB,CAACF,UAAD,CAAxC;;AAEA,IAAIG,iBAAiB,GAAGR,OAAO,CAAC,oBAAD,CAA/B;;AAEA,IAAIS,kBAAkB,GAAGF,sBAAsB,CAACC,iBAAD,CAA/C;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AACA,SAASb,SAAT,CAAmBgB,YAAnB,EAAiCC,QAAjC,EAA2CC,SAA3C,EAAsDC,YAAtD,EAAoEC,cAApE,EAAoFC,aAApF,EAAmGC,aAAnG,EAAkHC,sBAAlH,EAA0I;AACxI;AACA,MAAIC,IAAI,GAAGC,SAAS,CAACC,MAAV,KAAqB,CAArB,GAAyBV,YAAzB,GAAwCW,SAAnD;AACA,MAAIC,MAAM,GAAGJ,IAAI,GAAGA,IAAI,CAACI,MAAR,GAAiBZ,YAAlC;AAEA,SAAOQ,IAAI,GAAGK,aAAa,CAACD,MAAD,EAASJ,IAAI,CAACP,QAAd,EAAwBO,IAAI,CAACN,SAA7B,EAAwCM,IAAI,CAACL,YAA7C,EAA2DK,IAAI,CAACJ,cAAhE,EAAgFI,IAAI,CAACH,aAArF,EAAoGG,IAAI,CAACF,aAAzG,EAAwHE,IAAI,CAACD,sBAA7H,CAAhB,GAAuKM,aAAa,CAACD,MAAD,EAASX,QAAT,EAAmBC,SAAnB,EAA8BC,YAA9B,EAA4CC,cAA5C,EAA4DC,aAA5D,EAA2EC,aAA3E,EAA0FC,sBAA1F,CAA/L;AACD;AAED;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASO,kBAAT,CAA4BC,KAA5B,EAAmC;AACjC,MAAIA,KAAK,YAAY3B,aAAa,CAAC4B,YAAnC,EAAiD;AAC/C,WAAO;AAAEC,MAAAA,MAAM,EAAE,CAACF,KAAD;AAAV,KAAP;AACD;;AACD,QAAMA,KAAN;AACD;;AAED,SAASF,aAAT,CAAuBD,MAAvB,EAA+BX,QAA/B,EAAyCC,SAAzC,EAAoDC,YAApD,EAAkEC,cAAlE,EAAkFC,aAAlF,EAAiGC,aAAjG,EAAgHC,sBAAhH,EAAwI;AACtI,MAAIW,aAAa,GAAGjC,uBAAuB,CAAC2B,MAAD,EAASX,QAAT,EAAmBC,SAAnB,EAA8BC,YAA9B,EAA4CC,cAA5C,EAA4DC,aAA5D,EAA2EE,sBAA3E,CAA3C,CADsI,CAGtI;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIY,mBAAmB,GAAG,SAASA,mBAAT,CAA6BC,OAA7B,EAAsC;AAC9D,WAAO,CAAC,GAAG9B,QAAQ,CAAC+B,OAAb,EAAsBT,MAAtB,EAA8BX,QAA9B,EAAwCmB,OAAxC,EAAiDjB,YAAjD,EAA+DC,cAA/D,EAA+EC,aAA/E,EAA8FC,aAA9F,CAAP;AACD,GAFD,CATsI,CAatI;AACA;;;AACA,SAAOY,aAAa,CAACI,IAAd,CAAmB,UAAUC,YAAV,EAAwB;AAChD,WAAO,CAAC,GAAG3B,kBAAkB,CAACG,OAAvB,EAAgCwB,YAAhC,EAA8CJ,mBAA9C,EAAmEL,kBAAnE,CAAP;AACD,GAFM,EAEJA,kBAFI,CAAP;AAGD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS7B,uBAAT,CAAiC2B,MAAjC,EAAyCX,QAAzC,EAAmDC,SAAnD,EAA8DC,YAA9D,EAA4EC,cAA5E,EAA4FC,aAA5F,EAA2GC,aAA3G,EAA0H;AACxH;AACA;AACA,GAAC,GAAGhB,QAAQ,CAACkC,6BAAb,EAA4CZ,MAA5C,EAAoDX,QAApD,EAA8DG,cAA9D;AAEA,SAAO,IAAIqB,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C;AACA;AACA,QAAIC,UAAU,GAAG,CAAC,GAAGtC,QAAQ,CAACuC,qBAAb,EAAoCjB,MAApC,EAA4CX,QAA5C,EAAsDC,SAAtD,EAAiEC,YAAjE,EAA+EC,cAA/E,EAA+FC,aAA/F,EAA8GC,aAA9G,CAAjB;AAEA,QAAIwB,IAAI,GAAG,CAAC,GAAGxC,QAAQ,CAACyC,oBAAb,EAAmCnB,MAAnC,EAA2CgB,UAAU,CAACI,SAAtD,CAAX;AACA,QAAIC,MAAM,GAAG,CAAC,GAAG3C,QAAQ,CAAC4C,aAAb,EAA4BN,UAA5B,EAAwCE,IAAxC,EAA8CF,UAAU,CAACI,SAAX,CAAqBG,YAAnE,EAAiFvD,MAAM,CAACwD,MAAP,CAAc,IAAd,CAAjF,EAAsGxD,MAAM,CAACwD,MAAP,CAAc,IAAd,CAAtG,CAAb;AACA,QAAIC,aAAa,GAAGzD,MAAM,CAAC0D,IAAP,CAAYL,MAAZ,CAApB;AACA,QAAIM,YAAY,GAAGF,aAAa,CAAC,CAAD,CAAhC;AACA,QAAIG,UAAU,GAAGP,MAAM,CAACM,YAAD,CAAvB;AACA,QAAIE,SAAS,GAAGD,UAAU,CAAC,CAAD,CAA1B;AACA,QAAIE,QAAQ,GAAG,CAAC,GAAGpD,QAAQ,CAACqD,WAAb,EAA0B/B,MAA1B,EAAkCkB,IAAlC,EAAwCW,SAAS,CAACG,IAAV,CAAe7D,KAAvD,CAAf;AACA,KAAC2D,QAAD,GAAY,CAAC,GAAGjD,WAAW,CAACM,OAAhB,EAAyB,CAAzB,EAA4B,iDAA5B,CAAZ,GAA6F,KAAK,CAAlG,CAZ4C,CAc5C;AACA;;AACA,QAAI8C,SAAS,GAAGH,QAAQ,CAAC1D,SAAT,IAAsB4C,UAAU,CAACtB,aAAjD;AAEA,QAAIwC,IAAI,GAAG,CAAC,GAAGxD,QAAQ,CAACyD,OAAb,EAAsBpC,SAAtB,EAAiC4B,YAAjC,CAAX;AAEA,QAAIS,IAAI,GAAG,CAAC,GAAG1D,QAAQ,CAAC2D,gBAAb,EAA+BrB,UAA/B,EAA2Cc,QAA3C,EAAqDF,UAArD,EAAiEV,IAAjE,EAAuEgB,IAAvE,CAAX,CApB4C,CAsB5C;AACA;AACA;;AACArB,IAAAA,OAAO,CAACC,OAAR,CAAgB,CAAC,GAAGpC,QAAQ,CAAC4D,wBAAb,EAAuCtB,UAAvC,EAAmDc,QAAnD,EAA6DF,UAA7D,EAAyEK,SAAzE,EAAoF3C,SAApF,EAA+F8C,IAA/F,CAAhB,EAAsH1B,IAAtH,CAA2H,UAAU6B,YAAV,EAAwB;AACjJ;AACA;AACA,UAAIA,YAAY,YAAYC,KAA5B,EAAmC;AACjC,YAAIrC,KAAK,GAAG,CAAC,GAAG1B,aAAa,CAACgE,YAAlB,EAAgCF,YAAhC,EAA8CX,UAA9C,EAA0D,CAAC,GAAGlD,QAAQ,CAACgE,mBAAb,EAAkCR,IAAlC,CAA1D,CAAZ;AACAnB,QAAAA,MAAM,CAACZ,KAAD,CAAN;AACD;;AAED,UAAI,CAAC,CAAC,GAAG7B,QAAQ,CAACqE,eAAb,EAA8BJ,YAA9B,CAAL,EAAkD;AAChDxB,QAAAA,MAAM,CAAC,IAAIyB,KAAJ,CAAU,8CAA8C,YAA9C,GAA6DI,MAAM,CAACL,YAAD,CAA7E,CAAD,CAAN;AACD;;AAEDzB,MAAAA,OAAO,CAACyB,YAAD,CAAP;AACD,KAbD,EAaGM,KAbH,CAaS9B,MAbT;AAcD,GAvCM,CAAP;AAwCD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribe = subscribe;\nexports.createSourceEventStream = createSourceEventStream;\n\nvar _iterall = require('iterall');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _locatedError = require('../error/locatedError');\n\nvar _execute = require('../execution/execute');\n\nvar _schema = require('../type/schema');\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _mapAsyncIterator = require('./mapAsyncIterator');\n\nvar _mapAsyncIterator2 = _interopRequireDefault(_mapAsyncIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (client error). The promise will be rejected if a\n * server error occurs.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\n/* eslint-disable no-redeclare */\nfunction subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  // Extract arguments from object args if provided.\n  var args = arguments.length === 1 ? argsOrSchema : undefined;\n  var schema = args ? args.schema : argsOrSchema;\n\n  return args ? subscribeImpl(schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.subscribeFieldResolver) : subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);\n}\n\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof _GraphQLError.GraphQLError) {\n    return { errors: [error] };\n  }\n  throw error;\n}\n\nfunction subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);\n\n  // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return (0, _execute.execute)(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  };\n\n  // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n  return sourcePromise.then(function (sourceStream) {\n    return (0, _mapAsyncIterator2.default)(sourceStream, mapSourceToResponse, reportGraphQLError);\n  }, reportGraphQLError);\n}\n\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise<AsyncIterable>.\n *\n * If the client-provided invalid arguments, the source stream could not be\n * created, or the resolver did not return an AsyncIterable, this function will\n * will throw an error, which should be caught and handled by the caller.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\nfunction createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);\n\n  return new Promise(function (resolve, reject) {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = (0, _execute.buildExecutionContext)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n\n    var type = (0, _execute.getOperationRootType)(schema, exeContext.operation);\n    var fields = (0, _execute.collectFields)(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldNode.name.value);\n    !fieldDef ? (0, _invariant2.default)(0, 'This subscription is not defined by the schema.') : void 0;\n\n    // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n\n    var path = (0, _execute.addPath)(undefined, responseName);\n\n    var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path);\n\n    // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    Promise.resolve((0, _execute.resolveFieldValueOrError)(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info)).then(function (subscription) {\n      // Reject with a located GraphQLError if subscription source fails\n      // to resolve.\n      if (subscription instanceof Error) {\n        var error = (0, _locatedError.locatedError)(subscription, fieldNodes, (0, _execute.responsePathAsArray)(path));\n        reject(error);\n      }\n\n      if (!(0, _iterall.isAsyncIterable)(subscription)) {\n        reject(new Error('Subscription must return Async Iterable. ' + 'Received: ' + String(subscription)));\n      }\n\n      resolve(subscription);\n    }).catch(reject);\n  });\n}"]},"metadata":{},"sourceType":"script"}