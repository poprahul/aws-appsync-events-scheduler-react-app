{"ast":null,"code":"/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { GraphQLSchema } from '../type/schema';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  NON_NULL_ARG_ADDED: 'NON_NULL_ARG_ADDED',\n  NON_NULL_INPUT_FIELD_ADDED: 'NON_NULL_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  NON_NULL_DIRECTIVE_ARG_ADDED: 'NON_NULL_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  NULLABLE_INPUT_FIELD_ADDED: 'NULLABLE_INPUT_FIELD_ADDED',\n  NULLABLE_ARG_ADDED: 'NULLABLE_ARG_ADDED'\n};\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return [].concat(findRemovedTypes(oldSchema, newSchema), findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return [].concat(findArgChanges(oldSchema, newSchema).dangerousChanges, findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: typeName + ' was removed.'\n      });\n    }\n  });\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      return;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: typeName + ' changed from ' + (typeKindName(oldType) + ' to ' + typeKindName(newType) + '.')\n      });\n    }\n  });\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n    Object.keys(oldTypeFields).forEach(function (fieldName) {\n      if (!newTypeFields[fieldName]) {\n        return;\n      }\n\n      oldTypeFields[fieldName].args.forEach(function (oldArgDef) {\n        var newArgs = newTypeFields[fieldName].args;\n        var newArgDef = newArgs.find(function (arg) {\n          return arg.name === oldArgDef.name;\n        }); // Arg not present\n\n        if (!newArgDef) {\n          breakingChanges.push({\n            type: BreakingChangeType.ARG_REMOVED,\n            description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' was removed')\n          });\n        } else {\n          var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n          if (!isSafe) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_CHANGED_KIND,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed type from ') + (oldArgDef.type.toString() + ' to ' + newArgDef.type.toString())\n            });\n          } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n            dangerousChanges.push({\n              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed defaultValue')\n            });\n          }\n        }\n      }); // Check if a non-null arg was added to the field\n\n      newTypeFields[fieldName].args.forEach(function (newArgDef) {\n        var oldArgs = oldTypeFields[fieldName].args;\n        var oldArgDef = oldArgs.find(function (arg) {\n          return arg.name === newArgDef.name;\n        });\n\n        if (!oldArgDef) {\n          if (isNonNullType(newArgDef.type)) {\n            breakingChanges.push({\n              type: BreakingChangeType.NON_NULL_ARG_ADDED,\n              description: 'A non-null arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          } else {\n            dangerousChanges.push({\n              type: DangerousChangeType.NULLABLE_ARG_ADDED,\n              description: 'A nullable arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          }\n        }\n      });\n    });\n  });\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    });\n  });\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    }); // Check if a field was added to the input object type\n\n    Object.keys(newTypeFieldsDef).forEach(function (fieldName) {\n      if (!(fieldName in oldTypeFieldsDef)) {\n        if (isNonNullType(newTypeFieldsDef[fieldName].type)) {\n          breakingChanges.push({\n            type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,\n            description: 'A non-null field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.NULLABLE_INPUT_FIELD_ADDED,\n            description: 'A nullable field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        }\n      }\n    });\n  });\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    newType.getTypes().forEach(function (type) {\n      typeNamesInNewUnion[type.name] = true;\n    });\n    oldType.getTypes().forEach(function (type) {\n      if (!typeNamesInNewUnion[type.name]) {\n        typesRemovedFromUnion.push({\n          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n          description: type.name + ' was removed from union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    oldType.getTypes().forEach(function (type) {\n      typeNamesInOldUnion[type.name] = true;\n    });\n    newType.getTypes().forEach(function (type) {\n      if (!typeNamesInOldUnion[type.name]) {\n        typesAddedToUnion.push({\n          type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n          description: type.name + ' was added to union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    newType.getValues().forEach(function (value) {\n      valuesInNewEnum[value.name] = true;\n    });\n    oldType.getValues().forEach(function (value) {\n      if (!valuesInNewEnum[value.name]) {\n        valuesRemovedFromEnums.push({\n          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n          description: value.name + ' was removed from enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    oldType.getValues().forEach(function (value) {\n      valuesInOldEnum[value.name] = true;\n    });\n    newType.getValues().forEach(function (value) {\n      if (!valuesInOldEnum[value.name]) {\n        valuesAddedToEnums.push({\n          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n          description: value.name + ' was added to enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    oldInterfaces.forEach(function (oldInterface) {\n      if (!newInterfaces.some(function (int) {\n        return int.name === oldInterface.name;\n      })) {\n        breakingChanges.push({\n          type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n          description: typeName + ' no longer implements interface ' + (oldInterface.name + '.')\n        });\n      }\n    });\n  });\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    newInterfaces.forEach(function (newInterface) {\n      if (!oldInterfaces.some(function (int) {\n        return int.name === newInterface.name;\n      })) {\n        interfacesAddedToObjectTypes.push({\n          type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n          description: newInterface.name + ' added to interfaces implemented ' + ('by ' + typeName + '.')\n        });\n      }\n    });\n  });\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  oldSchema.getDirectives().forEach(function (directive) {\n    if (!newSchemaDirectiveMap[directive.name]) {\n      removedDirectives.push({\n        type: BreakingChangeType.DIRECTIVE_REMOVED,\n        description: directive.name + ' was removed'\n      });\n    }\n  });\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  oldDirective.args.forEach(function (arg) {\n    if (!newArgMap[arg.name]) {\n      removedArgs.push(arg);\n    }\n  });\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      removedDirectiveArgs.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: arg.name + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  newDirective.args.forEach(function (arg) {\n    if (!oldArgMap[arg.name]) {\n      addedArgs.push(arg);\n    }\n  });\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n    if (!oldDirective) {\n      return;\n    }\n\n    findAddedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      if (!isNonNullType(arg.type)) {\n        return;\n      }\n\n      addedNonNullableArgs.push({\n        type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,\n        description: 'A non-null arg ' + arg.name + ' on directive ' + (newDirective.name + ' was added')\n      });\n    });\n  });\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  oldDirective.locations.forEach(function (oldLocation) {\n    if (!newLocationSet.has(oldLocation)) {\n      removedLocations.push(oldLocation);\n    }\n  });\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedLocationsForDirective(oldDirective, newDirective).forEach(function (location) {\n      removedLocations.push({\n        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n        description: location + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/findBreakingChanges.js"],"names":["isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNonNullType","isListType","isNamedType","GraphQLDirective","GraphQLSchema","keyMap","BreakingChangeType","FIELD_CHANGED_KIND","FIELD_REMOVED","TYPE_CHANGED_KIND","TYPE_REMOVED","TYPE_REMOVED_FROM_UNION","VALUE_REMOVED_FROM_ENUM","ARG_REMOVED","ARG_CHANGED_KIND","NON_NULL_ARG_ADDED","NON_NULL_INPUT_FIELD_ADDED","INTERFACE_REMOVED_FROM_OBJECT","DIRECTIVE_REMOVED","DIRECTIVE_ARG_REMOVED","DIRECTIVE_LOCATION_REMOVED","NON_NULL_DIRECTIVE_ARG_ADDED","DangerousChangeType","ARG_DEFAULT_VALUE_CHANGE","VALUE_ADDED_TO_ENUM","INTERFACE_ADDED_TO_OBJECT","TYPE_ADDED_TO_UNION","NULLABLE_INPUT_FIELD_ADDED","NULLABLE_ARG_ADDED","findBreakingChanges","oldSchema","newSchema","concat","findRemovedTypes","findTypesThatChangedKind","findFieldsThatChangedTypeOnObjectOrInterfaceTypes","findFieldsThatChangedTypeOnInputObjectTypes","breakingChanges","findTypesRemovedFromUnions","findValuesRemovedFromEnums","findArgChanges","findInterfacesRemovedFromObjectTypes","findRemovedDirectives","findRemovedDirectiveArgs","findAddedNonNullDirectiveArgs","findRemovedDirectiveLocations","findDangerousChanges","dangerousChanges","findValuesAddedToEnums","findInterfacesAddedToObjectTypes","findTypesAddedToUnions","oldTypeMap","getTypeMap","newTypeMap","Object","keys","forEach","typeName","push","type","description","oldType","newType","constructor","typeKindName","oldTypeFields","getFields","newTypeFields","fieldName","args","oldArgDef","newArgs","newArgDef","find","arg","name","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","toString","defaultValue","undefined","oldArgs","TypeError","oldTypeFieldsDef","newTypeFieldsDef","oldFieldType","newFieldType","isChangeSafeForObjectOrInterfaceField","oldFieldTypeString","newFieldTypeString","ofType","typesRemovedFromUnion","typeNamesInNewUnion","create","getTypes","typesAddedToUnion","typeNamesInOldUnion","valuesRemovedFromEnums","valuesInNewEnum","getValues","value","valuesAddedToEnums","valuesInOldEnum","oldInterfaces","getInterfaces","newInterfaces","oldInterface","some","int","interfacesAddedToObjectTypes","newInterface","removedDirectives","newSchemaDirectiveMap","getDirectiveMapForSchema","getDirectives","directive","findRemovedArgsForDirective","oldDirective","newDirective","removedArgs","newArgMap","getArgumentMapForDirective","removedDirectiveArgs","oldSchemaDirectiveMap","findAddedArgsForDirective","addedArgs","oldArgMap","addedNonNullableArgs","findRemovedLocationsForDirective","removedLocations","newLocationSet","Set","locations","oldLocation","has","location","schema","dir"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,YAAT,EAAuBC,YAAvB,EAAqCC,eAArC,EAAsDC,WAAtD,EAAmEC,UAAnE,EAA+EC,iBAA/E,EAAkGC,aAAlG,EAAiHC,UAAjH,EAA6HC,WAA7H,QAAgJ,oBAAhJ;AAEA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,aAAT,QAA8B,gBAA9B;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AAEA,OAAO,IAAIC,kBAAkB,GAAG;AAC9BC,EAAAA,kBAAkB,EAAE,oBADU;AAE9BC,EAAAA,aAAa,EAAE,eAFe;AAG9BC,EAAAA,iBAAiB,EAAE,mBAHW;AAI9BC,EAAAA,YAAY,EAAE,cAJgB;AAK9BC,EAAAA,uBAAuB,EAAE,yBALK;AAM9BC,EAAAA,uBAAuB,EAAE,yBANK;AAO9BC,EAAAA,WAAW,EAAE,aAPiB;AAQ9BC,EAAAA,gBAAgB,EAAE,kBARY;AAS9BC,EAAAA,kBAAkB,EAAE,oBATU;AAU9BC,EAAAA,0BAA0B,EAAE,4BAVE;AAW9BC,EAAAA,6BAA6B,EAAE,+BAXD;AAY9BC,EAAAA,iBAAiB,EAAE,mBAZW;AAa9BC,EAAAA,qBAAqB,EAAE,uBAbO;AAc9BC,EAAAA,0BAA0B,EAAE,4BAdE;AAe9BC,EAAAA,4BAA4B,EAAE;AAfA,CAAzB;AAkBP,OAAO,IAAIC,mBAAmB,GAAG;AAC/BC,EAAAA,wBAAwB,EAAE,0BADK;AAE/BC,EAAAA,mBAAmB,EAAE,qBAFU;AAG/BC,EAAAA,yBAAyB,EAAE,2BAHI;AAI/BC,EAAAA,mBAAmB,EAAE,qBAJU;AAK/BC,EAAAA,0BAA0B,EAAE,4BALG;AAM/BC,EAAAA,kBAAkB,EAAE;AANW,CAA1B;AASP;AACA;AACA;AACA;;AACA,OAAO,SAASC,mBAAT,CAA6BC,SAA7B,EAAwCC,SAAxC,EAAmD;AACxD,SAAO,GAAGC,MAAH,CAAUC,gBAAgB,CAACH,SAAD,EAAYC,SAAZ,CAA1B,EAAkDG,wBAAwB,CAACJ,SAAD,EAAYC,SAAZ,CAA1E,EAAkGI,iDAAiD,CAACL,SAAD,EAAYC,SAAZ,CAAnJ,EAA2KK,2CAA2C,CAACN,SAAD,EAAYC,SAAZ,CAA3C,CAAkEM,eAA7O,EAA8PC,0BAA0B,CAACR,SAAD,EAAYC,SAAZ,CAAxR,EAAgTQ,0BAA0B,CAACT,SAAD,EAAYC,SAAZ,CAA1U,EAAkWS,cAAc,CAACV,SAAD,EAAYC,SAAZ,CAAd,CAAqCM,eAAvY,EAAwZI,oCAAoC,CAACX,SAAD,EAAYC,SAAZ,CAA5b,EAAodW,qBAAqB,CAACZ,SAAD,EAAYC,SAAZ,CAAze,EAAigBY,wBAAwB,CAACb,SAAD,EAAYC,SAAZ,CAAzhB,EAAijBa,6BAA6B,CAACd,SAAD,EAAYC,SAAZ,CAA9kB,EAAsmBc,6BAA6B,CAACf,SAAD,EAAYC,SAAZ,CAAnoB,CAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASe,oBAAT,CAA8BhB,SAA9B,EAAyCC,SAAzC,EAAoD;AACzD,SAAO,GAAGC,MAAH,CAAUQ,cAAc,CAACV,SAAD,EAAYC,SAAZ,CAAd,CAAqCgB,gBAA/C,EAAiEC,sBAAsB,CAAClB,SAAD,EAAYC,SAAZ,CAAvF,EAA+GkB,gCAAgC,CAACnB,SAAD,EAAYC,SAAZ,CAA/I,EAAuKmB,sBAAsB,CAACpB,SAAD,EAAYC,SAAZ,CAA7L,EAAqNK,2CAA2C,CAACN,SAAD,EAAYC,SAAZ,CAA3C,CAAkEgB,gBAAvR,CAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASd,gBAAT,CAA0BH,SAA1B,EAAqCC,SAArC,EAAgD;AACrD,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAIf,eAAe,GAAG,EAAtB;AACAiB,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAI,CAACJ,UAAU,CAACI,QAAD,CAAf,EAA2B;AACzBpB,MAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,QAAAA,IAAI,EAAErD,kBAAkB,CAACI,YADN;AAEnBkD,QAAAA,WAAW,EAAEH,QAAQ,GAAG;AAFL,OAArB;AAID;AACF,GAPD;AAQA,SAAOpB,eAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASH,wBAAT,CAAkCJ,SAAlC,EAA6CC,SAA7C,EAAwD;AAC7D,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAIf,eAAe,GAAG,EAAtB;AACAiB,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAI,CAACJ,UAAU,CAACI,QAAD,CAAf,EAA2B;AACzB;AACD;;AACD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAII,OAAO,CAACE,WAAR,KAAwBD,OAAO,CAACC,WAApC,EAAiD;AAC/C1B,MAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,QAAAA,IAAI,EAAErD,kBAAkB,CAACG,iBADN;AAEnBmD,QAAAA,WAAW,EAAEH,QAAQ,GAAG,gBAAX,IAA+BO,YAAY,CAACH,OAAD,CAAZ,GAAwB,MAAxB,GAAiCG,YAAY,CAACF,OAAD,CAA7C,GAAyD,GAAxF;AAFM,OAArB;AAID;AACF,GAZD;AAaA,SAAOzB,eAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,cAAT,CAAwBV,SAAxB,EAAmCC,SAAnC,EAA8C;AACnD,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAIf,eAAe,GAAG,EAAtB;AACA,MAAIU,gBAAgB,GAAG,EAAvB;AAEAO,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,EAAE9D,YAAY,CAACkE,OAAD,CAAZ,IAAyBjE,eAAe,CAACiE,OAAD,CAA1C,KAAwD,EAAElE,YAAY,CAACmE,OAAD,CAAZ,IAAyBlE,eAAe,CAACkE,OAAD,CAA1C,CAAxD,IAAgHA,OAAO,CAACC,WAAR,KAAwBF,OAAO,CAACE,WAApJ,EAAiK;AAC/J;AACD;;AAED,QAAIE,aAAa,GAAGJ,OAAO,CAACK,SAAR,EAApB;AACA,QAAIC,aAAa,GAAGL,OAAO,CAACI,SAAR,EAApB;AAEAZ,IAAAA,MAAM,CAACC,IAAP,CAAYU,aAAZ,EAA2BT,OAA3B,CAAmC,UAAUY,SAAV,EAAqB;AACtD,UAAI,CAACD,aAAa,CAACC,SAAD,CAAlB,EAA+B;AAC7B;AACD;;AAEDH,MAAAA,aAAa,CAACG,SAAD,CAAb,CAAyBC,IAAzB,CAA8Bb,OAA9B,CAAsC,UAAUc,SAAV,EAAqB;AACzD,YAAIC,OAAO,GAAGJ,aAAa,CAACC,SAAD,CAAb,CAAyBC,IAAvC;AACA,YAAIG,SAAS,GAAGD,OAAO,CAACE,IAAR,CAAa,UAAUC,GAAV,EAAe;AAC1C,iBAAOA,GAAG,CAACC,IAAJ,KAAaL,SAAS,CAACK,IAA9B;AACD,SAFe,CAAhB,CAFyD,CAMzD;;AACA,YAAI,CAACH,SAAL,EAAgB;AACdnC,UAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,YAAAA,IAAI,EAAErD,kBAAkB,CAACO,WADN;AAEnB+C,YAAAA,WAAW,EAAEC,OAAO,CAACc,IAAR,GAAe,GAAf,GAAqBP,SAArB,GAAiC,OAAjC,IAA4CE,SAAS,CAACK,IAAV,GAAiB,cAA7D;AAFM,WAArB;AAID,SALD,MAKO;AACL,cAAIC,MAAM,GAAGC,yCAAyC,CAACP,SAAS,CAACX,IAAX,EAAiBa,SAAS,CAACb,IAA3B,CAAtD;;AACA,cAAI,CAACiB,MAAL,EAAa;AACXvC,YAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,cAAAA,IAAI,EAAErD,kBAAkB,CAACQ,gBADN;AAEnB8C,cAAAA,WAAW,EAAEC,OAAO,CAACc,IAAR,GAAe,GAAf,GAAqBP,SAArB,GAAiC,OAAjC,IAA4CE,SAAS,CAACK,IAAV,GAAiB,yBAA7D,KAA2FL,SAAS,CAACX,IAAV,CAAemB,QAAf,KAA4B,MAA5B,GAAqCN,SAAS,CAACb,IAAV,CAAemB,QAAf,EAAhI;AAFM,aAArB;AAID,WALD,MAKO,IAAIR,SAAS,CAACS,YAAV,KAA2BC,SAA3B,IAAwCV,SAAS,CAACS,YAAV,KAA2BP,SAAS,CAACO,YAAjF,EAA+F;AACpGhC,YAAAA,gBAAgB,CAACW,IAAjB,CAAsB;AACpBC,cAAAA,IAAI,EAAErC,mBAAmB,CAACC,wBADN;AAEpBqC,cAAAA,WAAW,EAAEC,OAAO,CAACc,IAAR,GAAe,GAAf,GAAqBP,SAArB,GAAiC,OAAjC,IAA4CE,SAAS,CAACK,IAAV,GAAiB,2BAA7D;AAFO,aAAtB;AAID;AACF;AACF,OA1BD,EALsD,CAgCtD;;AACAR,MAAAA,aAAa,CAACC,SAAD,CAAb,CAAyBC,IAAzB,CAA8Bb,OAA9B,CAAsC,UAAUgB,SAAV,EAAqB;AACzD,YAAIS,OAAO,GAAGhB,aAAa,CAACG,SAAD,CAAb,CAAyBC,IAAvC;AACA,YAAIC,SAAS,GAAGW,OAAO,CAACR,IAAR,CAAa,UAAUC,GAAV,EAAe;AAC1C,iBAAOA,GAAG,CAACC,IAAJ,KAAaH,SAAS,CAACG,IAA9B;AACD,SAFe,CAAhB;;AAGA,YAAI,CAACL,SAAL,EAAgB;AACd,cAAItE,aAAa,CAACwE,SAAS,CAACb,IAAX,CAAjB,EAAmC;AACjCtB,YAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,cAAAA,IAAI,EAAErD,kBAAkB,CAACS,kBADN;AAEnB6C,cAAAA,WAAW,EAAE,oBAAoBY,SAAS,CAACG,IAA9B,GAAqC,MAArC,IAA+Cb,OAAO,CAACa,IAAR,GAAe,GAAf,GAAqBP,SAArB,GAAiC,YAAhF;AAFM,aAArB;AAID,WALD,MAKO;AACLrB,YAAAA,gBAAgB,CAACW,IAAjB,CAAsB;AACpBC,cAAAA,IAAI,EAAErC,mBAAmB,CAACM,kBADN;AAEpBgC,cAAAA,WAAW,EAAE,oBAAoBY,SAAS,CAACG,IAA9B,GAAqC,MAArC,IAA+Cb,OAAO,CAACa,IAAR,GAAe,GAAf,GAAqBP,SAArB,GAAiC,YAAhF;AAFO,aAAtB;AAID;AACF;AACF,OAlBD;AAmBD,KApDD;AAqDD,GA/DD;AAiEA,SAAO;AACL/B,IAAAA,eAAe,EAAEA,eADZ;AAELU,IAAAA,gBAAgB,EAAEA;AAFb,GAAP;AAID;;AAED,SAASiB,YAAT,CAAsBL,IAAtB,EAA4B;AAC1B,MAAIjE,YAAY,CAACiE,IAAD,CAAhB,EAAwB;AACtB,WAAO,eAAP;AACD;;AACD,MAAIhE,YAAY,CAACgE,IAAD,CAAhB,EAAwB;AACtB,WAAO,gBAAP;AACD;;AACD,MAAI/D,eAAe,CAAC+D,IAAD,CAAnB,EAA2B;AACzB,WAAO,mBAAP;AACD;;AACD,MAAI9D,WAAW,CAAC8D,IAAD,CAAf,EAAuB;AACrB,WAAO,cAAP;AACD;;AACD,MAAI7D,UAAU,CAAC6D,IAAD,CAAd,EAAsB;AACpB,WAAO,cAAP;AACD;;AACD,MAAI5D,iBAAiB,CAAC4D,IAAD,CAArB,EAA6B;AAC3B,WAAO,eAAP;AACD;;AACD,QAAM,IAAIuB,SAAJ,CAAc,kBAAkBvB,IAAI,CAACI,WAAL,CAAiBY,IAAjD,CAAN;AACD;;AAED,OAAO,SAASxC,iDAAT,CAA2DL,SAA3D,EAAsEC,SAAtE,EAAiF;AACtF,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAIf,eAAe,GAAG,EAAtB;AACAiB,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,EAAE9D,YAAY,CAACkE,OAAD,CAAZ,IAAyBjE,eAAe,CAACiE,OAAD,CAA1C,KAAwD,EAAElE,YAAY,CAACmE,OAAD,CAAZ,IAAyBlE,eAAe,CAACkE,OAAD,CAA1C,CAAxD,IAAgHA,OAAO,CAACC,WAAR,KAAwBF,OAAO,CAACE,WAApJ,EAAiK;AAC/J;AACD;;AAED,QAAIoB,gBAAgB,GAAGtB,OAAO,CAACK,SAAR,EAAvB;AACA,QAAIkB,gBAAgB,GAAGtB,OAAO,CAACI,SAAR,EAAvB;AACAZ,IAAAA,MAAM,CAACC,IAAP,CAAY4B,gBAAZ,EAA8B3B,OAA9B,CAAsC,UAAUY,SAAV,EAAqB;AACzD;AACA,UAAI,EAAEA,SAAS,IAAIgB,gBAAf,CAAJ,EAAsC;AACpC/C,QAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,UAAAA,IAAI,EAAErD,kBAAkB,CAACE,aADN;AAEnBoD,UAAAA,WAAW,EAAEH,QAAQ,GAAG,GAAX,GAAiBW,SAAjB,GAA6B;AAFvB,SAArB;AAID,OALD,MAKO;AACL,YAAIiB,YAAY,GAAGF,gBAAgB,CAACf,SAAD,CAAhB,CAA4BT,IAA/C;AACA,YAAI2B,YAAY,GAAGF,gBAAgB,CAAChB,SAAD,CAAhB,CAA4BT,IAA/C;AACA,YAAIiB,MAAM,GAAGW,qCAAqC,CAACF,YAAD,EAAeC,YAAf,CAAlD;;AACA,YAAI,CAACV,MAAL,EAAa;AACX,cAAIY,kBAAkB,GAAGtF,WAAW,CAACmF,YAAD,CAAX,GAA4BA,YAAY,CAACV,IAAzC,GAAgDU,YAAY,CAACP,QAAb,EAAzE;AACA,cAAIW,kBAAkB,GAAGvF,WAAW,CAACoF,YAAD,CAAX,GAA4BA,YAAY,CAACX,IAAzC,GAAgDW,YAAY,CAACR,QAAb,EAAzE;AACAzC,UAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,YAAAA,IAAI,EAAErD,kBAAkB,CAACC,kBADN;AAEnBqD,YAAAA,WAAW,EAAEH,QAAQ,GAAG,GAAX,GAAiBW,SAAjB,GAA6B,qBAA7B,IAAsDoB,kBAAkB,GAAG,MAArB,GAA8BC,kBAA9B,GAAmD,GAAzG;AAFM,WAArB;AAID;AACF;AACF,KApBD;AAqBD,GA9BD;AA+BA,SAAOpD,eAAP;AACD;AAED,OAAO,SAASD,2CAAT,CAAqDN,SAArD,EAAgEC,SAAhE,EAA2E;AAChF,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAIf,eAAe,GAAG,EAAtB;AACA,MAAIU,gBAAgB,GAAG,EAAvB;AACAO,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,CAAC1D,iBAAiB,CAAC8D,OAAD,CAAlB,IAA+B,CAAC9D,iBAAiB,CAAC+D,OAAD,CAArD,EAAgE;AAC9D;AACD;;AAED,QAAIqB,gBAAgB,GAAGtB,OAAO,CAACK,SAAR,EAAvB;AACA,QAAIkB,gBAAgB,GAAGtB,OAAO,CAACI,SAAR,EAAvB;AACAZ,IAAAA,MAAM,CAACC,IAAP,CAAY4B,gBAAZ,EAA8B3B,OAA9B,CAAsC,UAAUY,SAAV,EAAqB;AACzD;AACA,UAAI,EAAEA,SAAS,IAAIgB,gBAAf,CAAJ,EAAsC;AACpC/C,QAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,UAAAA,IAAI,EAAErD,kBAAkB,CAACE,aADN;AAEnBoD,UAAAA,WAAW,EAAEH,QAAQ,GAAG,GAAX,GAAiBW,SAAjB,GAA6B;AAFvB,SAArB;AAID,OALD,MAKO;AACL,YAAIiB,YAAY,GAAGF,gBAAgB,CAACf,SAAD,CAAhB,CAA4BT,IAA/C;AACA,YAAI2B,YAAY,GAAGF,gBAAgB,CAAChB,SAAD,CAAhB,CAA4BT,IAA/C;AAEA,YAAIiB,MAAM,GAAGC,yCAAyC,CAACQ,YAAD,EAAeC,YAAf,CAAtD;;AACA,YAAI,CAACV,MAAL,EAAa;AACX,cAAIY,kBAAkB,GAAGtF,WAAW,CAACmF,YAAD,CAAX,GAA4BA,YAAY,CAACV,IAAzC,GAAgDU,YAAY,CAACP,QAAb,EAAzE;AACA,cAAIW,kBAAkB,GAAGvF,WAAW,CAACoF,YAAD,CAAX,GAA4BA,YAAY,CAACX,IAAzC,GAAgDW,YAAY,CAACR,QAAb,EAAzE;AACAzC,UAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,YAAAA,IAAI,EAAErD,kBAAkB,CAACC,kBADN;AAEnBqD,YAAAA,WAAW,EAAEH,QAAQ,GAAG,GAAX,GAAiBW,SAAjB,GAA6B,qBAA7B,IAAsDoB,kBAAkB,GAAG,MAArB,GAA8BC,kBAA9B,GAAmD,GAAzG;AAFM,WAArB;AAID;AACF;AACF,KArBD,EATkD,CA+BlD;;AACAnC,IAAAA,MAAM,CAACC,IAAP,CAAY6B,gBAAZ,EAA8B5B,OAA9B,CAAsC,UAAUY,SAAV,EAAqB;AACzD,UAAI,EAAEA,SAAS,IAAIe,gBAAf,CAAJ,EAAsC;AACpC,YAAInF,aAAa,CAACoF,gBAAgB,CAAChB,SAAD,CAAhB,CAA4BT,IAA7B,CAAjB,EAAqD;AACnDtB,UAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,YAAAA,IAAI,EAAErD,kBAAkB,CAACU,0BADN;AAEnB4C,YAAAA,WAAW,EAAE,sBAAsBQ,SAAtB,GAAkC,MAAlC,IAA4C,gBAAgBN,OAAO,CAACa,IAAxB,GAA+B,aAA3E;AAFM,WAArB;AAID,SALD,MAKO;AACL5B,UAAAA,gBAAgB,CAACW,IAAjB,CAAsB;AACpBC,YAAAA,IAAI,EAAErC,mBAAmB,CAACK,0BADN;AAEpBiC,YAAAA,WAAW,EAAE,sBAAsBQ,SAAtB,GAAkC,MAAlC,IAA4C,gBAAgBN,OAAO,CAACa,IAAxB,GAA+B,aAA3E;AAFO,WAAtB;AAID;AACF;AACF,KAdD;AAeD,GA/CD;AAgDA,SAAO;AACLtC,IAAAA,eAAe,EAAEA,eADZ;AAELU,IAAAA,gBAAgB,EAAEA;AAFb,GAAP;AAID;;AAED,SAASwC,qCAAT,CAA+C1B,OAA/C,EAAwDC,OAAxD,EAAiE;AAC/D,MAAI5D,WAAW,CAAC2D,OAAD,CAAf,EAA0B;AACxB,WACE;AACA3D,MAAAA,WAAW,CAAC4D,OAAD,CAAX,IAAwBD,OAAO,CAACc,IAAR,KAAiBb,OAAO,CAACa,IAAjD,IACA;AACA3E,MAAAA,aAAa,CAAC8D,OAAD,CAAb,IAA0ByB,qCAAqC,CAAC1B,OAAD,EAAUC,OAAO,CAAC4B,MAAlB;AAJjE;AAMD,GAPD,MAOO,IAAIzF,UAAU,CAAC4D,OAAD,CAAd,EAAyB;AAC9B,WACE;AACA5D,MAAAA,UAAU,CAAC6D,OAAD,CAAV,IAAuByB,qCAAqC,CAAC1B,OAAO,CAAC6B,MAAT,EAAiB5B,OAAO,CAAC4B,MAAzB,CAA5D,IACA;AACA1F,MAAAA,aAAa,CAAC8D,OAAD,CAAb,IAA0ByB,qCAAqC,CAAC1B,OAAD,EAAUC,OAAO,CAAC4B,MAAlB;AAJjE;AAMD,GAPM,MAOA,IAAI1F,aAAa,CAAC6D,OAAD,CAAjB,EAA4B;AACjC;AACA,WAAO7D,aAAa,CAAC8D,OAAD,CAAb,IAA0ByB,qCAAqC,CAAC1B,OAAO,CAAC6B,MAAT,EAAiB5B,OAAO,CAAC4B,MAAzB,CAAtE;AACD;;AACD,SAAO,KAAP;AACD;;AAED,SAASb,yCAAT,CAAmDhB,OAAnD,EAA4DC,OAA5D,EAAqE;AACnE,MAAI5D,WAAW,CAAC2D,OAAD,CAAf,EAA0B;AACxB;AACA,WAAO3D,WAAW,CAAC4D,OAAD,CAAX,IAAwBD,OAAO,CAACc,IAAR,KAAiBb,OAAO,CAACa,IAAxD;AACD,GAHD,MAGO,IAAI1E,UAAU,CAAC4D,OAAD,CAAd,EAAyB;AAC9B;AACA,WAAO5D,UAAU,CAAC6D,OAAD,CAAV,IAAuBe,yCAAyC,CAAChB,OAAO,CAAC6B,MAAT,EAAiB5B,OAAO,CAAC4B,MAAzB,CAAvE;AACD,GAHM,MAGA,IAAI1F,aAAa,CAAC6D,OAAD,CAAjB,EAA4B;AACjC,WACE;AACA;AACA7D,MAAAA,aAAa,CAAC8D,OAAD,CAAb,IAA0Be,yCAAyC,CAAChB,OAAO,CAAC6B,MAAT,EAAiB5B,OAAO,CAAC4B,MAAzB,CAAnE,IACA;AACA,OAAC1F,aAAa,CAAC8D,OAAD,CAAd,IAA2Be,yCAAyC,CAAChB,OAAO,CAAC6B,MAAT,EAAiB5B,OAAjB;AALtE;AAOD;;AACD,SAAO,KAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,OAAO,SAASxB,0BAAT,CAAoCR,SAApC,EAA+CC,SAA/C,EAA0D;AAC/D,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAIuC,qBAAqB,GAAG,EAA5B;AACArC,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,CAAC5D,WAAW,CAACgE,OAAD,CAAZ,IAAyB,CAAChE,WAAW,CAACiE,OAAD,CAAzC,EAAoD;AAClD;AACD;;AACD,QAAI8B,mBAAmB,GAAGtC,MAAM,CAACuC,MAAP,CAAc,IAAd,CAA1B;AACA/B,IAAAA,OAAO,CAACgC,QAAR,GAAmBtC,OAAnB,CAA2B,UAAUG,IAAV,EAAgB;AACzCiC,MAAAA,mBAAmB,CAACjC,IAAI,CAACgB,IAAN,CAAnB,GAAiC,IAAjC;AACD,KAFD;AAGAd,IAAAA,OAAO,CAACiC,QAAR,GAAmBtC,OAAnB,CAA2B,UAAUG,IAAV,EAAgB;AACzC,UAAI,CAACiC,mBAAmB,CAACjC,IAAI,CAACgB,IAAN,CAAxB,EAAqC;AACnCgB,QAAAA,qBAAqB,CAACjC,IAAtB,CAA2B;AACzBC,UAAAA,IAAI,EAAErD,kBAAkB,CAACK,uBADA;AAEzBiD,UAAAA,WAAW,EAAED,IAAI,CAACgB,IAAL,GAAY,+BAAZ,GAA8ClB,QAA9C,GAAyD;AAF7C,SAA3B;AAID;AACF,KAPD;AAQD,GAlBD;AAmBA,SAAOkC,qBAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASzC,sBAAT,CAAgCpB,SAAhC,EAA2CC,SAA3C,EAAsD;AAC3D,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAI2C,iBAAiB,GAAG,EAAxB;AACAzC,EAAAA,MAAM,CAACC,IAAP,CAAYF,UAAZ,EAAwBG,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,CAAC5D,WAAW,CAACgE,OAAD,CAAZ,IAAyB,CAAChE,WAAW,CAACiE,OAAD,CAAzC,EAAoD;AAClD;AACD;;AACD,QAAIkC,mBAAmB,GAAG1C,MAAM,CAACuC,MAAP,CAAc,IAAd,CAA1B;AACAhC,IAAAA,OAAO,CAACiC,QAAR,GAAmBtC,OAAnB,CAA2B,UAAUG,IAAV,EAAgB;AACzCqC,MAAAA,mBAAmB,CAACrC,IAAI,CAACgB,IAAN,CAAnB,GAAiC,IAAjC;AACD,KAFD;AAGAb,IAAAA,OAAO,CAACgC,QAAR,GAAmBtC,OAAnB,CAA2B,UAAUG,IAAV,EAAgB;AACzC,UAAI,CAACqC,mBAAmB,CAACrC,IAAI,CAACgB,IAAN,CAAxB,EAAqC;AACnCoB,QAAAA,iBAAiB,CAACrC,IAAlB,CAAuB;AACrBC,UAAAA,IAAI,EAAErC,mBAAmB,CAACI,mBADL;AAErBkC,UAAAA,WAAW,EAAED,IAAI,CAACgB,IAAL,GAAY,2BAAZ,GAA0ClB,QAA1C,GAAqD;AAF7C,SAAvB;AAID;AACF,KAPD;AAQD,GAlBD;AAmBA,SAAOsC,iBAAP;AACD;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASxD,0BAAT,CAAoCT,SAApC,EAA+CC,SAA/C,EAA0D;AAC/D,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAI6C,sBAAsB,GAAG,EAA7B;AACA3C,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,CAAC3D,UAAU,CAAC+D,OAAD,CAAX,IAAwB,CAAC/D,UAAU,CAACgE,OAAD,CAAvC,EAAkD;AAChD;AACD;;AACD,QAAIoC,eAAe,GAAG5C,MAAM,CAACuC,MAAP,CAAc,IAAd,CAAtB;AACA/B,IAAAA,OAAO,CAACqC,SAAR,GAAoB3C,OAApB,CAA4B,UAAU4C,KAAV,EAAiB;AAC3CF,MAAAA,eAAe,CAACE,KAAK,CAACzB,IAAP,CAAf,GAA8B,IAA9B;AACD,KAFD;AAGAd,IAAAA,OAAO,CAACsC,SAAR,GAAoB3C,OAApB,CAA4B,UAAU4C,KAAV,EAAiB;AAC3C,UAAI,CAACF,eAAe,CAACE,KAAK,CAACzB,IAAP,CAApB,EAAkC;AAChCsB,QAAAA,sBAAsB,CAACvC,IAAvB,CAA4B;AAC1BC,UAAAA,IAAI,EAAErD,kBAAkB,CAACM,uBADC;AAE1BgD,UAAAA,WAAW,EAAEwC,KAAK,CAACzB,IAAN,GAAa,8BAAb,GAA8ClB,QAA9C,GAAyD;AAF5C,SAA5B;AAID;AACF,KAPD;AAQD,GAlBD;AAmBA,SAAOwC,sBAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASjD,sBAAT,CAAgClB,SAAhC,EAA2CC,SAA3C,EAAsD;AAC3D,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AAEA,MAAIiD,kBAAkB,GAAG,EAAzB;AACA/C,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,CAAC3D,UAAU,CAAC+D,OAAD,CAAX,IAAwB,CAAC/D,UAAU,CAACgE,OAAD,CAAvC,EAAkD;AAChD;AACD;;AAED,QAAIwC,eAAe,GAAGhD,MAAM,CAACuC,MAAP,CAAc,IAAd,CAAtB;AACAhC,IAAAA,OAAO,CAACsC,SAAR,GAAoB3C,OAApB,CAA4B,UAAU4C,KAAV,EAAiB;AAC3CE,MAAAA,eAAe,CAACF,KAAK,CAACzB,IAAP,CAAf,GAA8B,IAA9B;AACD,KAFD;AAGAb,IAAAA,OAAO,CAACqC,SAAR,GAAoB3C,OAApB,CAA4B,UAAU4C,KAAV,EAAiB;AAC3C,UAAI,CAACE,eAAe,CAACF,KAAK,CAACzB,IAAP,CAApB,EAAkC;AAChC0B,QAAAA,kBAAkB,CAAC3C,IAAnB,CAAwB;AACtBC,UAAAA,IAAI,EAAErC,mBAAmB,CAACE,mBADJ;AAEtBoC,UAAAA,WAAW,EAAEwC,KAAK,CAACzB,IAAN,GAAa,0BAAb,GAA0ClB,QAA1C,GAAqD;AAF5C,SAAxB;AAID;AACF,KAPD;AAQD,GAnBD;AAoBA,SAAO4C,kBAAP;AACD;AAED,OAAO,SAAS5D,oCAAT,CAA8CX,SAA9C,EAAyDC,SAAzD,EAAoE;AACzE,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AACA,MAAIf,eAAe,GAAG,EAAtB;AAEAiB,EAAAA,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwBK,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,CAAC9D,YAAY,CAACkE,OAAD,CAAb,IAA0B,CAAClE,YAAY,CAACmE,OAAD,CAA3C,EAAsD;AACpD;AACD;;AAED,QAAIyC,aAAa,GAAG1C,OAAO,CAAC2C,aAAR,EAApB;AACA,QAAIC,aAAa,GAAG3C,OAAO,CAAC0C,aAAR,EAApB;AACAD,IAAAA,aAAa,CAAC/C,OAAd,CAAsB,UAAUkD,YAAV,EAAwB;AAC5C,UAAI,CAACD,aAAa,CAACE,IAAd,CAAmB,UAAUC,GAAV,EAAe;AACrC,eAAOA,GAAG,CAACjC,IAAJ,KAAa+B,YAAY,CAAC/B,IAAjC;AACD,OAFI,CAAL,EAEI;AACFtC,QAAAA,eAAe,CAACqB,IAAhB,CAAqB;AACnBC,UAAAA,IAAI,EAAErD,kBAAkB,CAACW,6BADN;AAEnB2C,UAAAA,WAAW,EAAEH,QAAQ,GAAG,kCAAX,IAAiDiD,YAAY,CAAC/B,IAAb,GAAoB,GAArE;AAFM,SAArB;AAID;AACF,KATD;AAUD,GAnBD;AAoBA,SAAOtC,eAAP;AACD;AAED,OAAO,SAASY,gCAAT,CAA0CnB,SAA1C,EAAqDC,SAArD,EAAgE;AACrE,MAAIoB,UAAU,GAAGrB,SAAS,CAACsB,UAAV,EAAjB;AACA,MAAIC,UAAU,GAAGtB,SAAS,CAACqB,UAAV,EAAjB;AACA,MAAIyD,4BAA4B,GAAG,EAAnC;AAEAvD,EAAAA,MAAM,CAACC,IAAP,CAAYF,UAAZ,EAAwBG,OAAxB,CAAgC,UAAUC,QAAV,EAAoB;AAClD,QAAII,OAAO,GAAGV,UAAU,CAACM,QAAD,CAAxB;AACA,QAAIK,OAAO,GAAGT,UAAU,CAACI,QAAD,CAAxB;;AACA,QAAI,CAAC9D,YAAY,CAACkE,OAAD,CAAb,IAA0B,CAAClE,YAAY,CAACmE,OAAD,CAA3C,EAAsD;AACpD;AACD;;AAED,QAAIyC,aAAa,GAAG1C,OAAO,CAAC2C,aAAR,EAApB;AACA,QAAIC,aAAa,GAAG3C,OAAO,CAAC0C,aAAR,EAApB;AACAC,IAAAA,aAAa,CAACjD,OAAd,CAAsB,UAAUsD,YAAV,EAAwB;AAC5C,UAAI,CAACP,aAAa,CAACI,IAAd,CAAmB,UAAUC,GAAV,EAAe;AACrC,eAAOA,GAAG,CAACjC,IAAJ,KAAamC,YAAY,CAACnC,IAAjC;AACD,OAFI,CAAL,EAEI;AACFkC,QAAAA,4BAA4B,CAACnD,IAA7B,CAAkC;AAChCC,UAAAA,IAAI,EAAErC,mBAAmB,CAACG,yBADM;AAEhCmC,UAAAA,WAAW,EAAEkD,YAAY,CAACnC,IAAb,GAAoB,mCAApB,IAA2D,QAAQlB,QAAR,GAAmB,GAA9E;AAFmB,SAAlC;AAID;AACF,KATD;AAUD,GAnBD;AAoBA,SAAOoD,4BAAP;AACD;AAED,OAAO,SAASnE,qBAAT,CAA+BZ,SAA/B,EAA0CC,SAA1C,EAAqD;AAC1D,MAAIgF,iBAAiB,GAAG,EAAxB;AAEA,MAAIC,qBAAqB,GAAGC,wBAAwB,CAAClF,SAAD,CAApD;AACAD,EAAAA,SAAS,CAACoF,aAAV,GAA0B1D,OAA1B,CAAkC,UAAU2D,SAAV,EAAqB;AACrD,QAAI,CAACH,qBAAqB,CAACG,SAAS,CAACxC,IAAX,CAA1B,EAA4C;AAC1CoC,MAAAA,iBAAiB,CAACrD,IAAlB,CAAuB;AACrBC,QAAAA,IAAI,EAAErD,kBAAkB,CAACY,iBADJ;AAErB0C,QAAAA,WAAW,EAAEuD,SAAS,CAACxC,IAAV,GAAiB;AAFT,OAAvB;AAID;AACF,GAPD;AASA,SAAOoC,iBAAP;AACD;;AAED,SAASK,2BAAT,CAAqCC,YAArC,EAAmDC,YAAnD,EAAiE;AAC/D,MAAIC,WAAW,GAAG,EAAlB;AACA,MAAIC,SAAS,GAAGC,0BAA0B,CAACH,YAAD,CAA1C;AAEAD,EAAAA,YAAY,CAAChD,IAAb,CAAkBb,OAAlB,CAA0B,UAAUkB,GAAV,EAAe;AACvC,QAAI,CAAC8C,SAAS,CAAC9C,GAAG,CAACC,IAAL,CAAd,EAA0B;AACxB4C,MAAAA,WAAW,CAAC7D,IAAZ,CAAiBgB,GAAjB;AACD;AACF,GAJD;AAMA,SAAO6C,WAAP;AACD;;AAED,OAAO,SAAS5E,wBAAT,CAAkCb,SAAlC,EAA6CC,SAA7C,EAAwD;AAC7D,MAAI2F,oBAAoB,GAAG,EAA3B;AACA,MAAIC,qBAAqB,GAAGV,wBAAwB,CAACnF,SAAD,CAApD;AAEAC,EAAAA,SAAS,CAACmF,aAAV,GAA0B1D,OAA1B,CAAkC,UAAU8D,YAAV,EAAwB;AACxD,QAAID,YAAY,GAAGM,qBAAqB,CAACL,YAAY,CAAC3C,IAAd,CAAxC;;AACA,QAAI,CAAC0C,YAAL,EAAmB;AACjB;AACD;;AAEDD,IAAAA,2BAA2B,CAACC,YAAD,EAAeC,YAAf,CAA3B,CAAwD9D,OAAxD,CAAgE,UAAUkB,GAAV,EAAe;AAC7EgD,MAAAA,oBAAoB,CAAChE,IAArB,CAA0B;AACxBC,QAAAA,IAAI,EAAErD,kBAAkB,CAACa,qBADD;AAExByC,QAAAA,WAAW,EAAEc,GAAG,CAACC,IAAJ,GAAW,oBAAX,GAAkC2C,YAAY,CAAC3C;AAFpC,OAA1B;AAID,KALD;AAMD,GAZD;AAcA,SAAO+C,oBAAP;AACD;;AAED,SAASE,yBAAT,CAAmCP,YAAnC,EAAiDC,YAAjD,EAA+D;AAC7D,MAAIO,SAAS,GAAG,EAAhB;AACA,MAAIC,SAAS,GAAGL,0BAA0B,CAACJ,YAAD,CAA1C;AAEAC,EAAAA,YAAY,CAACjD,IAAb,CAAkBb,OAAlB,CAA0B,UAAUkB,GAAV,EAAe;AACvC,QAAI,CAACoD,SAAS,CAACpD,GAAG,CAACC,IAAL,CAAd,EAA0B;AACxBkD,MAAAA,SAAS,CAACnE,IAAV,CAAegB,GAAf;AACD;AACF,GAJD;AAMA,SAAOmD,SAAP;AACD;;AAED,OAAO,SAASjF,6BAAT,CAAuCd,SAAvC,EAAkDC,SAAlD,EAA6D;AAClE,MAAIgG,oBAAoB,GAAG,EAA3B;AACA,MAAIJ,qBAAqB,GAAGV,wBAAwB,CAACnF,SAAD,CAApD;AAEAC,EAAAA,SAAS,CAACmF,aAAV,GAA0B1D,OAA1B,CAAkC,UAAU8D,YAAV,EAAwB;AACxD,QAAID,YAAY,GAAGM,qBAAqB,CAACL,YAAY,CAAC3C,IAAd,CAAxC;;AACA,QAAI,CAAC0C,YAAL,EAAmB;AACjB;AACD;;AAEDO,IAAAA,yBAAyB,CAACP,YAAD,EAAeC,YAAf,CAAzB,CAAsD9D,OAAtD,CAA8D,UAAUkB,GAAV,EAAe;AAC3E,UAAI,CAAC1E,aAAa,CAAC0E,GAAG,CAACf,IAAL,CAAlB,EAA8B;AAC5B;AACD;;AAEDoE,MAAAA,oBAAoB,CAACrE,IAArB,CAA0B;AACxBC,QAAAA,IAAI,EAAErD,kBAAkB,CAACe,4BADD;AAExBuC,QAAAA,WAAW,EAAE,oBAAoBc,GAAG,CAACC,IAAxB,GAA+B,gBAA/B,IAAmD2C,YAAY,CAAC3C,IAAb,GAAoB,YAAvE;AAFW,OAA1B;AAID,KATD;AAUD,GAhBD;AAkBA,SAAOoD,oBAAP;AACD;AAED,OAAO,SAASC,gCAAT,CAA0CX,YAA1C,EAAwDC,YAAxD,EAAsE;AAC3E,MAAIW,gBAAgB,GAAG,EAAvB;AACA,MAAIC,cAAc,GAAG,IAAIC,GAAJ,CAAQb,YAAY,CAACc,SAArB,CAArB;AAEAf,EAAAA,YAAY,CAACe,SAAb,CAAuB5E,OAAvB,CAA+B,UAAU6E,WAAV,EAAuB;AACpD,QAAI,CAACH,cAAc,CAACI,GAAf,CAAmBD,WAAnB,CAAL,EAAsC;AACpCJ,MAAAA,gBAAgB,CAACvE,IAAjB,CAAsB2E,WAAtB;AACD;AACF,GAJD;AAMA,SAAOJ,gBAAP;AACD;AAED,OAAO,SAASpF,6BAAT,CAAuCf,SAAvC,EAAkDC,SAAlD,EAA6D;AAClE,MAAIkG,gBAAgB,GAAG,EAAvB;AACA,MAAIN,qBAAqB,GAAGV,wBAAwB,CAACnF,SAAD,CAApD;AAEAC,EAAAA,SAAS,CAACmF,aAAV,GAA0B1D,OAA1B,CAAkC,UAAU8D,YAAV,EAAwB;AACxD,QAAID,YAAY,GAAGM,qBAAqB,CAACL,YAAY,CAAC3C,IAAd,CAAxC;;AACA,QAAI,CAAC0C,YAAL,EAAmB;AACjB;AACD;;AAEDW,IAAAA,gCAAgC,CAACX,YAAD,EAAeC,YAAf,CAAhC,CAA6D9D,OAA7D,CAAqE,UAAU+E,QAAV,EAAoB;AACvFN,MAAAA,gBAAgB,CAACvE,IAAjB,CAAsB;AACpBC,QAAAA,IAAI,EAAErD,kBAAkB,CAACc,0BADL;AAEpBwC,QAAAA,WAAW,EAAE2E,QAAQ,GAAG,oBAAX,GAAkCjB,YAAY,CAAC3C;AAFxC,OAAtB;AAID,KALD;AAMD,GAZD;AAcA,SAAOsD,gBAAP;AACD;;AAED,SAAShB,wBAAT,CAAkCuB,MAAlC,EAA0C;AACxC,SAAOnI,MAAM,CAACmI,MAAM,CAACtB,aAAP,EAAD,EAAyB,UAAUuB,GAAV,EAAe;AACnD,WAAOA,GAAG,CAAC9D,IAAX;AACD,GAFY,CAAb;AAGD;;AAED,SAAS8C,0BAAT,CAAoCN,SAApC,EAA+C;AAC7C,SAAO9G,MAAM,CAAC8G,SAAS,CAAC9C,IAAX,EAAiB,UAAUK,GAAV,EAAe;AAC3C,WAAOA,GAAG,CAACC,IAAX;AACD,GAFY,CAAb;AAGD","sourcesContent":["/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType } from '../type/definition';\n\nimport { GraphQLDirective } from '../type/directives';\nimport { GraphQLSchema } from '../type/schema';\nimport keyMap from '../jsutils/keyMap';\n\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  NON_NULL_ARG_ADDED: 'NON_NULL_ARG_ADDED',\n  NON_NULL_INPUT_FIELD_ADDED: 'NON_NULL_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  NON_NULL_DIRECTIVE_ARG_ADDED: 'NON_NULL_DIRECTIVE_ARG_ADDED'\n};\n\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  NULLABLE_INPUT_FIELD_ADDED: 'NULLABLE_INPUT_FIELD_ADDED',\n  NULLABLE_ARG_ADDED: 'NULLABLE_ARG_ADDED'\n};\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return [].concat(findRemovedTypes(oldSchema, newSchema), findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return [].concat(findArgChanges(oldSchema, newSchema).dangerousChanges, findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: typeName + ' was removed.'\n      });\n    }\n  });\n  return breakingChanges;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      return;\n    }\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: typeName + ' changed from ' + (typeKindName(oldType) + ' to ' + typeKindName(newType) + '.')\n      });\n    }\n  });\n  return breakingChanges;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    Object.keys(oldTypeFields).forEach(function (fieldName) {\n      if (!newTypeFields[fieldName]) {\n        return;\n      }\n\n      oldTypeFields[fieldName].args.forEach(function (oldArgDef) {\n        var newArgs = newTypeFields[fieldName].args;\n        var newArgDef = newArgs.find(function (arg) {\n          return arg.name === oldArgDef.name;\n        });\n\n        // Arg not present\n        if (!newArgDef) {\n          breakingChanges.push({\n            type: BreakingChangeType.ARG_REMOVED,\n            description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' was removed')\n          });\n        } else {\n          var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n          if (!isSafe) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_CHANGED_KIND,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed type from ') + (oldArgDef.type.toString() + ' to ' + newArgDef.type.toString())\n            });\n          } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n            dangerousChanges.push({\n              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed defaultValue')\n            });\n          }\n        }\n      });\n      // Check if a non-null arg was added to the field\n      newTypeFields[fieldName].args.forEach(function (newArgDef) {\n        var oldArgs = oldTypeFields[fieldName].args;\n        var oldArgDef = oldArgs.find(function (arg) {\n          return arg.name === newArgDef.name;\n        });\n        if (!oldArgDef) {\n          if (isNonNullType(newArgDef.type)) {\n            breakingChanges.push({\n              type: BreakingChangeType.NON_NULL_ARG_ADDED,\n              description: 'A non-null arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          } else {\n            dangerousChanges.push({\n              type: DangerousChangeType.NULLABLE_ARG_ADDED,\n              description: 'A nullable arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          }\n        }\n      });\n    });\n  });\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    });\n  });\n  return breakingChanges;\n}\n\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    });\n    // Check if a field was added to the input object type\n    Object.keys(newTypeFieldsDef).forEach(function (fieldName) {\n      if (!(fieldName in oldTypeFieldsDef)) {\n        if (isNonNullType(newTypeFieldsDef[fieldName].type)) {\n          breakingChanges.push({\n            type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,\n            description: 'A non-null field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.NULLABLE_INPUT_FIELD_ADDED,\n            description: 'A nullable field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        }\n      }\n    });\n  });\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (\n      // if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name ||\n      // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) ||\n      // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) ||\n      // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n  return false;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var typesRemovedFromUnion = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n    var typeNamesInNewUnion = Object.create(null);\n    newType.getTypes().forEach(function (type) {\n      typeNamesInNewUnion[type.name] = true;\n    });\n    oldType.getTypes().forEach(function (type) {\n      if (!typeNamesInNewUnion[type.name]) {\n        typesRemovedFromUnion.push({\n          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n          description: type.name + ' was removed from union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesRemovedFromUnion;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var typesAddedToUnion = [];\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n    var typeNamesInOldUnion = Object.create(null);\n    oldType.getTypes().forEach(function (type) {\n      typeNamesInOldUnion[type.name] = true;\n    });\n    newType.getTypes().forEach(function (type) {\n      if (!typeNamesInOldUnion[type.name]) {\n        typesAddedToUnion.push({\n          type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n          description: type.name + ' was added to union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var valuesRemovedFromEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n    var valuesInNewEnum = Object.create(null);\n    newType.getValues().forEach(function (value) {\n      valuesInNewEnum[value.name] = true;\n    });\n    oldType.getValues().forEach(function (value) {\n      if (!valuesInNewEnum[value.name]) {\n        valuesRemovedFromEnums.push({\n          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n          description: value.name + ' was removed from enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesRemovedFromEnums;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var valuesAddedToEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    oldType.getValues().forEach(function (value) {\n      valuesInOldEnum[value.name] = true;\n    });\n    newType.getValues().forEach(function (value) {\n      if (!valuesInOldEnum[value.name]) {\n        valuesAddedToEnums.push({\n          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n          description: value.name + ' was added to enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesAddedToEnums;\n}\n\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    oldInterfaces.forEach(function (oldInterface) {\n      if (!newInterfaces.some(function (int) {\n        return int.name === oldInterface.name;\n      })) {\n        breakingChanges.push({\n          type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n          description: typeName + ' no longer implements interface ' + (oldInterface.name + '.')\n        });\n      }\n    });\n  });\n  return breakingChanges;\n}\n\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    newInterfaces.forEach(function (newInterface) {\n      if (!oldInterfaces.some(function (int) {\n        return int.name === newInterface.name;\n      })) {\n        interfacesAddedToObjectTypes.push({\n          type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n          description: newInterface.name + ' added to interfaces implemented ' + ('by ' + typeName + '.')\n        });\n      }\n    });\n  });\n  return interfacesAddedToObjectTypes;\n}\n\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  oldSchema.getDirectives().forEach(function (directive) {\n    if (!newSchemaDirectiveMap[directive.name]) {\n      removedDirectives.push({\n        type: BreakingChangeType.DIRECTIVE_REMOVED,\n        description: directive.name + ' was removed'\n      });\n    }\n  });\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n\n  oldDirective.args.forEach(function (arg) {\n    if (!newArgMap[arg.name]) {\n      removedArgs.push(arg);\n    }\n  });\n\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      removedDirectiveArgs.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: arg.name + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n\n  newDirective.args.forEach(function (arg) {\n    if (!oldArgMap[arg.name]) {\n      addedArgs.push(arg);\n    }\n  });\n\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n    if (!oldDirective) {\n      return;\n    }\n\n    findAddedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      if (!isNonNullType(arg.type)) {\n        return;\n      }\n\n      addedNonNullableArgs.push({\n        type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,\n        description: 'A non-null arg ' + arg.name + ' on directive ' + (newDirective.name + ' was added')\n      });\n    });\n  });\n\n  return addedNonNullableArgs;\n}\n\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n\n  oldDirective.locations.forEach(function (oldLocation) {\n    if (!newLocationSet.has(oldLocation)) {\n      removedLocations.push(oldLocation);\n    }\n  });\n\n  return removedLocations;\n}\n\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedLocationsForDirective(oldDirective, newDirective).forEach(function (location) {\n      removedLocations.push({\n        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n        description: location + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}"]},"metadata":{},"sourceType":"module"}