{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\nexports.getDeprecationReason = getDeprecationReason;\nexports.getDescription = getDescription;\nexports.buildSchema = buildSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _lexer = require('../language/lexer');\n\nvar _parser = require('../language/parser');\n\nvar _values = require('../execution/values');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _schema = require('../type/schema');\n\nvar _scalars = require('../type/scalars');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction buildWrappedType(innerType, inputTypeNode) {\n  if (inputTypeNode.kind === Kind.LIST_TYPE) {\n    return new _definition.GraphQLList(buildWrappedType(innerType, inputTypeNode.type));\n  }\n\n  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {\n    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);\n    !!(wrappedType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;\n    return new _definition.GraphQLNonNull(wrappedType);\n  }\n\n  return innerType;\n}\n\nfunction getNamedTypeNode(typeNode) {\n  var namedType = typeNode;\n\n  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n\n  return namedType;\n}\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\n\n\nfunction buildASTSchema(ast) {\n  if (!ast || ast.kind !== Kind.DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  var schemaDef = void 0;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var d = ast.definitions[i];\n\n    switch (d.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n\n        schemaDef = d;\n        break;\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        var typeName = d.name.value;\n\n        if (nodeMap[typeName]) {\n          throw new Error('Type \"' + typeName + '\" was defined more than once.');\n        }\n\n        typeDefs.push(d);\n        nodeMap[typeName] = d;\n        break;\n\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  var queryTypeName = void 0;\n  var mutationTypeName = void 0;\n  var subscriptionTypeName = void 0;\n\n  if (schemaDef) {\n    schemaDef.operationTypes.forEach(function (operationType) {\n      var typeName = operationType.type.name.value;\n\n      if (operationType.operation === 'query') {\n        if (queryTypeName) {\n          throw new Error('Must provide only one query type in schema.');\n        }\n\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified query type \"' + typeName + '\" not found in document.');\n        }\n\n        queryTypeName = typeName;\n      } else if (operationType.operation === 'mutation') {\n        if (mutationTypeName) {\n          throw new Error('Must provide only one mutation type in schema.');\n        }\n\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified mutation type \"' + typeName + '\" not found in document.');\n        }\n\n        mutationTypeName = typeName;\n      } else if (operationType.operation === 'subscription') {\n        if (subscriptionTypeName) {\n          throw new Error('Must provide only one subscription type in schema.');\n        }\n\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified subscription type \"' + typeName + '\" not found in document.');\n        }\n\n        subscriptionTypeName = typeName;\n      }\n    });\n  } else {\n    if (nodeMap.Query) {\n      queryTypeName = 'Query';\n    }\n\n    if (nodeMap.Mutation) {\n      mutationTypeName = 'Mutation';\n    }\n\n    if (nodeMap.Subscription) {\n      subscriptionTypeName = 'Subscription';\n    }\n  }\n\n  if (!queryTypeName) {\n    throw new Error('Must provide schema definition with query type or a type named Query.');\n  }\n\n  var innerTypeMap = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  };\n  var types = typeDefs.map(function (def) {\n    return typeDefNamed(def.name.value);\n  });\n  var directives = directiveDefs.map(getDirective); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(_directives.GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(_directives.GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(_directives.GraphQLDeprecatedDirective);\n  }\n\n  return new _schema.GraphQLSchema({\n    query: getObjectType(nodeMap[queryTypeName]),\n    mutation: mutationTypeName ? getObjectType(nodeMap[mutationTypeName]) : null,\n    subscription: subscriptionTypeName ? getObjectType(nodeMap[subscriptionTypeName]) : null,\n    types: types,\n    directives: directives,\n    astNode: schemaDef\n  });\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function getObjectType(typeNode) {\n    var type = typeDefNamed(typeNode.name.value);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'AST must provide object type.') : void 0;\n    return type;\n  }\n\n  function produceType(typeNode) {\n    var typeName = getNamedTypeNode(typeNode).name.value;\n    var typeDef = typeDefNamed(typeName);\n    return buildWrappedType(typeDef, typeNode);\n  }\n\n  function produceInputType(typeNode) {\n    return (0, _definition.assertInputType)(produceType(typeNode));\n  }\n\n  function produceOutputType(typeNode) {\n    return (0, _definition.assertOutputType)(produceType(typeNode));\n  }\n\n  function produceObjectType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Expected Object type.') : void 0;\n    return type;\n  }\n\n  function produceInterfaceType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Expected Interface type.') : void 0;\n    return type;\n  }\n\n  function typeDefNamed(typeName) {\n    if (!innerTypeMap[typeName]) {\n      if (!nodeMap[typeName]) {\n        throw new Error('Type \"' + typeName + '\" not found in document.');\n      }\n\n      innerTypeMap[typeName] = makeSchemaDef(nodeMap[typeName]);\n    }\n\n    return innerTypeMap[typeName];\n  }\n\n  function makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return makeInputObjectDef(def);\n\n      default:\n        throw new Error('Type kind \"' + def.kind + '\" not supported.');\n    }\n  }\n\n  function makeTypeDef(def) {\n    var typeName = def.name.value;\n    return new _definition.GraphQLObjectType({\n      name: typeName,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      interfaces: function interfaces() {\n        return makeImplementedInterfaces(def);\n      },\n      astNode: def\n    });\n  }\n\n  function makeFieldDefMap(def) {\n    return (0, _keyValMap2.default)(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: produceOutputType(field.type),\n        description: getDescription(field),\n        args: makeInputValues(field.arguments),\n        deprecationReason: getDeprecationReason(field),\n        astNode: field\n      };\n    });\n  }\n\n  function makeImplementedInterfaces(def) {\n    return def.interfaces && def.interfaces.map(function (iface) {\n      return produceInterfaceType(iface);\n    });\n  }\n\n  function makeInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = produceInputType(value.type);\n      return {\n        type: type,\n        description: getDescription(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function makeInterfaceDef(def) {\n    return new _definition.GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      astNode: def,\n      resolveType: cannotExecuteSchema\n    });\n  }\n\n  function makeEnumDef(def) {\n    return new _definition.GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def),\n      values: (0, _keyValMap2.default)(def.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: getDescription(enumValue),\n          deprecationReason: getDeprecationReason(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: def\n    });\n  }\n\n  function makeUnionDef(def) {\n    return new _definition.GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def),\n      types: def.types.map(function (t) {\n        return produceObjectType(t);\n      }),\n      resolveType: cannotExecuteSchema,\n      astNode: def\n    });\n  }\n\n  function makeScalarDef(def) {\n    return new _definition.GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def),\n      astNode: def,\n      serialize: function serialize() {\n        return null;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function makeInputObjectDef(def) {\n    return new _definition.GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeInputValues(def.fields);\n      },\n      astNode: def\n    });\n  }\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nfunction getDeprecationReason(node) {\n  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description based on a contiguous\n * block full-line of comments preceding it.\n */\n\n\nfunction getDescription(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var minSpaces = void 0;\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === _lexer.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    var spaces = leadingSpaces(value);\n\n    if (minSpaces === undefined || spaces < minSpaces) {\n      minSpaces = spaces;\n    }\n\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().map(function (comment) {\n    return comment.slice(minSpaces);\n  }).join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nfunction buildSchema(source) {\n  return buildASTSchema((0, _parser.parse)(source));\n} // Count the number of spaces on the starting side of a string.\n\n\nfunction leadingSpaces(str) {\n  var i = 0;\n\n  for (; i < str.length; i++) {\n    if (str[i] !== ' ') {\n      break;\n    }\n  }\n\n  return i;\n}\n\nfunction cannotExecuteSchema() {\n  throw new Error('Generated Schema cannot use Interface or Union types for execution.');\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/utilities/buildASTSchema.js"],"names":["Object","defineProperty","exports","value","buildASTSchema","getDeprecationReason","getDescription","buildSchema","_invariant","require","_invariant2","_interopRequireDefault","_keyValMap","_keyValMap2","_valueFromAST","_lexer","_parser","_values","_kinds","Kind","_interopRequireWildcard","_schema","_scalars","_definition","_directives","_introspection","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","buildWrappedType","innerType","inputTypeNode","kind","LIST_TYPE","GraphQLList","type","NON_NULL_TYPE","wrappedType","GraphQLNonNull","getNamedTypeNode","typeNode","namedType","ast","DOCUMENT","Error","schemaDef","typeDefs","nodeMap","create","directiveDefs","i","definitions","length","d","SCHEMA_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","typeName","name","push","DIRECTIVE_DEFINITION","queryTypeName","mutationTypeName","subscriptionTypeName","operationTypes","forEach","operationType","operation","Query","Mutation","Subscription","innerTypeMap","String","GraphQLString","Int","GraphQLInt","Float","GraphQLFloat","Boolean","GraphQLBoolean","ID","GraphQLID","__Schema","__Directive","__DirectiveLocation","__Type","__Field","__InputValue","__EnumValue","__TypeKind","types","map","def","typeDefNamed","directives","getDirective","some","directive","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","GraphQLSchema","query","getObjectType","mutation","subscription","astNode","directiveNode","GraphQLDirective","description","locations","node","args","arguments","makeInputValues","GraphQLObjectType","produceType","typeDef","produceInputType","assertInputType","produceOutputType","assertOutputType","produceObjectType","produceInterfaceType","GraphQLInterfaceType","makeSchemaDef","makeTypeDef","makeInterfaceDef","makeEnumDef","makeUnionDef","makeScalarDef","makeInputObjectDef","fields","makeFieldDefMap","interfaces","makeImplementedInterfaces","field","deprecationReason","iface","values","defaultValue","valueFromAST","resolveType","cannotExecuteSchema","GraphQLEnumType","enumValue","GraphQLUnionType","t","GraphQLScalarType","serialize","parseValue","parseLiteral","GraphQLInputObjectType","deprecated","getDirectiveValues","reason","loc","comments","minSpaces","token","startToken","prev","TokenKind","COMMENT","next","line","spaces","leadingSpaces","undefined","reverse","comment","slice","join","source","parse","str"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\nexports.getDeprecationReason = getDeprecationReason;\nexports.getDescription = getDescription;\nexports.buildSchema = buildSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _lexer = require('../language/lexer');\n\nvar _parser = require('../language/parser');\n\nvar _values = require('../execution/values');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _schema = require('../type/schema');\n\nvar _scalars = require('../type/scalars');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction buildWrappedType(innerType, inputTypeNode) {\n  if (inputTypeNode.kind === Kind.LIST_TYPE) {\n    return new _definition.GraphQLList(buildWrappedType(innerType, inputTypeNode.type));\n  }\n  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {\n    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);\n    !!(wrappedType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;\n    return new _definition.GraphQLNonNull(wrappedType);\n  }\n  return innerType;\n}\n\nfunction getNamedTypeNode(typeNode) {\n  var namedType = typeNode;\n  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n  return namedType;\n}\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nfunction buildASTSchema(ast) {\n  if (!ast || ast.kind !== Kind.DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  var schemaDef = void 0;\n\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var d = ast.definitions[i];\n    switch (d.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n        schemaDef = d;\n        break;\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        var typeName = d.name.value;\n        if (nodeMap[typeName]) {\n          throw new Error('Type \"' + typeName + '\" was defined more than once.');\n        }\n        typeDefs.push(d);\n        nodeMap[typeName] = d;\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  var queryTypeName = void 0;\n  var mutationTypeName = void 0;\n  var subscriptionTypeName = void 0;\n  if (schemaDef) {\n    schemaDef.operationTypes.forEach(function (operationType) {\n      var typeName = operationType.type.name.value;\n      if (operationType.operation === 'query') {\n        if (queryTypeName) {\n          throw new Error('Must provide only one query type in schema.');\n        }\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified query type \"' + typeName + '\" not found in document.');\n        }\n        queryTypeName = typeName;\n      } else if (operationType.operation === 'mutation') {\n        if (mutationTypeName) {\n          throw new Error('Must provide only one mutation type in schema.');\n        }\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified mutation type \"' + typeName + '\" not found in document.');\n        }\n        mutationTypeName = typeName;\n      } else if (operationType.operation === 'subscription') {\n        if (subscriptionTypeName) {\n          throw new Error('Must provide only one subscription type in schema.');\n        }\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified subscription type \"' + typeName + '\" not found in document.');\n        }\n        subscriptionTypeName = typeName;\n      }\n    });\n  } else {\n    if (nodeMap.Query) {\n      queryTypeName = 'Query';\n    }\n    if (nodeMap.Mutation) {\n      mutationTypeName = 'Mutation';\n    }\n    if (nodeMap.Subscription) {\n      subscriptionTypeName = 'Subscription';\n    }\n  }\n\n  if (!queryTypeName) {\n    throw new Error('Must provide schema definition with query type or a type named Query.');\n  }\n\n  var innerTypeMap = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  };\n\n  var types = typeDefs.map(function (def) {\n    return typeDefNamed(def.name.value);\n  });\n\n  var directives = directiveDefs.map(getDirective);\n\n  // If specified directives were not explicitly declared, add them.\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(_directives.GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(_directives.GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(_directives.GraphQLDeprecatedDirective);\n  }\n\n  return new _schema.GraphQLSchema({\n    query: getObjectType(nodeMap[queryTypeName]),\n    mutation: mutationTypeName ? getObjectType(nodeMap[mutationTypeName]) : null,\n    subscription: subscriptionTypeName ? getObjectType(nodeMap[subscriptionTypeName]) : null,\n    types: types,\n    directives: directives,\n    astNode: schemaDef\n  });\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function getObjectType(typeNode) {\n    var type = typeDefNamed(typeNode.name.value);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'AST must provide object type.') : void 0;\n    return type;\n  }\n\n  function produceType(typeNode) {\n    var typeName = getNamedTypeNode(typeNode).name.value;\n    var typeDef = typeDefNamed(typeName);\n    return buildWrappedType(typeDef, typeNode);\n  }\n\n  function produceInputType(typeNode) {\n    return (0, _definition.assertInputType)(produceType(typeNode));\n  }\n\n  function produceOutputType(typeNode) {\n    return (0, _definition.assertOutputType)(produceType(typeNode));\n  }\n\n  function produceObjectType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Expected Object type.') : void 0;\n    return type;\n  }\n\n  function produceInterfaceType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Expected Interface type.') : void 0;\n    return type;\n  }\n\n  function typeDefNamed(typeName) {\n    if (!innerTypeMap[typeName]) {\n      if (!nodeMap[typeName]) {\n        throw new Error('Type \"' + typeName + '\" not found in document.');\n      }\n      innerTypeMap[typeName] = makeSchemaDef(nodeMap[typeName]);\n    }\n    return innerTypeMap[typeName];\n  }\n\n  function makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return makeTypeDef(def);\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return makeInterfaceDef(def);\n      case Kind.ENUM_TYPE_DEFINITION:\n        return makeEnumDef(def);\n      case Kind.UNION_TYPE_DEFINITION:\n        return makeUnionDef(def);\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return makeScalarDef(def);\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return makeInputObjectDef(def);\n      default:\n        throw new Error('Type kind \"' + def.kind + '\" not supported.');\n    }\n  }\n\n  function makeTypeDef(def) {\n    var typeName = def.name.value;\n    return new _definition.GraphQLObjectType({\n      name: typeName,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      interfaces: function interfaces() {\n        return makeImplementedInterfaces(def);\n      },\n      astNode: def\n    });\n  }\n\n  function makeFieldDefMap(def) {\n    return (0, _keyValMap2.default)(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: produceOutputType(field.type),\n        description: getDescription(field),\n        args: makeInputValues(field.arguments),\n        deprecationReason: getDeprecationReason(field),\n        astNode: field\n      };\n    });\n  }\n\n  function makeImplementedInterfaces(def) {\n    return def.interfaces && def.interfaces.map(function (iface) {\n      return produceInterfaceType(iface);\n    });\n  }\n\n  function makeInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = produceInputType(value.type);\n      return {\n        type: type,\n        description: getDescription(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function makeInterfaceDef(def) {\n    return new _definition.GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      astNode: def,\n      resolveType: cannotExecuteSchema\n    });\n  }\n\n  function makeEnumDef(def) {\n    return new _definition.GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def),\n      values: (0, _keyValMap2.default)(def.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: getDescription(enumValue),\n          deprecationReason: getDeprecationReason(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: def\n    });\n  }\n\n  function makeUnionDef(def) {\n    return new _definition.GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def),\n      types: def.types.map(function (t) {\n        return produceObjectType(t);\n      }),\n      resolveType: cannotExecuteSchema,\n      astNode: def\n    });\n  }\n\n  function makeScalarDef(def) {\n    return new _definition.GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def),\n      astNode: def,\n      serialize: function serialize() {\n        return null;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function makeInputObjectDef(def) {\n    return new _definition.GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeInputValues(def.fields);\n      },\n      astNode: def\n    });\n  }\n}\n\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\nfunction getDeprecationReason(node) {\n  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n\n/**\n * Given an ast node, returns its string description based on a contiguous\n * block full-line of comments preceding it.\n */\nfunction getDescription(node) {\n  var loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  var comments = [];\n  var minSpaces = void 0;\n  var token = loc.startToken.prev;\n  while (token && token.kind === _lexer.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    var spaces = leadingSpaces(value);\n    if (minSpaces === undefined || spaces < minSpaces) {\n      minSpaces = spaces;\n    }\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.reverse().map(function (comment) {\n    return comment.slice(minSpaces);\n  }).join('\\n');\n}\n\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\nfunction buildSchema(source) {\n  return buildASTSchema((0, _parser.parse)(source));\n}\n\n// Count the number of spaces on the starting side of a string.\nfunction leadingSpaces(str) {\n  var i = 0;\n  for (; i < str.length; i++) {\n    if (str[i] !== ' ') {\n      break;\n    }\n  }\n  return i;\n}\n\nfunction cannotExecuteSchema() {\n  throw new Error('Generated Schema cannot use Interface or Union types for execution.');\n}"]},"metadata":{},"sourceType":"script"}