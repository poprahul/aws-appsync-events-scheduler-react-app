{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\nimport { assertNullableType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { introspectionTypes } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { GraphQLSchema } from '../type/schema';\n\nfunction buildWrappedType(innerType, inputTypeNode) {\n  if (inputTypeNode.kind === Kind.LIST_TYPE) {\n    return GraphQLList(buildWrappedType(innerType, inputTypeNode.type));\n  }\n\n  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {\n    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);\n    return GraphQLNonNull(assertNullableType(wrappedType));\n  }\n\n  return innerType;\n}\n\nfunction getNamedTypeNode(typeNode) {\n  var namedType = typeNode;\n\n  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n\n  return namedType;\n}\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function buildASTSchema(ast, options) {\n  if (!ast || ast.kind !== Kind.DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  var schemaDef = void 0;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var d = ast.definitions[i];\n\n    switch (d.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n\n        schemaDef = d;\n        break;\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        var _typeName = d.name.value;\n\n        if (nodeMap[_typeName]) {\n          throw new Error('Type \"' + _typeName + '\" was defined more than once.');\n        }\n\n        typeDefs.push(d);\n        nodeMap[_typeName] = d;\n        break;\n\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query ? 'Query' : null,\n    mutation: nodeMap.Mutation ? 'Mutation' : null,\n    subscription: nodeMap.Subscription ? 'Subscription' : null\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeName) {\n    throw new Error('Type \"' + typeName + '\" not found in document.');\n  });\n  var types = typeDefs.map(function (def) {\n    return definitionBuilder.buildType(def.name.value);\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: types,\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    schema.operationTypes.forEach(function (operationType) {\n      var typeName = operationType.type.name.value;\n      var operation = operationType.operation;\n\n      if (opTypes[operation]) {\n        throw new Error('Must provide only one ' + operation + ' type in schema.');\n      }\n\n      if (!nodeMap[typeName]) {\n        throw new Error('Specified ' + operation + ' type \"' + typeName + '\" not found in document.');\n      }\n\n      opTypes[operation] = typeName;\n    });\n    return opTypes;\n  }\n}\nexport var ASTDefinitionBuilder = function () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _classCallCheck(this, ASTDefinitionBuilder);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  ASTDefinitionBuilder.prototype._buildType = function _buildType(typeName, typeNode) {\n    if (!this._cache[typeName]) {\n      var defNode = this._typeDefinitionsMap[typeName];\n\n      if (defNode) {\n        this._cache[typeName] = this._makeSchemaDef(defNode);\n      } else {\n        this._cache[typeName] = this._resolveType(typeName, typeNode);\n      }\n    }\n\n    return this._cache[typeName];\n  };\n\n  ASTDefinitionBuilder.prototype.buildType = function buildType(ref) {\n    if (typeof ref === 'string') {\n      return this._buildType(ref);\n    }\n\n    return this._buildType(ref.name.value, ref);\n  };\n\n  ASTDefinitionBuilder.prototype._buildWrappedType = function _buildWrappedType(typeNode) {\n    var typeDef = this.buildType(getNamedTypeNode(typeNode));\n    return buildWrappedType(typeDef, typeNode);\n  };\n\n  ASTDefinitionBuilder.prototype.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  ASTDefinitionBuilder.prototype.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  ASTDefinitionBuilder.prototype._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n\n      default:\n        throw new Error('Type kind \"' + def.kind + '\" not supported.');\n    }\n  };\n\n  ASTDefinitionBuilder.prototype._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var typeName = def.name.value;\n    return new GraphQLObjectType({\n      name: typeName,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      interfaces: function interfaces() {\n        return _this._makeImplementedInterfaces(def);\n      },\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  ASTDefinitionBuilder.prototype._makeImplementedInterfaces = function _makeImplementedInterfaces(def) {\n    var _this3 = this;\n\n    return def.interfaces && // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    def.interfaces.map(function (iface) {\n      return _this3.buildType(iface);\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeInputValues = function _makeInputValues(values) {\n    var _this4 = this;\n\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      var type = _this4._buildWrappedType(value.type);\n\n      return {\n        type: type,\n        description: getDescription(value, _this4._options),\n        defaultValue: valueFromAST(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this5 = this;\n\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this5._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeEnumDef = function _makeEnumDef(def) {\n    var _this6 = this;\n\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: def.values ? keyValMap(def.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: getDescription(enumValue, _this6._options),\n          deprecationReason: getDeprecationReason(enumValue),\n          astNode: enumValue\n        };\n      }) : {},\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeUnionDef = function _makeUnionDef(def) {\n    var _this7 = this;\n\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: def.types ? def.types.map(function (t) {\n        return _this7.buildType(t);\n      }) : [],\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this8 = this;\n\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this8._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source) {\n  return buildASTSchema(parse(source));\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/buildASTSchema.js"],"names":["_classCallCheck","instance","Constructor","TypeError","keyMap","keyValMap","valueFromAST","blockStringValue","TokenKind","parse","getDirectiveValues","Kind","assertNullableType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","GraphQLDirective","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","introspectionTypes","specifiedScalarTypes","GraphQLSchema","buildWrappedType","innerType","inputTypeNode","kind","LIST_TYPE","type","NON_NULL_TYPE","wrappedType","getNamedTypeNode","typeNode","namedType","buildASTSchema","ast","options","DOCUMENT","Error","schemaDef","typeDefs","nodeMap","Object","create","directiveDefs","i","definitions","length","d","SCHEMA_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","_typeName","name","value","push","DIRECTIVE_DEFINITION","operationTypes","getOperationTypes","query","Query","mutation","Mutation","subscription","Subscription","definitionBuilder","ASTDefinitionBuilder","typeName","types","map","def","buildType","directives","buildDirective","some","directive","astNode","assumeValid","schema","opTypes","forEach","operationType","operation","typeDefinitionsMap","resolveType","_typeDefinitionsMap","_options","_resolveType","_cache","concat","prototype","_buildType","defNode","_makeSchemaDef","ref","_buildWrappedType","typeDef","directiveNode","description","getDescription","locations","node","args","arguments","_makeInputValues","buildField","field","deprecationReason","getDeprecationReason","_makeTypeDef","_makeInterfaceDef","_makeEnumDef","_makeUnionDef","_makeScalarDef","_makeInputObjectDef","_this","fields","_makeFieldDefMap","interfaces","_makeImplementedInterfaces","_this2","_this3","iface","values","_this4","defaultValue","_this5","_this6","enumValue","_this7","t","serialize","_this8","deprecated","reason","commentDescriptions","rawValue","getLeadingCommentBlock","undefined","loc","comments","token","startToken","prev","COMMENT","next","line","String","reverse","join","buildSchema","source"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\n\nimport { valueFromAST } from './valueFromAST';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\n\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\n\nimport { assertNullableType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\n\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\n\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\n\nimport { introspectionTypes } from '../type/introspection';\n\nimport { specifiedScalarTypes } from '../type/scalars';\n\nimport { GraphQLSchema } from '../type/schema';\n\nfunction buildWrappedType(innerType, inputTypeNode) {\n  if (inputTypeNode.kind === Kind.LIST_TYPE) {\n    return GraphQLList(buildWrappedType(innerType, inputTypeNode.type));\n  }\n  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {\n    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);\n    return GraphQLNonNull(assertNullableType(wrappedType));\n  }\n  return innerType;\n}\n\nfunction getNamedTypeNode(typeNode) {\n  var namedType = typeNode;\n  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n  return namedType;\n}\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(ast, options) {\n  if (!ast || ast.kind !== Kind.DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  var schemaDef = void 0;\n\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var d = ast.definitions[i];\n    switch (d.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n        schemaDef = d;\n        break;\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        var _typeName = d.name.value;\n        if (nodeMap[_typeName]) {\n          throw new Error('Type \"' + _typeName + '\" was defined more than once.');\n        }\n        typeDefs.push(d);\n        nodeMap[_typeName] = d;\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query ? 'Query' : null,\n    mutation: nodeMap.Mutation ? 'Mutation' : null,\n    subscription: nodeMap.Subscription ? 'Subscription' : null\n  };\n\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeName) {\n    throw new Error('Type \"' + typeName + '\" not found in document.');\n  });\n\n  var types = typeDefs.map(function (def) {\n    return definitionBuilder.buildType(def.name.value);\n  });\n\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  });\n\n  // If specified directives were not explicitly declared, add them.\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: types,\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    schema.operationTypes.forEach(function (operationType) {\n      var typeName = operationType.type.name.value;\n      var operation = operationType.operation;\n      if (opTypes[operation]) {\n        throw new Error('Must provide only one ' + operation + ' type in schema.');\n      }\n      if (!nodeMap[typeName]) {\n        throw new Error('Specified ' + operation + ' type \"' + typeName + '\" not found in document.');\n      }\n      opTypes[operation] = typeName;\n    });\n    return opTypes;\n  }\n}\n\nexport var ASTDefinitionBuilder = function () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _classCallCheck(this, ASTDefinitionBuilder);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType;\n    // Initialize to the GraphQL built in scalars and introspection types.\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  ASTDefinitionBuilder.prototype._buildType = function _buildType(typeName, typeNode) {\n    if (!this._cache[typeName]) {\n      var defNode = this._typeDefinitionsMap[typeName];\n      if (defNode) {\n        this._cache[typeName] = this._makeSchemaDef(defNode);\n      } else {\n        this._cache[typeName] = this._resolveType(typeName, typeNode);\n      }\n    }\n    return this._cache[typeName];\n  };\n\n  ASTDefinitionBuilder.prototype.buildType = function buildType(ref) {\n    if (typeof ref === 'string') {\n      return this._buildType(ref);\n    }\n    return this._buildType(ref.name.value, ref);\n  };\n\n  ASTDefinitionBuilder.prototype._buildWrappedType = function _buildWrappedType(typeNode) {\n    var typeDef = this.buildType(getNamedTypeNode(typeNode));\n    return buildWrappedType(typeDef, typeNode);\n  };\n\n  ASTDefinitionBuilder.prototype.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  ASTDefinitionBuilder.prototype.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  ASTDefinitionBuilder.prototype._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n      default:\n        throw new Error('Type kind \"' + def.kind + '\" not supported.');\n    }\n  };\n\n  ASTDefinitionBuilder.prototype._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var typeName = def.name.value;\n    return new GraphQLObjectType({\n      name: typeName,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      interfaces: function interfaces() {\n        return _this._makeImplementedInterfaces(def);\n      },\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  ASTDefinitionBuilder.prototype._makeImplementedInterfaces = function _makeImplementedInterfaces(def) {\n    var _this3 = this;\n\n    return def.interfaces &&\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    def.interfaces.map(function (iface) {\n      return _this3.buildType(iface);\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeInputValues = function _makeInputValues(values) {\n    var _this4 = this;\n\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      var type = _this4._buildWrappedType(value.type);\n      return {\n        type: type,\n        description: getDescription(value, _this4._options),\n        defaultValue: valueFromAST(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this5 = this;\n\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this5._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeEnumDef = function _makeEnumDef(def) {\n    var _this6 = this;\n\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: def.values ? keyValMap(def.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: getDescription(enumValue, _this6._options),\n          deprecationReason: getDeprecationReason(enumValue),\n          astNode: enumValue\n        };\n      }) : {},\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeUnionDef = function _makeUnionDef(def) {\n    var _this7 = this;\n\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: def.types ? def.types.map(function (t) {\n        return _this7.buildType(t);\n      }) : [],\n      astNode: def\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  ASTDefinitionBuilder.prototype._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this8 = this;\n\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this8._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n\n/**\n * Given an ast node, returns its string description.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  var comments = [];\n  var token = loc.startToken.prev;\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.reverse().join('\\n');\n}\n\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\nexport function buildSchema(source) {\n  return buildASTSchema(parse(source));\n}"]},"metadata":{},"sourceType":"module"}