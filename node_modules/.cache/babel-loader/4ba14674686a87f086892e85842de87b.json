{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport invariant from '../jsutils/invariant';\nimport { GraphQLError } from '../error';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { Kind } from '../language/kinds';\nimport { GraphQLSchema } from '../type/schema';\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules } from './specifiedRules';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, ast, rules, typeInfo) {\n  !ast ? invariant(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  return visitUsingRules(schema, typeInfo || new TypeInfo(schema), ast, rules || specifiedRules);\n}\n/**\n * This uses a specialized visitor which runs multiple visitors in parallel,\n * while maintaining the visitor skip and break API.\n *\n * @internal\n */\n\nfunction visitUsingRules(schema, typeInfo, documentAST, rules) {\n  var context = new ValidationContext(schema, documentAST, typeInfo);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  }); // Visit the whole document with each instance of all provided rules.\n\n  visit(documentAST, visitWithTypeInfo(typeInfo, visitInParallel(visitors)));\n  return context.getErrors();\n}\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\n\n\nexport var ValidationContext = function () {\n  function ValidationContext(schema, ast, typeInfo) {\n    _classCallCheck(this, ValidationContext);\n\n    this._schema = schema;\n    this._ast = ast;\n    this._typeInfo = typeInfo;\n    this._errors = [];\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  ValidationContext.prototype.reportError = function reportError(error) {\n    this._errors.push(error);\n  };\n\n  ValidationContext.prototype.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  ValidationContext.prototype.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  ValidationContext.prototype.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  ValidationContext.prototype.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  ValidationContext.prototype.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var i = 0; i < set.selections.length; i++) {\n          var selection = set.selections[i];\n\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  ValidationContext.prototype.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var _node = nodesToVisit.pop();\n\n        var spreads = this.getFragmentSpreads(_node);\n\n        for (var i = 0; i < spreads.length; i++) {\n          var fragName = spreads[i].name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  ValidationContext.prototype.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  ValidationContext.prototype.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      var fragments = this.getRecursivelyReferencedFragments(operation);\n\n      for (var i = 0; i < fragments.length; i++) {\n        Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  ValidationContext.prototype.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  ValidationContext.prototype.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  ValidationContext.prototype.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  ValidationContext.prototype.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  ValidationContext.prototype.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  ValidationContext.prototype.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  ValidationContext.prototype.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  return ValidationContext;\n}();","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/validation/validate.js"],"names":["_classCallCheck","instance","Constructor","TypeError","invariant","GraphQLError","visit","visitInParallel","visitWithTypeInfo","Kind","GraphQLSchema","assertValidSchema","TypeInfo","specifiedRules","validate","schema","ast","rules","typeInfo","visitUsingRules","documentAST","context","ValidationContext","visitors","map","rule","getErrors","_schema","_ast","_typeInfo","_errors","_fragmentSpreads","Map","_recursivelyReferencedFragments","_variableUsages","_recursiveVariableUsages","prototype","reportError","error","push","getSchema","getDocument","getFragment","name","fragments","_fragments","definitions","reduce","frags","statement","kind","FRAGMENT_DEFINITION","value","Object","create","getFragmentSpreads","node","spreads","get","setsToVisit","length","set","pop","i","selections","selection","FRAGMENT_SPREAD","selectionSet","getRecursivelyReferencedFragments","operation","collectedNames","nodesToVisit","_node","fragName","fragment","getVariableUsages","usages","newUsages","VariableDefinition","Variable","variable","type","getInputType","getRecursiveVariableUsages","Array","apply","getType","getParentType","getParentInputType","getFieldDef","getDirective","getArgument"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport invariant from '../jsutils/invariant';\n\nimport { GraphQLError } from '../error';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { Kind } from '../language/kinds';\n\nimport { GraphQLSchema } from '../type/schema';\n\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules } from './specifiedRules';\n\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\nexport function validate(schema, ast, rules, typeInfo) {\n  !ast ? invariant(0, 'Must provide document') : void 0;\n  // If the schema used for validation is invalid, throw an error.\n  assertValidSchema(schema);\n  return visitUsingRules(schema, typeInfo || new TypeInfo(schema), ast, rules || specifiedRules);\n}\n\n/**\n * This uses a specialized visitor which runs multiple visitors in parallel,\n * while maintaining the visitor skip and break API.\n *\n * @internal\n */\nfunction visitUsingRules(schema, typeInfo, documentAST, rules) {\n  var context = new ValidationContext(schema, documentAST, typeInfo);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  // Visit the whole document with each instance of all provided rules.\n  visit(documentAST, visitWithTypeInfo(typeInfo, visitInParallel(visitors)));\n  return context.getErrors();\n}\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport var ValidationContext = function () {\n  function ValidationContext(schema, ast, typeInfo) {\n    _classCallCheck(this, ValidationContext);\n\n    this._schema = schema;\n    this._ast = ast;\n    this._typeInfo = typeInfo;\n    this._errors = [];\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  ValidationContext.prototype.reportError = function reportError(error) {\n    this._errors.push(error);\n  };\n\n  ValidationContext.prototype.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  ValidationContext.prototype.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  ValidationContext.prototype.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  ValidationContext.prototype.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n        return frags;\n      }, Object.create(null));\n    }\n    return fragments[name];\n  };\n\n  ValidationContext.prototype.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n        for (var i = 0; i < set.selections.length; i++) {\n          var selection = set.selections[i];\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n      this._fragmentSpreads.set(node, spreads);\n    }\n    return spreads;\n  };\n\n  ValidationContext.prototype.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n      while (nodesToVisit.length !== 0) {\n        var _node = nodesToVisit.pop();\n        var spreads = this.getFragmentSpreads(_node);\n        for (var i = 0; i < spreads.length; i++) {\n          var fragName = spreads[i].name.value;\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n    return fragments;\n  };\n\n  ValidationContext.prototype.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({ node: variable, type: typeInfo.getInputType() });\n        }\n      }));\n      usages = newUsages;\n      this._variableUsages.set(node, usages);\n    }\n    return usages;\n  };\n\n  ValidationContext.prototype.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      var fragments = this.getRecursivelyReferencedFragments(operation);\n      for (var i = 0; i < fragments.length; i++) {\n        Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));\n      }\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n    return usages;\n  };\n\n  ValidationContext.prototype.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  ValidationContext.prototype.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  ValidationContext.prototype.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  ValidationContext.prototype.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  ValidationContext.prototype.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  ValidationContext.prototype.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  ValidationContext.prototype.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  return ValidationContext;\n}();"]},"metadata":{},"sourceType":"module"}