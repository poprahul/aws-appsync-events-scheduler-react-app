{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isObjectType, isListType, isNonNullType, isAbstractType } from '../type/definition';\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n\nexport function isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nexport function isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isNonNullType(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isListType(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n\n\n  if (isAbstractType(superType) && isObjectType(maybeSubType) && schema.isPossibleType(superType, maybeSubType)) {\n    return true;\n  } // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return false;\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nexport function doTypesOverlap(schema, typeA, typeB) {\n  // So flow is aware this is constant\n  var _typeB = typeB; // Equivalent types overlap\n\n  if (typeA === _typeB) {\n    return true;\n  }\n\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(_typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isPossibleType(_typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isPossibleType(typeA, _typeB);\n  }\n\n  if (isAbstractType(_typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(_typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/typeComparators.js"],"names":["isObjectType","isListType","isNonNullType","isAbstractType","isEqualType","typeA","typeB","ofType","isTypeSubTypeOf","schema","maybeSubType","superType","isPossibleType","doTypesOverlap","_typeB","getPossibleTypes","some","type"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { isObjectType, isListType, isNonNullType, isAbstractType } from '../type/definition';\n\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nexport function isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  }\n\n  // If either type is non-null, the other must also be non-null.\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // If either type is a list, the other must also be a list.\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // Otherwise the types are not equal.\n  return false;\n}\n\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\nexport function isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  }\n\n  // If superType is non-null, maybeSubType must also be non-null.\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if (isNonNullType(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  }\n\n  // If superType type is a list, maybeSubType type must also be a list.\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if (isListType(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  }\n\n  // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n  if (isAbstractType(superType) && isObjectType(maybeSubType) && schema.isPossibleType(superType, maybeSubType)) {\n    return true;\n  }\n\n  // Otherwise, the child type is not a valid subtype of the parent type.\n  return false;\n}\n\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\nexport function doTypesOverlap(schema, typeA, typeB) {\n  // So flow is aware this is constant\n  var _typeB = typeB;\n\n  // Equivalent types overlap\n  if (typeA === _typeB) {\n    return true;\n  }\n\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(_typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isPossibleType(_typeB, type);\n      });\n    }\n    // Determine if the latter type is a possible concrete type of the former.\n    return schema.isPossibleType(typeA, _typeB);\n  }\n\n  if (isAbstractType(_typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(_typeB, typeA);\n  }\n\n  // Otherwise the types do not overlap.\n  return false;\n}"]},"metadata":{},"sourceType":"module"}