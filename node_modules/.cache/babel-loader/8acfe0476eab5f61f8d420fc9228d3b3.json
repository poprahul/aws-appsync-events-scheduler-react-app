{"ast":null,"code":"\"use strict\";\n\nvar getLocal = require(\"./local.js\").get;\n\nvar UNKNOWN_VALUE = Object.create(null);\nvar emptySetPool = [];\nvar entryPool = []; // Don't let the emptySetPool or entryPool grow larger than this size,\n// since unconstrained pool growth could lead to memory leaks.\n\nexports.POOL_TARGET_SIZE = 100; // Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\n\nfunction assert(condition, optionalMessage) {\n  if (!condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\nfunction Entry(fn, key, args) {\n  this.parents = new Set();\n  this.childValues = new Map(); // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n\n  this.dirtyChildren = null;\n  reset(this, fn, key, args);\n  ++Entry.count;\n}\n\nEntry.count = 0;\n\nfunction reset(entry, fn, key, args) {\n  entry.fn = fn;\n  entry.key = key;\n  entry.args = args;\n  entry.value = UNKNOWN_VALUE;\n  entry.dirty = true;\n  entry.subscribe = null;\n  entry.unsubscribe = null;\n  entry.recomputing = false; // Optional callback that will be invoked when entry.parents becomes\n  // empty. The Entry object is given as the first parameter. If the\n  // callback returns true, then this entry can be removed from the graph\n  // and safely recycled into the entryPool.\n\n  entry.reportOrphan = null;\n}\n\nEntry.acquire = function (fn, key, args) {\n  var entry = entryPool.pop();\n\n  if (entry) {\n    reset(entry, fn, key, args);\n    return entry;\n  }\n\n  return new Entry(fn, key, args);\n};\n\nfunction release(entry) {\n  assert(entry.parents.size === 0);\n  assert(entry.childValues.size === 0);\n  assert(entry.dirtyChildren === null);\n\n  if (entryPool.length < exports.POOL_TARGET_SIZE) {\n    entryPool.push(entry);\n  }\n}\n\nexports.Entry = Entry;\nvar Ep = Entry.prototype; // The public API of Entry objects consists of the Entry constructor,\n// along with the recompute, setDirty, and dispose methods.\n\nEp.recompute = function recompute() {\n  if (!rememberParent(this) && maybeReportOrphan(this)) {\n    // The recipient of the entry.reportOrphan callback decided to dispose\n    // of this orphan entry by calling entry.dispos(), which recycles it\n    // into the entryPool, so we don't need to (and should not) proceed\n    // with the recomputation.\n    return;\n  }\n\n  return recomputeIfDirty(this);\n}; // If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\n\n\nfunction maybeReportOrphan(entry) {\n  var report = entry.reportOrphan;\n  return typeof report === \"function\" && entry.parents.size === 0 && report(entry) === true;\n}\n\nEp.setDirty = function setDirty() {\n  if (this.dirty) return;\n  this.dirty = true;\n  this.value = UNKNOWN_VALUE;\n  reportDirty(this); // We can go ahead and unsubscribe here, since any further dirty\n  // notifications we receive will be redundant, and unsubscribing may\n  // free up some resources, e.g. file watchers.\n\n  unsubscribe(this);\n};\n\nEp.dispose = function dispose() {\n  var entry = this;\n  forgetChildren(entry).forEach(maybeReportOrphan);\n  unsubscribe(entry); // Because this entry has been kicked out of the cache (in index.js),\n  // we've lost the ability to find out if/when this entry becomes dirty,\n  // whether that happens through a subscription, because of a direct call\n  // to entry.setDirty(), or because one of its children becomes dirty.\n  // Because of this loss of future information, we have to assume the\n  // worst (that this entry might have become dirty very soon), so we must\n  // immediately mark this entry's parents as dirty. Normally we could\n  // just call entry.setDirty() rather than calling parent.setDirty() for\n  // each parent, but that would leave this entry in parent.childValues\n  // and parent.dirtyChildren, which would prevent the child from being\n  // truly forgotten.\n\n  entry.parents.forEach(function (parent) {\n    parent.setDirty();\n    forgetChild(parent, entry);\n  }); // Since this entry has no parents and no children anymore, and the\n  // caller of Entry#dispose has indicated that entry.value no longer\n  // matters, we can safely recycle this Entry object for later use.\n\n  release(entry);\n};\n\nfunction setClean(entry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(entry) {\n  entry.parents.forEach(function (parent) {\n    reportDirtyChild(parent, entry);\n  });\n}\n\nfunction reportClean(entry) {\n  entry.parents.forEach(function (parent) {\n    reportCleanChild(parent, entry);\n  });\n}\n\nfunction mightBeDirty(entry) {\n  return entry.dirty || entry.dirtyChildren && entry.dirtyChildren.size;\n} // Let a parent Entry know that one of its children may be dirty.\n\n\nfunction reportDirtyChild(entry, child) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(entry.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (!entry.dirtyChildren) {\n    entry.dirtyChildren = emptySetPool.pop() || new Set();\n  } else if (entry.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  entry.dirtyChildren.add(child);\n  reportDirty(entry);\n} // Let a parent Entry know that one of its children is no longer dirty.\n\n\nfunction reportCleanChild(entry, child) {\n  var cv = entry.childValues; // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n\n  assert(cv.has(child));\n  assert(!mightBeDirty(child));\n  var childValue = cv.get(child);\n\n  if (childValue === UNKNOWN_VALUE) {\n    cv.set(child, child.value);\n  } else if (childValue !== child.value) {\n    entry.setDirty();\n  }\n\n  removeDirtyChild(entry, child);\n\n  if (mightBeDirty(entry)) {\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction removeDirtyChild(entry, child) {\n  var dc = entry.dirtyChildren;\n\n  if (dc) {\n    dc.delete(child);\n\n    if (dc.size === 0) {\n      if (emptySetPool.length < exports.POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n\n      entry.dirtyChildren = null;\n    }\n  }\n}\n\nfunction rememberParent(entry) {\n  var local = getLocal();\n  var parent = local.currentParentEntry;\n\n  if (parent) {\n    entry.parents.add(parent);\n\n    if (!parent.childValues.has(entry)) {\n      parent.childValues.set(entry, UNKNOWN_VALUE);\n    }\n\n    if (mightBeDirty(entry)) {\n      reportDirtyChild(parent, entry);\n    } else {\n      reportCleanChild(parent, entry);\n    }\n\n    return parent;\n  }\n} // This is the most important method of the Entry API, because it\n// determines whether the cached entry.value can be returned immediately,\n// or must be recomputed. The overall performance of the caching system\n// depends on the truth of the following observations: (1) this.dirty is\n// usually false, (2) this.dirtyChildren is usually null/empty, and thus\n// (3) this.value is usally returned very quickly, without recomputation.\n\n\nfunction recomputeIfDirty(entry) {\n  if (entry.dirty) {\n    // If this Entry is explicitly dirty because someone called\n    // entry.setDirty(), recompute.\n    return reallyRecompute(entry);\n  }\n\n  if (mightBeDirty(entry)) {\n    // Get fresh values for any dirty children, and if those values\n    // disagree with this.childValues, mark this Entry explicitly dirty.\n    entry.dirtyChildren.forEach(function (child) {\n      assert(entry.childValues.has(child));\n\n      try {\n        recomputeIfDirty(child);\n      } catch (e) {\n        entry.setDirty();\n      }\n    });\n\n    if (entry.dirty) {\n      // If this Entry has become explicitly dirty after comparing the fresh\n      // values of its dirty children against this.childValues, recompute.\n      return reallyRecompute(entry);\n    }\n  }\n\n  assert(entry.value !== UNKNOWN_VALUE);\n  return entry.value;\n}\n\nfunction reallyRecompute(entry) {\n  assert(!entry.recomputing, \"already recomputing\");\n  entry.recomputing = true; // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n\n  var originalChildren = forgetChildren(entry);\n  var local = getLocal();\n  var parent = local.currentParentEntry;\n  local.currentParentEntry = entry;\n  var threw = true;\n\n  try {\n    entry.value = entry.fn.apply(null, entry.args);\n    threw = false;\n  } finally {\n    entry.recomputing = false;\n    assert(local.currentParentEntry === entry);\n    local.currentParentEntry = parent;\n\n    if (threw || !subscribe(entry)) {\n      // Mark this Entry dirty if entry.fn threw or we failed to\n      // resubscribe. This is important because, if we have a subscribe\n      // function and it failed, then we're going to miss important\n      // notifications about the potential dirtiness of entry.value.\n      entry.setDirty();\n    } else {\n      // If we successfully recomputed entry.value and did not fail to\n      // (re)subscribe, then this Entry is no longer explicitly dirty.\n      setClean(entry);\n    }\n  } // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n\n\n  originalChildren.forEach(maybeReportOrphan);\n  return entry.value;\n}\n\nvar reusableEmptyArray = []; // Removes all children from this entry and returns an array of the\n// removed children.\n\nfunction forgetChildren(entry) {\n  var children = reusableEmptyArray;\n\n  if (entry.childValues.size > 0) {\n    children = [];\n    entry.childValues.forEach(function (value, child) {\n      forgetChild(entry, child);\n      children.push(child);\n    });\n  } // After we forget all our children, this.dirtyChildren must be empty\n  // and therefor must have been reset to null.\n\n\n  assert(entry.dirtyChildren === null);\n  return children;\n}\n\nfunction forgetChild(entry, child) {\n  child.parents.delete(entry);\n  entry.childValues.delete(child);\n  removeDirtyChild(entry, child);\n}\n\nfunction subscribe(entry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      unsubscribe(entry); // Prevent double subscriptions.\n\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  } // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n\n\n  return true;\n}\n\nfunction unsubscribe(entry) {\n  var unsub = entry.unsubscribe;\n\n  if (typeof unsub === \"function\") {\n    entry.unsubscribe = null;\n    unsub();\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/optimism/lib/entry.js"],"names":["getLocal","require","get","UNKNOWN_VALUE","Object","create","emptySetPool","entryPool","exports","POOL_TARGET_SIZE","assert","condition","optionalMessage","Error","Entry","fn","key","args","parents","Set","childValues","Map","dirtyChildren","reset","count","entry","value","dirty","subscribe","unsubscribe","recomputing","reportOrphan","acquire","pop","release","size","length","push","Ep","prototype","recompute","rememberParent","maybeReportOrphan","recomputeIfDirty","report","setDirty","reportDirty","dispose","forgetChildren","forEach","parent","forgetChild","setClean","mightBeDirty","reportClean","reportDirtyChild","reportCleanChild","child","has","add","cv","childValue","set","removeDirtyChild","dc","delete","local","currentParentEntry","reallyRecompute","e","originalChildren","threw","apply","reusableEmptyArray","children","unsub"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar getLocal = require(\"./local.js\").get;\nvar UNKNOWN_VALUE = Object.create(null);\nvar emptySetPool = [];\nvar entryPool = [];\n\n// Don't let the emptySetPool or entryPool grow larger than this size,\n// since unconstrained pool growth could lead to memory leaks.\nexports.POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\nfunction Entry(fn, key, args) {\n  this.parents = new Set;\n  this.childValues = new Map;\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  this.dirtyChildren = null;\n\n  reset(this, fn, key, args);\n\n  ++Entry.count;\n}\n\nEntry.count = 0;\n\nfunction reset(entry, fn, key, args) {\n  entry.fn = fn;\n  entry.key = key;\n  entry.args = args;\n  entry.value = UNKNOWN_VALUE;\n  entry.dirty = true;\n  entry.subscribe = null;\n  entry.unsubscribe = null;\n  entry.recomputing = false;\n  // Optional callback that will be invoked when entry.parents becomes\n  // empty. The Entry object is given as the first parameter. If the\n  // callback returns true, then this entry can be removed from the graph\n  // and safely recycled into the entryPool.\n  entry.reportOrphan = null;\n}\n\nEntry.acquire = function (fn, key, args) {\n  var entry = entryPool.pop();\n  if (entry) {\n    reset(entry, fn, key, args);\n    return entry;\n  }\n  return new Entry(fn, key, args);\n};\n\nfunction release(entry) {\n  assert(entry.parents.size === 0);\n  assert(entry.childValues.size === 0);\n  assert(entry.dirtyChildren === null);\n  if (entryPool.length < exports.POOL_TARGET_SIZE) {\n    entryPool.push(entry);\n  }\n}\n\nexports.Entry = Entry;\n\nvar Ep = Entry.prototype;\n\n// The public API of Entry objects consists of the Entry constructor,\n// along with the recompute, setDirty, and dispose methods.\n\nEp.recompute = function recompute() {\n  if (! rememberParent(this) &&\n      maybeReportOrphan(this)) {\n    // The recipient of the entry.reportOrphan callback decided to dispose\n    // of this orphan entry by calling entry.dispos(), which recycles it\n    // into the entryPool, so we don't need to (and should not) proceed\n    // with the recomputation.\n    return;\n  }\n\n  return recomputeIfDirty(this);\n};\n\n// If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\nfunction maybeReportOrphan(entry) {\n  var report = entry.reportOrphan;\n  return typeof report === \"function\" &&\n    entry.parents.size === 0 &&\n    report(entry) === true;\n}\n\nEp.setDirty = function setDirty() {\n  if (this.dirty) return;\n  this.dirty = true;\n  this.value = UNKNOWN_VALUE;\n  reportDirty(this);\n  // We can go ahead and unsubscribe here, since any further dirty\n  // notifications we receive will be redundant, and unsubscribing may\n  // free up some resources, e.g. file watchers.\n  unsubscribe(this);\n};\n\nEp.dispose = function dispose() {\n  var entry = this;\n  forgetChildren(entry).forEach(maybeReportOrphan);\n  unsubscribe(entry);\n\n  // Because this entry has been kicked out of the cache (in index.js),\n  // we've lost the ability to find out if/when this entry becomes dirty,\n  // whether that happens through a subscription, because of a direct call\n  // to entry.setDirty(), or because one of its children becomes dirty.\n  // Because of this loss of future information, we have to assume the\n  // worst (that this entry might have become dirty very soon), so we must\n  // immediately mark this entry's parents as dirty. Normally we could\n  // just call entry.setDirty() rather than calling parent.setDirty() for\n  // each parent, but that would leave this entry in parent.childValues\n  // and parent.dirtyChildren, which would prevent the child from being\n  // truly forgotten.\n  entry.parents.forEach(function (parent) {\n    parent.setDirty();\n    forgetChild(parent, entry);\n  });\n\n  // Since this entry has no parents and no children anymore, and the\n  // caller of Entry#dispose has indicated that entry.value no longer\n  // matters, we can safely recycle this Entry object for later use.\n  release(entry);\n};\n\nfunction setClean(entry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(entry) {\n  entry.parents.forEach(function (parent) {\n    reportDirtyChild(parent, entry);\n  });\n}\n\nfunction reportClean(entry) {\n  entry.parents.forEach(function (parent) {\n    reportCleanChild(parent, entry);\n  });\n}\n\nfunction mightBeDirty(entry) {\n  return entry.dirty ||\n    (entry.dirtyChildren &&\n     entry.dirtyChildren.size);\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(entry, child) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(entry.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (! entry.dirtyChildren) {\n    entry.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (entry.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  entry.dirtyChildren.add(child);\n  reportDirty(entry);\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(entry, child) {\n  var cv = entry.childValues;\n\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(cv.has(child));\n  assert(! mightBeDirty(child));\n\n  var childValue = cv.get(child);\n  if (childValue === UNKNOWN_VALUE) {\n    cv.set(child, child.value);\n  } else if (childValue !== child.value) {\n    entry.setDirty();\n  }\n\n  removeDirtyChild(entry, child);\n\n  if (mightBeDirty(entry)) {\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction removeDirtyChild(entry, child) {\n  var dc = entry.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < exports.POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      entry.dirtyChildren = null;\n    }\n  }\n}\n\nfunction rememberParent(entry) {\n  var local = getLocal();\n  var parent = local.currentParentEntry;\n  if (parent) {\n    entry.parents.add(parent);\n\n    if (! parent.childValues.has(entry)) {\n      parent.childValues.set(entry, UNKNOWN_VALUE);\n    }\n\n    if (mightBeDirty(entry)) {\n      reportDirtyChild(parent, entry);\n    } else {\n      reportCleanChild(parent, entry);\n    }\n\n    return parent;\n  }\n}\n\n// This is the most important method of the Entry API, because it\n// determines whether the cached entry.value can be returned immediately,\n// or must be recomputed. The overall performance of the caching system\n// depends on the truth of the following observations: (1) this.dirty is\n// usually false, (2) this.dirtyChildren is usually null/empty, and thus\n// (3) this.value is usally returned very quickly, without recomputation.\nfunction recomputeIfDirty(entry) {\n  if (entry.dirty) {\n    // If this Entry is explicitly dirty because someone called\n    // entry.setDirty(), recompute.\n    return reallyRecompute(entry);\n  }\n\n  if (mightBeDirty(entry)) {\n    // Get fresh values for any dirty children, and if those values\n    // disagree with this.childValues, mark this Entry explicitly dirty.\n    entry.dirtyChildren.forEach(function (child) {\n      assert(entry.childValues.has(child));\n      try {\n        recomputeIfDirty(child);\n      } catch (e) {\n        entry.setDirty();\n      }\n    });\n\n    if (entry.dirty) {\n      // If this Entry has become explicitly dirty after comparing the fresh\n      // values of its dirty children against this.childValues, recompute.\n      return reallyRecompute(entry);\n    }\n  }\n\n  assert(entry.value !== UNKNOWN_VALUE);\n\n  return entry.value;\n}\n\nfunction reallyRecompute(entry) {\n  assert(! entry.recomputing, \"already recomputing\");\n  entry.recomputing = true;\n\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  var originalChildren = forgetChildren(entry);\n\n  var local = getLocal();\n  var parent = local.currentParentEntry;\n  local.currentParentEntry = entry;\n\n  var threw = true;\n  try {\n    entry.value = entry.fn.apply(null, entry.args);\n    threw = false;\n\n  } finally {\n    entry.recomputing = false;\n\n    assert(local.currentParentEntry === entry);\n    local.currentParentEntry = parent;\n\n    if (threw || ! subscribe(entry)) {\n      // Mark this Entry dirty if entry.fn threw or we failed to\n      // resubscribe. This is important because, if we have a subscribe\n      // function and it failed, then we're going to miss important\n      // notifications about the potential dirtiness of entry.value.\n      entry.setDirty();\n    } else {\n      // If we successfully recomputed entry.value and did not fail to\n      // (re)subscribe, then this Entry is no longer explicitly dirty.\n      setClean(entry);\n    }\n  }\n\n  // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n  originalChildren.forEach(maybeReportOrphan);\n\n  return entry.value;\n}\n\nvar reusableEmptyArray = [];\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(entry) {\n  var children = reusableEmptyArray;\n\n  if (entry.childValues.size > 0) {\n    children = [];\n    entry.childValues.forEach(function (value, child) {\n      forgetChild(entry, child);\n      children.push(child);\n    });\n  }\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefor must have been reset to null.\n  assert(entry.dirtyChildren === null);\n\n  return children;\n}\n\nfunction forgetChild(entry, child) {\n  child.parents.delete(entry);\n  entry.childValues.delete(child);\n  removeDirtyChild(entry, child);\n}\n\nfunction subscribe(entry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      unsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n\nfunction unsubscribe(entry) {\n  var unsub = entry.unsubscribe;\n  if (typeof unsub === \"function\") {\n    entry.unsubscribe = null;\n    unsub();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}