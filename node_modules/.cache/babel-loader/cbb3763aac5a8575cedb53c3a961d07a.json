{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.isType = isType;\nexports.assertType = assertType;\nexports.isInputType = isInputType;\nexports.assertInputType = assertInputType;\nexports.isOutputType = isOutputType;\nexports.assertOutputType = assertOutputType;\nexports.isLeafType = isLeafType;\nexports.assertLeafType = assertLeafType;\nexports.isCompositeType = isCompositeType;\nexports.assertCompositeType = assertCompositeType;\nexports.isAbstractType = isAbstractType;\nexports.assertAbstractType = assertAbstractType;\nexports.getNullableType = getNullableType;\nexports.isNamedType = isNamedType;\nexports.assertNamedType = assertNamedType;\nexports.getNamedType = getNamedType;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _isNullish = require('../jsutils/isNullish');\n\nvar _isNullish2 = _interopRequireDefault(_isNullish);\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _assertValidName = require('../utilities/assertValidName');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\n\n\nfunction isType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLList || type instanceof GraphQLNonNull;\n}\n\nfunction assertType(type) {\n  !isType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL type.') : void 0;\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\n\nfunction isInputType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLNonNull && isInputType(type.ofType) || type instanceof GraphQLList && isInputType(type.ofType);\n}\n\nfunction assertInputType(type) {\n  !isInputType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL input type.') : void 0;\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\n\nfunction isOutputType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLNonNull && isOutputType(type.ofType) || type instanceof GraphQLList && isOutputType(type.ofType);\n}\n\nfunction assertOutputType(type) {\n  !isOutputType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL output type.') : void 0;\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\n\nfunction isLeafType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLEnumType;\n}\n\nfunction assertLeafType(type) {\n  !isLeafType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL leaf type.') : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nfunction isCompositeType(type) {\n  return type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n}\n\nfunction assertCompositeType(type) {\n  !isCompositeType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL composite type.') : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nfunction isAbstractType(type) {\n  return type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n}\n\nfunction assertAbstractType(type) {\n  !isAbstractType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL abstract type.') : void 0;\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\n\nfunction getNullableType(type) {\n  return type instanceof GraphQLNonNull ? type.ofType : type;\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\n\nfunction isNamedType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType;\n}\n\nfunction assertNamedType(type) {\n  !isNamedType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL named type.') : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\n\nfunction getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unmodifiedType = type;\n\n    while (unmodifiedType instanceof GraphQLList || unmodifiedType instanceof GraphQLNonNull) {\n      unmodifiedType = unmodifiedType.ofType;\n    }\n\n    return unmodifiedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\n\nfunction resolveThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         return value % 2 === 1 ? value : null;\n *       }\n *     });\n *\n */\n\n\nvar GraphQLScalarType = exports.GraphQLScalarType = function () {\n  function GraphQLScalarType(config) {\n    _classCallCheck(this, GraphQLScalarType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    !(typeof config.serialize === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"serialize\" function. If this custom Scalar ' + 'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.') : void 0;\n\n    if (config.parseValue || config.parseLiteral) {\n      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide both \"parseValue\" and \"parseLiteral\" ' + 'functions.') : void 0;\n    }\n\n    this._scalarConfig = config;\n  } // Serializes an internal value to include in a response.\n\n\n  GraphQLScalarType.prototype.serialize = function serialize(value) {\n    var serializer = this._scalarConfig.serialize;\n    return serializer(value);\n  }; // Determines if an internal value is valid for this type.\n  // Equivalent to checking for if the parsedValue is nullish.\n\n\n  GraphQLScalarType.prototype.isValidValue = function isValidValue(value) {\n    return !(0, _isNullish2.default)(this.parseValue(value));\n  }; // Parses an externally provided value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseValue = function parseValue(value) {\n    var parser = this._scalarConfig.parseValue;\n    return parser && !(0, _isNullish2.default)(value) ? parser(value) : undefined;\n  }; // Determines if an internal value is valid for this type.\n  // Equivalent to checking for if the parsedLiteral is nullish.\n\n\n  GraphQLScalarType.prototype.isValidLiteral = function isValidLiteral(valueNode) {\n    return !(0, _isNullish2.default)(this.parseLiteral(valueNode));\n  }; // Parses an externally provided literal value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseLiteral = function parseLiteral(valueNode) {\n    var parser = this._scalarConfig.parseLiteral;\n    return parser ? parser(valueNode) : undefined;\n  };\n\n  GraphQLScalarType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect = GraphQLScalarType.prototype.toString;\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\n\nvar GraphQLObjectType = exports.GraphQLObjectType = function () {\n  function GraphQLObjectType(config) {\n    _classCallCheck(this, GraphQLObjectType);\n\n    (0, _assertValidName.assertValidName)(config.name, config.isIntrospection);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes || [];\n\n    if (config.isTypeOf) {\n      !(typeof config.isTypeOf === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"isTypeOf\" as a function.') : void 0;\n    }\n\n    this.isTypeOf = config.isTypeOf;\n    this._typeConfig = config;\n  }\n\n  GraphQLObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLObjectType.prototype.getInterfaces = function getInterfaces() {\n    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));\n  };\n\n  GraphQLObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect = GraphQLObjectType.prototype.toString;\n\nfunction defineInterfaces(type, interfacesThunk) {\n  var interfaces = resolveThunk(interfacesThunk);\n\n  if (!interfaces) {\n    return [];\n  }\n\n  !Array.isArray(interfaces) ? (0, _invariant2.default)(0, type.name + ' interfaces must be an Array or a function which returns ' + 'an Array.') : void 0;\n  var implementedTypeNames = Object.create(null);\n  interfaces.forEach(function (iface) {\n    !(iface instanceof GraphQLInterfaceType) ? (0, _invariant2.default)(0, type.name + ' may only implement Interface types, it cannot ' + ('implement: ' + String(iface) + '.')) : void 0;\n    !!implementedTypeNames[iface.name] ? (0, _invariant2.default)(0, type.name + ' may declare it implements ' + iface.name + ' only once.') : void 0;\n    implementedTypeNames[iface.name] = true;\n\n    if (typeof iface.resolveType !== 'function') {\n      !(typeof type.isTypeOf === 'function') ? (0, _invariant2.default)(0, 'Interface Type ' + iface.name + ' does not provide a \"resolveType\" ' + ('function and implementing Type ' + type.name + ' does not provide a ') + '\"isTypeOf\" function. There is no way to resolve this implementing ' + 'type during execution.') : void 0;\n    }\n  });\n  return interfaces;\n}\n\nfunction defineFieldMap(type, fieldsThunk) {\n  var fieldMap = resolveThunk(fieldsThunk);\n  !isPlainObj(fieldMap) ? (0, _invariant2.default)(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n  var fieldNames = Object.keys(fieldMap);\n  !(fieldNames.length > 0) ? (0, _invariant2.default)(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n  fieldNames.forEach(function (fieldName) {\n    (0, _assertValidName.assertValidName)(fieldName);\n    var fieldConfig = fieldMap[fieldName];\n    !isPlainObj(fieldConfig) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field config must be an object') : void 0;\n    !!fieldConfig.hasOwnProperty('isDeprecated') ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n\n    var field = _extends({}, fieldConfig, {\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      name: fieldName\n    });\n\n    !isOutputType(field.type) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field type must be Output Type but ' + ('got: ' + String(field.type) + '.')) : void 0;\n    !isValidResolver(field.resolve) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field resolver must be a function if ' + ('provided, but got: ' + String(field.resolve) + '.')) : void 0;\n    var argsConfig = fieldConfig.args;\n\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      !isPlainObj(argsConfig) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' args must be an object with argument ' + 'names as keys.') : void 0;\n      field.args = Object.keys(argsConfig).map(function (argName) {\n        (0, _assertValidName.assertValidName)(argName);\n        var arg = argsConfig[argName];\n        !isInputType(arg.type) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + String(arg.type) + '.')) : void 0;\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n\n    resultFieldMap[fieldName] = field;\n  });\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);\n} // If a resolver is defined, it must be a function.\n\n\nfunction isValidResolver(resolver) {\n  return resolver == null || typeof resolver === 'function';\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\n\n\nvar GraphQLInterfaceType = exports.GraphQLInterfaceType = function () {\n  function GraphQLInterfaceType(config) {\n    _classCallCheck(this, GraphQLInterfaceType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n  }\n\n  GraphQLInterfaceType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLInterfaceType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect = GraphQLInterfaceType.prototype.toString;\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\n\nvar GraphQLUnionType = exports.GraphQLUnionType = function () {\n  function GraphQLUnionType(config) {\n    _classCallCheck(this, GraphQLUnionType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n  }\n\n  GraphQLUnionType.prototype.getTypes = function getTypes() {\n    return this._types || (this._types = defineTypes(this, this._typeConfig.types));\n  };\n\n  GraphQLUnionType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect = GraphQLUnionType.prototype.toString;\n\nfunction defineTypes(unionType, typesThunk) {\n  var types = resolveThunk(typesThunk);\n  !(Array.isArray(types) && types.length > 0) ? (0, _invariant2.default)(0, 'Must provide Array of types or a function which returns ' + ('such an array for Union ' + unionType.name + '.')) : void 0;\n  var includedTypeNames = Object.create(null);\n  types.forEach(function (objType) {\n    !(objType instanceof GraphQLObjectType) ? (0, _invariant2.default)(0, unionType.name + ' may only contain Object types, it cannot contain: ' + (String(objType) + '.')) : void 0;\n    !!includedTypeNames[objType.name] ? (0, _invariant2.default)(0, unionType.name + ' can include ' + objType.name + ' type only once.') : void 0;\n    includedTypeNames[objType.name] = true;\n\n    if (typeof unionType.resolveType !== 'function') {\n      !(typeof objType.isTypeOf === 'function') ? (0, _invariant2.default)(0, 'Union type \"' + unionType.name + '\" does not provide a \"resolveType\" ' + ('function and possible type \"' + objType.name + '\" does not provide an ') + '\"isTypeOf\" function. There is no way to resolve this possible type ' + 'during execution.') : void 0;\n    }\n  });\n  return types;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\n\nvar GraphQLEnumType\n/* <T> */\n= exports.GraphQLEnumType = function () {\n  function GraphQLEnumType(config\n  /* <T> */\n  ) {\n    _classCallCheck(this, GraphQLEnumType);\n\n    this.name = config.name;\n    (0, _assertValidName.assertValidName)(config.name, config.isIntrospection);\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._values = defineEnumValues(this, config.values);\n    this._enumConfig = config;\n  }\n\n  GraphQLEnumType.prototype.getValues = function getValues() {\n    return this._values;\n  };\n\n  GraphQLEnumType.prototype.getValue = function getValue(name) {\n    return this._getNameLookup()[name];\n  };\n\n  GraphQLEnumType.prototype.serialize = function serialize(value\n  /* T */\n  ) {\n    var enumValue = this._getValueLookup().get(value);\n\n    return enumValue ? enumValue.name : null;\n  };\n\n  GraphQLEnumType.prototype.isValidValue = function isValidValue(value) {\n    return typeof value === 'string' && this._getNameLookup()[value] !== undefined;\n  };\n\n  GraphQLEnumType.prototype.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this._getNameLookup()[value];\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype.isValidLiteral = function isValidLiteral(valueNode) {\n    return valueNode.kind === Kind.ENUM && this._getNameLookup()[valueNode.value] !== undefined;\n  };\n\n  GraphQLEnumType.prototype.parseLiteral = function parseLiteral(valueNode)\n  /* T */\n  {\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this._getNameLookup()[valueNode.value];\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype._getValueLookup = function _getValueLookup() {\n    if (!this._valueLookup) {\n      var lookup = new Map();\n      this.getValues().forEach(function (value) {\n        lookup.set(value.value, value);\n      });\n      this._valueLookup = lookup;\n    }\n\n    return this._valueLookup;\n  };\n\n  GraphQLEnumType.prototype._getNameLookup = function _getNameLookup() {\n    if (!this._nameLookup) {\n      var lookup = Object.create(null);\n      this.getValues().forEach(function (value) {\n        lookup[value.name] = value;\n      });\n      this._nameLookup = lookup;\n    }\n\n    return this._nameLookup;\n  };\n\n  GraphQLEnumType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect = GraphQLEnumType.prototype.toString;\n\nfunction defineEnumValues(type, valueMap\n/* <T> */\n) {\n  !isPlainObj(valueMap) ? (0, _invariant2.default)(0, type.name + ' values must be an object with value names as keys.') : void 0;\n  var valueNames = Object.keys(valueMap);\n  !(valueNames.length > 0) ? (0, _invariant2.default)(0, type.name + ' values must be an object with value names as keys.') : void 0;\n  return valueNames.map(function (valueName) {\n    (0, _assertValidName.assertValidName)(valueName);\n    !(['true', 'false', 'null'].indexOf(valueName) === -1) ? (0, _invariant2.default)(0, 'Name \"' + valueName + '\" can not be used as an Enum value.') : void 0;\n    var value = valueMap[valueName];\n    !isPlainObj(value) ? (0, _invariant2.default)(0, type.name + '.' + valueName + ' must refer to an object with a \"value\" key ' + ('representing an internal value but got: ' + String(value) + '.')) : void 0;\n    !!value.hasOwnProperty('isDeprecated') ? (0, _invariant2.default)(0, type.name + '.' + valueName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n    return {\n      name: valueName,\n      description: value.description,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      astNode: value.astNode,\n      value: value.hasOwnProperty('value') ? value.value : valueName\n    };\n  });\n}\n/* <T> */\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\n\n\nvar GraphQLInputObjectType = exports.GraphQLInputObjectType = function () {\n  function GraphQLInputObjectType(config) {\n    _classCallCheck(this, GraphQLInputObjectType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._typeConfig = config;\n  }\n\n  GraphQLInputObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = this._defineFieldMap());\n  };\n\n  GraphQLInputObjectType.prototype._defineFieldMap = function _defineFieldMap() {\n    var _this = this;\n\n    var fieldMap = resolveThunk(this._typeConfig.fields);\n    !isPlainObj(fieldMap) ? (0, _invariant2.default)(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n    var fieldNames = Object.keys(fieldMap);\n    !(fieldNames.length > 0) ? (0, _invariant2.default)(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n    var resultFieldMap = Object.create(null);\n    fieldNames.forEach(function (fieldName) {\n      (0, _assertValidName.assertValidName)(fieldName);\n\n      var field = _extends({}, fieldMap[fieldName], {\n        name: fieldName\n      });\n\n      !isInputType(field.type) ? (0, _invariant2.default)(0, _this.name + '.' + fieldName + ' field type must be Input Type but ' + ('got: ' + String(field.type) + '.')) : void 0;\n      !(field.resolve == null) ? (0, _invariant2.default)(0, _this.name + '.' + fieldName + ' field type has a resolve property, but ' + 'Input Types cannot define resolvers.') : void 0;\n      resultFieldMap[fieldName] = field;\n    });\n    return resultFieldMap;\n  };\n\n  GraphQLInputObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.inspect = GraphQLInputObjectType.prototype.toString;\n/**\n * List Modifier\n *\n * A list is a kind of type marker, a wrapping type which points to another\n * type. Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: new GraphQLList(Person) },\n *         children: { type: new GraphQLList(Person) },\n *       })\n *     })\n *\n */\n\nvar GraphQLList = exports.GraphQLList = function () {\n  function GraphQLList(type) {\n    _classCallCheck(this, GraphQLList);\n\n    !isType(type) ? (0, _invariant2.default)(0, 'Can only create List of a GraphQLType but got: ' + String(type) + '.') : void 0;\n    this.ofType = type;\n  }\n\n  GraphQLList.prototype.toString = function toString() {\n    return '[' + String(this.ofType) + ']';\n  };\n\n  return GraphQLList;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLList.prototype.toJSON = GraphQLList.prototype.inspect = GraphQLList.prototype.toString;\n/**\n * Non-Null Modifier\n *\n * A non-null is a kind of type marker, a wrapping type which points to another\n * type. Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: new GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\nvar GraphQLNonNull = exports.GraphQLNonNull = function () {\n  function GraphQLNonNull(type) {\n    _classCallCheck(this, GraphQLNonNull);\n\n    !(isType(type) && !(type instanceof GraphQLNonNull)) ? (0, _invariant2.default)(0, 'Can only create NonNull of a Nullable GraphQLType but got: ' + (String(type) + '.')) : void 0;\n    this.ofType = type;\n  }\n\n  GraphQLNonNull.prototype.toString = function toString() {\n    return this.ofType.toString() + '!';\n  };\n\n  return GraphQLNonNull;\n}(); // Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLNonNull.prototype.toJSON = GraphQLNonNull.prototype.inspect = GraphQLNonNull.prototype.toString;","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/type/definition.js"],"names":["Object","defineProperty","exports","value","GraphQLNonNull","GraphQLList","GraphQLInputObjectType","GraphQLEnumType","GraphQLUnionType","GraphQLInterfaceType","GraphQLObjectType","GraphQLScalarType","undefined","_typeof","Symbol","iterator","obj","constructor","prototype","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","call","isType","assertType","isInputType","assertInputType","isOutputType","assertOutputType","isLeafType","assertLeafType","isCompositeType","assertCompositeType","isAbstractType","assertAbstractType","getNullableType","isNamedType","assertNamedType","getNamedType","_invariant","require","_invariant2","_interopRequireDefault","_isNullish","_isNullish2","_kinds","Kind","_interopRequireWildcard","_assertValidName","__esModule","newObj","default","_classCallCheck","instance","Constructor","TypeError","type","String","ofType","unmodifiedType","resolveThunk","thunk","config","assertValidName","name","description","astNode","serialize","parseValue","parseLiteral","_scalarConfig","serializer","isValidValue","parser","isValidLiteral","valueNode","toString","toJSON","inspect","isIntrospection","extensionASTNodes","isTypeOf","_typeConfig","getFields","_fields","defineFieldMap","fields","getInterfaces","_interfaces","defineInterfaces","interfaces","interfacesThunk","Array","isArray","implementedTypeNames","create","forEach","iface","resolveType","fieldsThunk","fieldMap","isPlainObj","fieldNames","keys","resultFieldMap","fieldName","fieldConfig","field","isDeprecated","Boolean","deprecationReason","isValidResolver","resolve","argsConfig","args","map","argName","arg","defaultValue","resolver","getTypes","_types","defineTypes","types","unionType","typesThunk","includedTypeNames","objType","_values","defineEnumValues","values","_enumConfig","getValues","getValue","_getNameLookup","enumValue","_getValueLookup","get","kind","ENUM","_valueLookup","lookup","Map","set","_nameLookup","valueMap","valueNames","valueName","indexOf","_defineFieldMap","_this"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.isType = isType;\nexports.assertType = assertType;\nexports.isInputType = isInputType;\nexports.assertInputType = assertInputType;\nexports.isOutputType = isOutputType;\nexports.assertOutputType = assertOutputType;\nexports.isLeafType = isLeafType;\nexports.assertLeafType = assertLeafType;\nexports.isCompositeType = isCompositeType;\nexports.assertCompositeType = assertCompositeType;\nexports.isAbstractType = isAbstractType;\nexports.assertAbstractType = assertAbstractType;\nexports.getNullableType = getNullableType;\nexports.isNamedType = isNamedType;\nexports.assertNamedType = assertNamedType;\nexports.getNamedType = getNamedType;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _isNullish = require('../jsutils/isNullish');\n\nvar _isNullish2 = _interopRequireDefault(_isNullish);\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _assertValidName = require('../utilities/assertValidName');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           * \n                                                                                                                                                           */\n\n// Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\nfunction isType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLList || type instanceof GraphQLNonNull;\n}\n\nfunction assertType(type) {\n  !isType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL type.') : void 0;\n  return type;\n}\n\n/**\n * These types may be used as input types for arguments and directives.\n */\nfunction isInputType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType || type instanceof GraphQLNonNull && isInputType(type.ofType) || type instanceof GraphQLList && isInputType(type.ofType);\n}\n\nfunction assertInputType(type) {\n  !isInputType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL input type.') : void 0;\n  return type;\n}\n\n/**\n * These types may be used as output types as the result of fields.\n */\nfunction isOutputType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLNonNull && isOutputType(type.ofType) || type instanceof GraphQLList && isOutputType(type.ofType);\n}\n\nfunction assertOutputType(type) {\n  !isOutputType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL output type.') : void 0;\n  return type;\n}\n\n/**\n * These types may describe types which may be leaf values.\n */\nfunction isLeafType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLEnumType;\n}\n\nfunction assertLeafType(type) {\n  !isLeafType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL leaf type.') : void 0;\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nfunction isCompositeType(type) {\n  return type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n}\n\nfunction assertCompositeType(type) {\n  !isCompositeType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL composite type.') : void 0;\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nfunction isAbstractType(type) {\n  return type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType;\n}\n\nfunction assertAbstractType(type) {\n  !isAbstractType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL abstract type.') : void 0;\n  return type;\n}\n\n/**\n * These types can all accept null as a value.\n */\nfunction getNullableType(type) {\n  return type instanceof GraphQLNonNull ? type.ofType : type;\n}\n\n/**\n * These named types do not include modifiers like List or NonNull.\n */\nfunction isNamedType(type) {\n  return type instanceof GraphQLScalarType || type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType || type instanceof GraphQLUnionType || type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType;\n}\n\nfunction assertNamedType(type) {\n  !isNamedType(type) ? (0, _invariant2.default)(0, 'Expected ' + String(type) + ' to be a GraphQL named type.') : void 0;\n  return type;\n}\n\n/* eslint-disable no-redeclare */\nfunction getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unmodifiedType = type;\n    while (unmodifiedType instanceof GraphQLList || unmodifiedType instanceof GraphQLNonNull) {\n      unmodifiedType = unmodifiedType.ofType;\n    }\n    return unmodifiedType;\n  }\n}\n\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\n\nfunction resolveThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         return value % 2 === 1 ? value : null;\n *       }\n *     });\n *\n */\n\nvar GraphQLScalarType = exports.GraphQLScalarType = function () {\n  function GraphQLScalarType(config) {\n    _classCallCheck(this, GraphQLScalarType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    !(typeof config.serialize === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"serialize\" function. If this custom Scalar ' + 'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.') : void 0;\n    if (config.parseValue || config.parseLiteral) {\n      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide both \"parseValue\" and \"parseLiteral\" ' + 'functions.') : void 0;\n    }\n    this._scalarConfig = config;\n  }\n\n  // Serializes an internal value to include in a response.\n\n\n  GraphQLScalarType.prototype.serialize = function serialize(value) {\n    var serializer = this._scalarConfig.serialize;\n    return serializer(value);\n  };\n\n  // Determines if an internal value is valid for this type.\n  // Equivalent to checking for if the parsedValue is nullish.\n\n\n  GraphQLScalarType.prototype.isValidValue = function isValidValue(value) {\n    return !(0, _isNullish2.default)(this.parseValue(value));\n  };\n\n  // Parses an externally provided value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseValue = function parseValue(value) {\n    var parser = this._scalarConfig.parseValue;\n    return parser && !(0, _isNullish2.default)(value) ? parser(value) : undefined;\n  };\n\n  // Determines if an internal value is valid for this type.\n  // Equivalent to checking for if the parsedLiteral is nullish.\n\n\n  GraphQLScalarType.prototype.isValidLiteral = function isValidLiteral(valueNode) {\n    return !(0, _isNullish2.default)(this.parseLiteral(valueNode));\n  };\n\n  // Parses an externally provided literal value to use as an input.\n\n\n  GraphQLScalarType.prototype.parseLiteral = function parseLiteral(valueNode) {\n    var parser = this._scalarConfig.parseLiteral;\n    return parser ? parser(valueNode) : undefined;\n  };\n\n  GraphQLScalarType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect = GraphQLScalarType.prototype.toString;\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nvar GraphQLObjectType = exports.GraphQLObjectType = function () {\n  function GraphQLObjectType(config) {\n    _classCallCheck(this, GraphQLObjectType);\n\n    (0, _assertValidName.assertValidName)(config.name, config.isIntrospection);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes || [];\n    if (config.isTypeOf) {\n      !(typeof config.isTypeOf === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"isTypeOf\" as a function.') : void 0;\n    }\n    this.isTypeOf = config.isTypeOf;\n    this._typeConfig = config;\n  }\n\n  GraphQLObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLObjectType.prototype.getInterfaces = function getInterfaces() {\n    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));\n  };\n\n  GraphQLObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect = GraphQLObjectType.prototype.toString;\n\nfunction defineInterfaces(type, interfacesThunk) {\n  var interfaces = resolveThunk(interfacesThunk);\n  if (!interfaces) {\n    return [];\n  }\n  !Array.isArray(interfaces) ? (0, _invariant2.default)(0, type.name + ' interfaces must be an Array or a function which returns ' + 'an Array.') : void 0;\n\n  var implementedTypeNames = Object.create(null);\n  interfaces.forEach(function (iface) {\n    !(iface instanceof GraphQLInterfaceType) ? (0, _invariant2.default)(0, type.name + ' may only implement Interface types, it cannot ' + ('implement: ' + String(iface) + '.')) : void 0;\n    !!implementedTypeNames[iface.name] ? (0, _invariant2.default)(0, type.name + ' may declare it implements ' + iface.name + ' only once.') : void 0;\n    implementedTypeNames[iface.name] = true;\n    if (typeof iface.resolveType !== 'function') {\n      !(typeof type.isTypeOf === 'function') ? (0, _invariant2.default)(0, 'Interface Type ' + iface.name + ' does not provide a \"resolveType\" ' + ('function and implementing Type ' + type.name + ' does not provide a ') + '\"isTypeOf\" function. There is no way to resolve this implementing ' + 'type during execution.') : void 0;\n    }\n  });\n  return interfaces;\n}\n\nfunction defineFieldMap(type, fieldsThunk) {\n  var fieldMap = resolveThunk(fieldsThunk);\n  !isPlainObj(fieldMap) ? (0, _invariant2.default)(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n\n  var fieldNames = Object.keys(fieldMap);\n  !(fieldNames.length > 0) ? (0, _invariant2.default)(0, type.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n\n  var resultFieldMap = Object.create(null);\n  fieldNames.forEach(function (fieldName) {\n    (0, _assertValidName.assertValidName)(fieldName);\n    var fieldConfig = fieldMap[fieldName];\n    !isPlainObj(fieldConfig) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field config must be an object') : void 0;\n    !!fieldConfig.hasOwnProperty('isDeprecated') ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n    var field = _extends({}, fieldConfig, {\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      name: fieldName\n    });\n    !isOutputType(field.type) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field type must be Output Type but ' + ('got: ' + String(field.type) + '.')) : void 0;\n    !isValidResolver(field.resolve) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' field resolver must be a function if ' + ('provided, but got: ' + String(field.resolve) + '.')) : void 0;\n    var argsConfig = fieldConfig.args;\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      !isPlainObj(argsConfig) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + ' args must be an object with argument ' + 'names as keys.') : void 0;\n      field.args = Object.keys(argsConfig).map(function (argName) {\n        (0, _assertValidName.assertValidName)(argName);\n        var arg = argsConfig[argName];\n        !isInputType(arg.type) ? (0, _invariant2.default)(0, type.name + '.' + fieldName + '(' + argName + ':) argument type must be ' + ('Input Type but got: ' + String(arg.type) + '.')) : void 0;\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n    resultFieldMap[fieldName] = field;\n  });\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);\n}\n\n// If a resolver is defined, it must be a function.\nfunction isValidResolver(resolver) {\n  return resolver == null || typeof resolver === 'function';\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nvar GraphQLInterfaceType = exports.GraphQLInterfaceType = function () {\n  function GraphQLInterfaceType(config) {\n    _classCallCheck(this, GraphQLInterfaceType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n  }\n\n  GraphQLInterfaceType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  };\n\n  GraphQLInterfaceType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect = GraphQLInterfaceType.prototype.toString;\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nvar GraphQLUnionType = exports.GraphQLUnionType = function () {\n  function GraphQLUnionType(config) {\n    _classCallCheck(this, GraphQLUnionType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    if (config.resolveType) {\n      !(typeof config.resolveType === 'function') ? (0, _invariant2.default)(0, this.name + ' must provide \"resolveType\" as a function.') : void 0;\n    }\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n  }\n\n  GraphQLUnionType.prototype.getTypes = function getTypes() {\n    return this._types || (this._types = defineTypes(this, this._typeConfig.types));\n  };\n\n  GraphQLUnionType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect = GraphQLUnionType.prototype.toString;\n\nfunction defineTypes(unionType, typesThunk) {\n  var types = resolveThunk(typesThunk);\n\n  !(Array.isArray(types) && types.length > 0) ? (0, _invariant2.default)(0, 'Must provide Array of types or a function which returns ' + ('such an array for Union ' + unionType.name + '.')) : void 0;\n  var includedTypeNames = Object.create(null);\n  types.forEach(function (objType) {\n    !(objType instanceof GraphQLObjectType) ? (0, _invariant2.default)(0, unionType.name + ' may only contain Object types, it cannot contain: ' + (String(objType) + '.')) : void 0;\n    !!includedTypeNames[objType.name] ? (0, _invariant2.default)(0, unionType.name + ' can include ' + objType.name + ' type only once.') : void 0;\n    includedTypeNames[objType.name] = true;\n    if (typeof unionType.resolveType !== 'function') {\n      !(typeof objType.isTypeOf === 'function') ? (0, _invariant2.default)(0, 'Union type \"' + unionType.name + '\" does not provide a \"resolveType\" ' + ('function and possible type \"' + objType.name + '\" does not provide an ') + '\"isTypeOf\" function. There is no way to resolve this possible type ' + 'during execution.') : void 0;\n    }\n  });\n\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nvar GraphQLEnumType /* <T> */ = exports.GraphQLEnumType = function () {\n  function GraphQLEnumType(config /* <T> */) {\n    _classCallCheck(this, GraphQLEnumType);\n\n    this.name = config.name;\n    (0, _assertValidName.assertValidName)(config.name, config.isIntrospection);\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._values = defineEnumValues(this, config.values);\n    this._enumConfig = config;\n  }\n\n  GraphQLEnumType.prototype.getValues = function getValues() {\n    return this._values;\n  };\n\n  GraphQLEnumType.prototype.getValue = function getValue(name) {\n    return this._getNameLookup()[name];\n  };\n\n  GraphQLEnumType.prototype.serialize = function serialize(value /* T */) {\n    var enumValue = this._getValueLookup().get(value);\n    return enumValue ? enumValue.name : null;\n  };\n\n  GraphQLEnumType.prototype.isValidValue = function isValidValue(value) {\n    return typeof value === 'string' && this._getNameLookup()[value] !== undefined;\n  };\n\n  GraphQLEnumType.prototype.parseValue = function parseValue(value) /* T */{\n    if (typeof value === 'string') {\n      var enumValue = this._getNameLookup()[value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype.isValidLiteral = function isValidLiteral(valueNode) {\n    return valueNode.kind === Kind.ENUM && this._getNameLookup()[valueNode.value] !== undefined;\n  };\n\n  GraphQLEnumType.prototype.parseLiteral = function parseLiteral(valueNode) /* T */{\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this._getNameLookup()[valueNode.value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  GraphQLEnumType.prototype._getValueLookup = function _getValueLookup() {\n    if (!this._valueLookup) {\n      var lookup = new Map();\n      this.getValues().forEach(function (value) {\n        lookup.set(value.value, value);\n      });\n      this._valueLookup = lookup;\n    }\n    return this._valueLookup;\n  };\n\n  GraphQLEnumType.prototype._getNameLookup = function _getNameLookup() {\n    if (!this._nameLookup) {\n      var lookup = Object.create(null);\n      this.getValues().forEach(function (value) {\n        lookup[value.name] = value;\n      });\n      this._nameLookup = lookup;\n    }\n    return this._nameLookup;\n  };\n\n  GraphQLEnumType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect = GraphQLEnumType.prototype.toString;\n\nfunction defineEnumValues(type, valueMap /* <T> */\n) {\n  !isPlainObj(valueMap) ? (0, _invariant2.default)(0, type.name + ' values must be an object with value names as keys.') : void 0;\n  var valueNames = Object.keys(valueMap);\n  !(valueNames.length > 0) ? (0, _invariant2.default)(0, type.name + ' values must be an object with value names as keys.') : void 0;\n  return valueNames.map(function (valueName) {\n    (0, _assertValidName.assertValidName)(valueName);\n    !(['true', 'false', 'null'].indexOf(valueName) === -1) ? (0, _invariant2.default)(0, 'Name \"' + valueName + '\" can not be used as an Enum value.') : void 0;\n\n    var value = valueMap[valueName];\n    !isPlainObj(value) ? (0, _invariant2.default)(0, type.name + '.' + valueName + ' must refer to an object with a \"value\" key ' + ('representing an internal value but got: ' + String(value) + '.')) : void 0;\n    !!value.hasOwnProperty('isDeprecated') ? (0, _invariant2.default)(0, type.name + '.' + valueName + ' should provide \"deprecationReason\" instead ' + 'of \"isDeprecated\".') : void 0;\n    return {\n      name: valueName,\n      description: value.description,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      astNode: value.astNode,\n      value: value.hasOwnProperty('value') ? value.value : valueName\n    };\n  });\n} /* <T> */\n\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nvar GraphQLInputObjectType = exports.GraphQLInputObjectType = function () {\n  function GraphQLInputObjectType(config) {\n    _classCallCheck(this, GraphQLInputObjectType);\n\n    (0, _assertValidName.assertValidName)(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this._typeConfig = config;\n  }\n\n  GraphQLInputObjectType.prototype.getFields = function getFields() {\n    return this._fields || (this._fields = this._defineFieldMap());\n  };\n\n  GraphQLInputObjectType.prototype._defineFieldMap = function _defineFieldMap() {\n    var _this = this;\n\n    var fieldMap = resolveThunk(this._typeConfig.fields);\n    !isPlainObj(fieldMap) ? (0, _invariant2.default)(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n    var fieldNames = Object.keys(fieldMap);\n    !(fieldNames.length > 0) ? (0, _invariant2.default)(0, this.name + ' fields must be an object with field names as keys or a ' + 'function which returns such an object.') : void 0;\n    var resultFieldMap = Object.create(null);\n    fieldNames.forEach(function (fieldName) {\n      (0, _assertValidName.assertValidName)(fieldName);\n      var field = _extends({}, fieldMap[fieldName], {\n        name: fieldName\n      });\n      !isInputType(field.type) ? (0, _invariant2.default)(0, _this.name + '.' + fieldName + ' field type must be Input Type but ' + ('got: ' + String(field.type) + '.')) : void 0;\n      !(field.resolve == null) ? (0, _invariant2.default)(0, _this.name + '.' + fieldName + ' field type has a resolve property, but ' + 'Input Types cannot define resolvers.') : void 0;\n      resultFieldMap[fieldName] = field;\n    });\n    return resultFieldMap;\n  };\n\n  GraphQLInputObjectType.prototype.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.inspect = GraphQLInputObjectType.prototype.toString;\n\n/**\n * List Modifier\n *\n * A list is a kind of type marker, a wrapping type which points to another\n * type. Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: new GraphQLList(Person) },\n *         children: { type: new GraphQLList(Person) },\n *       })\n *     })\n *\n */\nvar GraphQLList = exports.GraphQLList = function () {\n  function GraphQLList(type) {\n    _classCallCheck(this, GraphQLList);\n\n    !isType(type) ? (0, _invariant2.default)(0, 'Can only create List of a GraphQLType but got: ' + String(type) + '.') : void 0;\n    this.ofType = type;\n  }\n\n  GraphQLList.prototype.toString = function toString() {\n    return '[' + String(this.ofType) + ']';\n  };\n\n  return GraphQLList;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLList.prototype.toJSON = GraphQLList.prototype.inspect = GraphQLList.prototype.toString;\n\n/**\n * Non-Null Modifier\n *\n * A non-null is a kind of type marker, a wrapping type which points to another\n * type. Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: new GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\nvar GraphQLNonNull = exports.GraphQLNonNull = function () {\n  function GraphQLNonNull(type) {\n    _classCallCheck(this, GraphQLNonNull);\n\n    !(isType(type) && !(type instanceof GraphQLNonNull)) ? (0, _invariant2.default)(0, 'Can only create NonNull of a Nullable GraphQLType but got: ' + (String(type) + '.')) : void 0;\n    this.ofType = type;\n  }\n\n  GraphQLNonNull.prototype.toString = function toString() {\n    return this.ofType.toString() + '!';\n  };\n\n  return GraphQLNonNull;\n}();\n\n// Also provide toJSON and inspect aliases for toString.\n\n\nGraphQLNonNull.prototype.toJSON = GraphQLNonNull.prototype.inspect = GraphQLNonNull.prototype.toString;"]},"metadata":{},"sourceType":"script"}