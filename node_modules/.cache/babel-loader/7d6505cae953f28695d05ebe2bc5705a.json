{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildClientSchema = buildClientSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyMap = require('../jsutils/keyMap');\n\nvar _keyMap2 = _interopRequireDefault(_keyMap);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _parser = require('../language/parser');\n\nvar _schema = require('../type/schema');\n\nvar _definition = require('../type/definition');\n\nvar _introspection = require('../type/introspection');\n\nvar _scalars = require('../type/scalars');\n\nvar _directives = require('../type/directives');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n */\n\n\nfunction buildClientSchema(introspection) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = (0, _keyMap2.default)(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  }; // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new _definition.GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !(0, _definition.isInputType)(type) ? (0, _invariant2.default)(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !(0, _definition.isOutputType)(type) ? (0, _invariant2.default)(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Introspection must provide object type for possibleTypes.') : void 0;\n    return type;\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Introspection must provide interface type for interfaces.') : void 0;\n    return type;\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    switch (type.kind) {\n      case _introspection.TypeKind.SCALAR:\n        return buildScalarDef(type);\n\n      case _introspection.TypeKind.OBJECT:\n        return buildObjectDef(type);\n\n      case _introspection.TypeKind.INTERFACE:\n        return buildInterfaceDef(type);\n\n      case _introspection.TypeKind.UNION:\n        return buildUnionDef(type);\n\n      case _introspection.TypeKind.ENUM:\n        return buildEnumDef(type);\n\n      case _introspection.TypeKind.INPUT_OBJECT:\n        return buildInputObjectDef(type);\n\n      default:\n        throw new Error('Invalid or incomplete schema, unknown kind: ' + type.kind + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(id) {\n        return id;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      },\n      resolveType: cannotExecuteClientSchema\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType),\n      resolveType: cannotExecuteClientSchema\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap2.default)(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    return (0, _keyValMap2.default)(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap2.default)(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      name: inputValueIntrospection.name,\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    // Support deprecated `on****` fields for building `locations`, as this\n    // is used by GraphiQL which may need to support outdated servers.\n    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [_directives.DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [_directives.DirectiveLocation.QUERY, _directives.DirectiveLocation.MUTATION, _directives.DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [_directives.DirectiveLocation.FRAGMENT_DEFINITION, _directives.DirectiveLocation.FRAGMENT_SPREAD, _directives.DirectiveLocation.INLINE_FRAGMENT]);\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: locations,\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = getObjectType(schemaIntrospection.queryType);\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives\n  });\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction cannotExecuteClientSchema() {\n  throw new Error('Client Schema cannot use Interface or Union types for execution.');\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/utilities/buildClientSchema.js"],"names":["Object","defineProperty","exports","value","buildClientSchema","_invariant","require","_invariant2","_interopRequireDefault","_keyMap","_keyMap2","_keyValMap","_keyValMap2","_valueFromAST","_parser","_schema","_definition","_introspection","_scalars","_directives","obj","__esModule","default","introspection","schemaIntrospection","__schema","typeIntrospectionMap","types","type","name","typeDefCache","String","GraphQLString","Int","GraphQLInt","Float","GraphQLFloat","Boolean","GraphQLBoolean","ID","GraphQLID","__Schema","__Directive","__DirectiveLocation","__Type","__Field","__InputValue","__EnumValue","__TypeKind","getType","typeRef","kind","TypeKind","LIST","itemRef","ofType","Error","GraphQLList","NON_NULL","nullableRef","nullableType","GraphQLNonNull","getNamedType","typeName","typeIntrospection","typeDef","buildType","getInputType","isInputType","getOutputType","isOutputType","getObjectType","GraphQLObjectType","getInterfaceType","GraphQLInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","scalarIntrospection","GraphQLScalarType","description","serialize","id","parseValue","parseLiteral","objectIntrospection","interfaces","map","fields","buildFieldDefMap","interfaceIntrospection","resolveType","cannotExecuteClientSchema","unionIntrospection","GraphQLUnionType","possibleTypes","enumIntrospection","GraphQLEnumType","values","enumValues","valueIntrospection","deprecationReason","inputObjectIntrospection","GraphQLInputObjectType","buildInputValueDefMap","inputFields","fieldIntrospection","args","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","valueFromAST","undefined","buildDirective","directiveIntrospection","locations","slice","concat","onField","DirectiveLocation","FIELD","onOperation","QUERY","MUTATION","SUBSCRIPTION","onFragment","FRAGMENT_DEFINITION","FRAGMENT_SPREAD","INLINE_FRAGMENT","GraphQLDirective","queryType","mutationType","subscriptionType","directives","GraphQLSchema","query","mutation","subscription"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AAEA,IAAIC,WAAW,GAAGC,sBAAsB,CAACH,UAAD,CAAxC;;AAEA,IAAII,OAAO,GAAGH,OAAO,CAAC,mBAAD,CAArB;;AAEA,IAAII,QAAQ,GAAGF,sBAAsB,CAACC,OAAD,CAArC;;AAEA,IAAIE,UAAU,GAAGL,OAAO,CAAC,sBAAD,CAAxB;;AAEA,IAAIM,WAAW,GAAGJ,sBAAsB,CAACG,UAAD,CAAxC;;AAEA,IAAIE,aAAa,GAAGP,OAAO,CAAC,gBAAD,CAA3B;;AAEA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,oBAAD,CAArB;;AAEA,IAAIS,OAAO,GAAGT,OAAO,CAAC,gBAAD,CAArB;;AAEA,IAAIU,WAAW,GAAGV,OAAO,CAAC,oBAAD,CAAzB;;AAEA,IAAIW,cAAc,GAAGX,OAAO,CAAC,uBAAD,CAA5B;;AAEA,IAAIY,QAAQ,GAAGZ,OAAO,CAAC,iBAAD,CAAtB;;AAEA,IAAIa,WAAW,GAAGb,OAAO,CAAC,oBAAD,CAAzB;;AAEA,SAASE,sBAAT,CAAgCY,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAShB,iBAAT,CAA2BmB,aAA3B,EAA0C;AAExC;AACA,MAAIC,mBAAmB,GAAGD,aAAa,CAACE,QAAxC,CAHwC,CAKxC;;AACA,MAAIC,oBAAoB,GAAG,CAAC,GAAGhB,QAAQ,CAACY,OAAb,EAAsBE,mBAAmB,CAACG,KAA1C,EAAiD,UAAUC,IAAV,EAAgB;AAC1F,WAAOA,IAAI,CAACC,IAAZ;AACD,GAF0B,CAA3B,CANwC,CAUxC;AACA;AACA;;AACA,MAAIC,YAAY,GAAG;AACjBC,IAAAA,MAAM,EAAEb,QAAQ,CAACc,aADA;AAEjBC,IAAAA,GAAG,EAAEf,QAAQ,CAACgB,UAFG;AAGjBC,IAAAA,KAAK,EAAEjB,QAAQ,CAACkB,YAHC;AAIjBC,IAAAA,OAAO,EAAEnB,QAAQ,CAACoB,cAJD;AAKjBC,IAAAA,EAAE,EAAErB,QAAQ,CAACsB,SALI;AAMjBC,IAAAA,QAAQ,EAAExB,cAAc,CAACwB,QANR;AAOjBC,IAAAA,WAAW,EAAEzB,cAAc,CAACyB,WAPX;AAQjBC,IAAAA,mBAAmB,EAAE1B,cAAc,CAAC0B,mBARnB;AASjBC,IAAAA,MAAM,EAAE3B,cAAc,CAAC2B,MATN;AAUjBC,IAAAA,OAAO,EAAE5B,cAAc,CAAC4B,OAVP;AAWjBC,IAAAA,YAAY,EAAE7B,cAAc,CAAC6B,YAXZ;AAYjBC,IAAAA,WAAW,EAAE9B,cAAc,CAAC8B,WAZX;AAajBC,IAAAA,UAAU,EAAE/B,cAAc,CAAC+B;AAbV,GAAnB,CAbwC,CA6BxC;AACA;;AACA,WAASC,OAAT,CAAiBC,OAAjB,EAA0B;AACxB,QAAIA,OAAO,CAACC,IAAR,KAAiBlC,cAAc,CAACmC,QAAf,CAAwBC,IAA7C,EAAmD;AACjD,UAAIC,OAAO,GAAGJ,OAAO,CAACK,MAAtB;;AACA,UAAI,CAACD,OAAL,EAAc;AACZ,cAAM,IAAIE,KAAJ,CAAU,iDAAV,CAAN;AACD;;AACD,aAAO,IAAIxC,WAAW,CAACyC,WAAhB,CAA4BR,OAAO,CAACK,OAAD,CAAnC,CAAP;AACD;;AACD,QAAIJ,OAAO,CAACC,IAAR,KAAiBlC,cAAc,CAACmC,QAAf,CAAwBM,QAA7C,EAAuD;AACrD,UAAIC,WAAW,GAAGT,OAAO,CAACK,MAA1B;;AACA,UAAI,CAACI,WAAL,EAAkB;AAChB,cAAM,IAAIH,KAAJ,CAAU,iDAAV,CAAN;AACD;;AACD,UAAII,YAAY,GAAGX,OAAO,CAACU,WAAD,CAA1B;AACA,OAAC,EAAEC,YAAY,YAAY5C,WAAW,CAAC6C,cAAtC,CAAD,GAAyD,CAAC,GAAGtD,WAAW,CAACe,OAAhB,EAAyB,CAAzB,EAA4B,qBAA5B,CAAzD,GAA8G,KAAK,CAAnH;AACA,aAAO,IAAIN,WAAW,CAAC6C,cAAhB,CAA+BD,YAA/B,CAAP;AACD;;AACD,WAAOE,YAAY,CAACZ,OAAO,CAACrB,IAAT,CAAnB;AACD;;AAED,WAASiC,YAAT,CAAsBC,QAAtB,EAAgC;AAC9B,QAAIjC,YAAY,CAACiC,QAAD,CAAhB,EAA4B;AAC1B,aAAOjC,YAAY,CAACiC,QAAD,CAAnB;AACD;;AACD,QAAIC,iBAAiB,GAAGtC,oBAAoB,CAACqC,QAAD,CAA5C;;AACA,QAAI,CAACC,iBAAL,EAAwB;AACtB,YAAM,IAAIR,KAAJ,CAAU,iDAAiDO,QAAjD,GAA4D,WAA5D,GAA0E,8DAA1E,GAA2I,gBAArJ,CAAN;AACD;;AACD,QAAIE,OAAO,GAAGC,SAAS,CAACF,iBAAD,CAAvB;AACAlC,IAAAA,YAAY,CAACiC,QAAD,CAAZ,GAAyBE,OAAzB;AACA,WAAOA,OAAP;AACD;;AAED,WAASE,YAAT,CAAsBjB,OAAtB,EAA+B;AAC7B,QAAItB,IAAI,GAAGqB,OAAO,CAACC,OAAD,CAAlB;AACA,KAAC,CAAC,GAAGlC,WAAW,CAACoD,WAAhB,EAA6BxC,IAA7B,CAAD,GAAsC,CAAC,GAAGrB,WAAW,CAACe,OAAhB,EAAyB,CAAzB,EAA4B,sDAA5B,CAAtC,GAA4H,KAAK,CAAjI;AACA,WAAOM,IAAP;AACD;;AAED,WAASyC,aAAT,CAAuBnB,OAAvB,EAAgC;AAC9B,QAAItB,IAAI,GAAGqB,OAAO,CAACC,OAAD,CAAlB;AACA,KAAC,CAAC,GAAGlC,WAAW,CAACsD,YAAhB,EAA8B1C,IAA9B,CAAD,GAAuC,CAAC,GAAGrB,WAAW,CAACe,OAAhB,EAAyB,CAAzB,EAA4B,oDAA5B,CAAvC,GAA2H,KAAK,CAAhI;AACA,WAAOM,IAAP;AACD;;AAED,WAAS2C,aAAT,CAAuBrB,OAAvB,EAAgC;AAC9B,QAAItB,IAAI,GAAGqB,OAAO,CAACC,OAAD,CAAlB;AACA,MAAEtB,IAAI,YAAYZ,WAAW,CAACwD,iBAA9B,IAAmD,CAAC,GAAGjE,WAAW,CAACe,OAAhB,EAAyB,CAAzB,EAA4B,2DAA5B,CAAnD,GAA8I,KAAK,CAAnJ;AACA,WAAOM,IAAP;AACD;;AAED,WAAS6C,gBAAT,CAA0BvB,OAA1B,EAAmC;AACjC,QAAItB,IAAI,GAAGqB,OAAO,CAACC,OAAD,CAAlB;AACA,MAAEtB,IAAI,YAAYZ,WAAW,CAAC0D,oBAA9B,IAAsD,CAAC,GAAGnE,WAAW,CAACe,OAAhB,EAAyB,CAAzB,EAA4B,2DAA5B,CAAtD,GAAiJ,KAAK,CAAtJ;AACA,WAAOM,IAAP;AACD,GAtFuC,CAwFxC;AACA;;;AACA,WAASsC,SAAT,CAAmBtC,IAAnB,EAAyB;AACvB,YAAQA,IAAI,CAACuB,IAAb;AACE,WAAKlC,cAAc,CAACmC,QAAf,CAAwBuB,MAA7B;AACE,eAAOC,cAAc,CAAChD,IAAD,CAArB;;AACF,WAAKX,cAAc,CAACmC,QAAf,CAAwByB,MAA7B;AACE,eAAOC,cAAc,CAAClD,IAAD,CAArB;;AACF,WAAKX,cAAc,CAACmC,QAAf,CAAwB2B,SAA7B;AACE,eAAOC,iBAAiB,CAACpD,IAAD,CAAxB;;AACF,WAAKX,cAAc,CAACmC,QAAf,CAAwB6B,KAA7B;AACE,eAAOC,aAAa,CAACtD,IAAD,CAApB;;AACF,WAAKX,cAAc,CAACmC,QAAf,CAAwB+B,IAA7B;AACE,eAAOC,YAAY,CAACxD,IAAD,CAAnB;;AACF,WAAKX,cAAc,CAACmC,QAAf,CAAwBiC,YAA7B;AACE,eAAOC,mBAAmB,CAAC1D,IAAD,CAA1B;;AACF;AACE,cAAM,IAAI4B,KAAJ,CAAU,iDAAiD5B,IAAI,CAACuB,IAAtD,GAA6D,WAA7D,GAA2E,8DAA3E,GAA4I,gBAAtJ,CAAN;AAdJ;AAgBD;;AAED,WAASyB,cAAT,CAAwBW,mBAAxB,EAA6C;AAC3C,WAAO,IAAIvE,WAAW,CAACwE,iBAAhB,CAAkC;AACvC3D,MAAAA,IAAI,EAAE0D,mBAAmB,CAAC1D,IADa;AAEvC4D,MAAAA,WAAW,EAAEF,mBAAmB,CAACE,WAFM;AAGvCC,MAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBC,EAAnB,EAAuB;AAChC,eAAOA,EAAP;AACD,OALsC;AAMvC;AACA;AACA;AACA;AACAC,MAAAA,UAAU,EAAE,SAASA,UAAT,GAAsB;AAChC,eAAO,KAAP;AACD,OAZsC;AAavCC,MAAAA,YAAY,EAAE,SAASA,YAAT,GAAwB;AACpC,eAAO,KAAP;AACD;AAfsC,KAAlC,CAAP;AAiBD;;AAED,WAASf,cAAT,CAAwBgB,mBAAxB,EAA6C;AAC3C,WAAO,IAAI9E,WAAW,CAACwD,iBAAhB,CAAkC;AACvC3C,MAAAA,IAAI,EAAEiE,mBAAmB,CAACjE,IADa;AAEvC4D,MAAAA,WAAW,EAAEK,mBAAmB,CAACL,WAFM;AAGvCM,MAAAA,UAAU,EAAED,mBAAmB,CAACC,UAApB,CAA+BC,GAA/B,CAAmCvB,gBAAnC,CAH2B;AAIvCwB,MAAAA,MAAM,EAAE,SAASA,MAAT,GAAkB;AACxB,eAAOC,gBAAgB,CAACJ,mBAAD,CAAvB;AACD;AANsC,KAAlC,CAAP;AAQD;;AAED,WAASd,iBAAT,CAA2BmB,sBAA3B,EAAmD;AACjD,WAAO,IAAInF,WAAW,CAAC0D,oBAAhB,CAAqC;AAC1C7C,MAAAA,IAAI,EAAEsE,sBAAsB,CAACtE,IADa;AAE1C4D,MAAAA,WAAW,EAAEU,sBAAsB,CAACV,WAFM;AAG1CQ,MAAAA,MAAM,EAAE,SAASA,MAAT,GAAkB;AACxB,eAAOC,gBAAgB,CAACC,sBAAD,CAAvB;AACD,OALyC;AAM1CC,MAAAA,WAAW,EAAEC;AAN6B,KAArC,CAAP;AAQD;;AAED,WAASnB,aAAT,CAAuBoB,kBAAvB,EAA2C;AACzC,WAAO,IAAItF,WAAW,CAACuF,gBAAhB,CAAiC;AACtC1E,MAAAA,IAAI,EAAEyE,kBAAkB,CAACzE,IADa;AAEtC4D,MAAAA,WAAW,EAAEa,kBAAkB,CAACb,WAFM;AAGtC9D,MAAAA,KAAK,EAAE2E,kBAAkB,CAACE,aAAnB,CAAiCR,GAAjC,CAAqCzB,aAArC,CAH+B;AAItC6B,MAAAA,WAAW,EAAEC;AAJyB,KAAjC,CAAP;AAMD;;AAED,WAASjB,YAAT,CAAsBqB,iBAAtB,EAAyC;AACvC,WAAO,IAAIzF,WAAW,CAAC0F,eAAhB,CAAgC;AACrC7E,MAAAA,IAAI,EAAE4E,iBAAiB,CAAC5E,IADa;AAErC4D,MAAAA,WAAW,EAAEgB,iBAAiB,CAAChB,WAFM;AAGrCkB,MAAAA,MAAM,EAAE,CAAC,GAAG/F,WAAW,CAACU,OAAhB,EAAyBmF,iBAAiB,CAACG,UAA3C,EAAuD,UAAUC,kBAAV,EAA8B;AAC3F,eAAOA,kBAAkB,CAAChF,IAA1B;AACD,OAFO,EAEL,UAAUgF,kBAAV,EAA8B;AAC/B,eAAO;AACLpB,UAAAA,WAAW,EAAEoB,kBAAkB,CAACpB,WAD3B;AAELqB,UAAAA,iBAAiB,EAAED,kBAAkB,CAACC;AAFjC,SAAP;AAID,OAPO;AAH6B,KAAhC,CAAP;AAYD;;AAED,WAASxB,mBAAT,CAA6ByB,wBAA7B,EAAuD;AACrD,WAAO,IAAI/F,WAAW,CAACgG,sBAAhB,CAAuC;AAC5CnF,MAAAA,IAAI,EAAEkF,wBAAwB,CAAClF,IADa;AAE5C4D,MAAAA,WAAW,EAAEsB,wBAAwB,CAACtB,WAFM;AAG5CQ,MAAAA,MAAM,EAAE,SAASA,MAAT,GAAkB;AACxB,eAAOgB,qBAAqB,CAACF,wBAAwB,CAACG,WAA1B,CAA5B;AACD;AAL2C,KAAvC,CAAP;AAOD;;AAED,WAAShB,gBAAT,CAA0BlC,iBAA1B,EAA6C;AAC3C,WAAO,CAAC,GAAGpD,WAAW,CAACU,OAAhB,EAAyB0C,iBAAiB,CAACiC,MAA3C,EAAmD,UAAUkB,kBAAV,EAA8B;AACtF,aAAOA,kBAAkB,CAACtF,IAA1B;AACD,KAFM,EAEJ,UAAUsF,kBAAV,EAA8B;AAC/B,aAAO;AACL1B,QAAAA,WAAW,EAAE0B,kBAAkB,CAAC1B,WAD3B;AAELqB,QAAAA,iBAAiB,EAAEK,kBAAkB,CAACL,iBAFjC;AAGLlF,QAAAA,IAAI,EAAEyC,aAAa,CAAC8C,kBAAkB,CAACvF,IAApB,CAHd;AAILwF,QAAAA,IAAI,EAAEH,qBAAqB,CAACE,kBAAkB,CAACC,IAApB;AAJtB,OAAP;AAMD,KATM,CAAP;AAUD;;AAED,WAASH,qBAAT,CAA+BI,wBAA/B,EAAyD;AACvD,WAAO,CAAC,GAAGzG,WAAW,CAACU,OAAhB,EAAyB+F,wBAAzB,EAAmD,UAAUC,UAAV,EAAsB;AAC9E,aAAOA,UAAU,CAACzF,IAAlB;AACD,KAFM,EAEJ0F,eAFI,CAAP;AAGD;;AAED,WAASA,eAAT,CAAyBC,uBAAzB,EAAkD;AAChD,QAAI5F,IAAI,GAAGuC,YAAY,CAACqD,uBAAuB,CAAC5F,IAAzB,CAAvB;AACA,QAAI6F,YAAY,GAAGD,uBAAuB,CAACC,YAAxB,GAAuC,CAAC,GAAG5G,aAAa,CAAC6G,YAAlB,EAAgC,CAAC,GAAG5G,OAAO,CAAC8E,UAAZ,EAAwB4B,uBAAuB,CAACC,YAAhD,CAAhC,EAA+F7F,IAA/F,CAAvC,GAA8I+F,SAAjK;AACA,WAAO;AACL9F,MAAAA,IAAI,EAAE2F,uBAAuB,CAAC3F,IADzB;AAEL4D,MAAAA,WAAW,EAAE+B,uBAAuB,CAAC/B,WAFhC;AAGL7D,MAAAA,IAAI,EAAEA,IAHD;AAIL6F,MAAAA,YAAY,EAAEA;AAJT,KAAP;AAMD;;AAED,WAASG,cAAT,CAAwBC,sBAAxB,EAAgD;AAC9C;AACA;AACA,QAAIC,SAAS,GAAGD,sBAAsB,CAACC,SAAvB,GAAmCD,sBAAsB,CAACC,SAAvB,CAAiCC,KAAjC,EAAnC,GAA8E,GAAGC,MAAH,CAAU,CAACH,sBAAsB,CAACI,OAAxB,GAAkC,EAAlC,GAAuC,CAAC9G,WAAW,CAAC+G,iBAAZ,CAA8BC,KAA/B,CAAjD,EAAwF,CAACN,sBAAsB,CAACO,WAAxB,GAAsC,EAAtC,GAA2C,CAACjH,WAAW,CAAC+G,iBAAZ,CAA8BG,KAA/B,EAAsClH,WAAW,CAAC+G,iBAAZ,CAA8BI,QAApE,EAA8EnH,WAAW,CAAC+G,iBAAZ,CAA8BK,YAA5G,CAAnI,EAA8P,CAACV,sBAAsB,CAACW,UAAxB,GAAqC,EAArC,GAA0C,CAACrH,WAAW,CAAC+G,iBAAZ,CAA8BO,mBAA/B,EAAoDtH,WAAW,CAAC+G,iBAAZ,CAA8BQ,eAAlF,EAAmGvH,WAAW,CAAC+G,iBAAZ,CAA8BS,eAAjI,CAAxS,CAA9F;AACA,WAAO,IAAIxH,WAAW,CAACyH,gBAAhB,CAAiC;AACtC/G,MAAAA,IAAI,EAAEgG,sBAAsB,CAAChG,IADS;AAEtC4D,MAAAA,WAAW,EAAEoC,sBAAsB,CAACpC,WAFE;AAGtCqC,MAAAA,SAAS,EAAEA,SAH2B;AAItCV,MAAAA,IAAI,EAAEH,qBAAqB,CAACY,sBAAsB,CAACT,IAAxB;AAJW,KAAjC,CAAP;AAMD,GAjOuC,CAmOxC;AACA;;;AACA,MAAIzF,KAAK,GAAGH,mBAAmB,CAACG,KAApB,CAA0BqE,GAA1B,CAA8B,UAAUhC,iBAAV,EAA6B;AACrE,WAAOF,YAAY,CAACE,iBAAiB,CAACnC,IAAnB,CAAnB;AACD,GAFW,CAAZ,CArOwC,CAyOxC;;AACA,MAAIgH,SAAS,GAAGtE,aAAa,CAAC/C,mBAAmB,CAACqH,SAArB,CAA7B;AAEA,MAAIC,YAAY,GAAGtH,mBAAmB,CAACsH,YAApB,GAAmCvE,aAAa,CAAC/C,mBAAmB,CAACsH,YAArB,CAAhD,GAAqF,IAAxG;AAEA,MAAIC,gBAAgB,GAAGvH,mBAAmB,CAACuH,gBAApB,GAAuCxE,aAAa,CAAC/C,mBAAmB,CAACuH,gBAArB,CAApD,GAA6F,IAApH,CA9OwC,CAgPxC;AACA;;AACA,MAAIC,UAAU,GAAGxH,mBAAmB,CAACwH,UAApB,GAAiCxH,mBAAmB,CAACwH,UAApB,CAA+BhD,GAA/B,CAAmC4B,cAAnC,CAAjC,GAAsF,EAAvG,CAlPwC,CAoPxC;;AACA,SAAO,IAAI7G,OAAO,CAACkI,aAAZ,CAA0B;AAC/BC,IAAAA,KAAK,EAAEL,SADwB;AAE/BM,IAAAA,QAAQ,EAAEL,YAFqB;AAG/BM,IAAAA,YAAY,EAAEL,gBAHiB;AAI/BpH,IAAAA,KAAK,EAAEA,KAJwB;AAK/BqH,IAAAA,UAAU,EAAEA;AALmB,GAA1B,CAAP;AAOD;AAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAS3C,yBAAT,GAAqC;AACnC,QAAM,IAAI7C,KAAJ,CAAU,kEAAV,CAAN;AACD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildClientSchema = buildClientSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyMap = require('../jsutils/keyMap');\n\nvar _keyMap2 = _interopRequireDefault(_keyMap);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _parser = require('../language/parser');\n\nvar _schema = require('../type/schema');\n\nvar _definition = require('../type/definition');\n\nvar _introspection = require('../type/introspection');\n\nvar _scalars = require('../type/scalars');\n\nvar _directives = require('../type/directives');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n */\nfunction buildClientSchema(introspection) {\n\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema;\n\n  // Converts the list of types into a keyMap based on the type names.\n  var typeIntrospectionMap = (0, _keyMap2.default)(schemaIntrospection.types, function (type) {\n    return type.name;\n  });\n\n  // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n  var typeDefCache = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  };\n\n  // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return new _definition.GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      var nullableType = getType(nullableRef);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n    var typeIntrospection = typeIntrospectionMap[typeName];\n    if (!typeIntrospection) {\n      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !(0, _definition.isInputType)(type) ? (0, _invariant2.default)(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !(0, _definition.isOutputType)(type) ? (0, _invariant2.default)(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Introspection must provide object type for possibleTypes.') : void 0;\n    return type;\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Introspection must provide interface type for interfaces.') : void 0;\n    return type;\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function buildType(type) {\n    switch (type.kind) {\n      case _introspection.TypeKind.SCALAR:\n        return buildScalarDef(type);\n      case _introspection.TypeKind.OBJECT:\n        return buildObjectDef(type);\n      case _introspection.TypeKind.INTERFACE:\n        return buildInterfaceDef(type);\n      case _introspection.TypeKind.UNION:\n        return buildUnionDef(type);\n      case _introspection.TypeKind.ENUM:\n        return buildEnumDef(type);\n      case _introspection.TypeKind.INPUT_OBJECT:\n        return buildInputObjectDef(type);\n      default:\n        throw new Error('Invalid or incomplete schema, unknown kind: ' + type.kind + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(id) {\n        return id;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      },\n      resolveType: cannotExecuteClientSchema\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType),\n      resolveType: cannotExecuteClientSchema\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap2.default)(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    return (0, _keyValMap2.default)(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap2.default)(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      name: inputValueIntrospection.name,\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    // Support deprecated `on****` fields for building `locations`, as this\n    // is used by GraphiQL which may need to support outdated servers.\n    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [_directives.DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [_directives.DirectiveLocation.QUERY, _directives.DirectiveLocation.MUTATION, _directives.DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [_directives.DirectiveLocation.FRAGMENT_DEFINITION, _directives.DirectiveLocation.FRAGMENT_SPREAD, _directives.DirectiveLocation.INLINE_FRAGMENT]);\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: locations,\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  });\n\n  // Get the root Query, Mutation, and Subscription types.\n  var queryType = getObjectType(schemaIntrospection.queryType);\n\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;\n\n  // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];\n\n  // Then produce and return a Schema with these types.\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives\n  });\n} /**\n   * Copyright (c) 2015-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */\n\nfunction cannotExecuteClientSchema() {\n  throw new Error('Client Schema cannot use Interface or Union types for execution.');\n}"]},"metadata":{},"sourceType":"script"}