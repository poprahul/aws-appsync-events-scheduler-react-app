{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport { forEach, isCollection } from 'iterall';\nimport isInvalid from '../jsutils/isInvalid';\nimport isNullish from '../jsutils/isNullish';\nimport orList from '../jsutils/orList';\nimport suggestionList from '../jsutils/suggestionList';\nimport { GraphQLError } from '../error';\nimport { isScalarType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n/**\n * Coerces a JavaScript value given a GraphQL Type.\n *\n * Returns either a value which is valid for the provided type or a list of\n * encountered coercion errors.\n *\n */\n\nexport function coerceValue(value, type, blameNode, path) {\n  // A value must be provided if the type is non-null.\n  if (isNonNullType(type)) {\n    if (isNullish(value)) {\n      return ofErrors([coercionError('Expected non-nullable type ' + String(type) + ' not to be null', blameNode, path)]);\n    }\n\n    return coerceValue(value, type.ofType, blameNode, path);\n  }\n\n  if (isNullish(value)) {\n    // Explicitly return the value null.\n    return ofValue(null);\n  }\n\n  if (isScalarType(type)) {\n    // Scalars determine if a value is valid via parseValue(), which can\n    // throw to indicate failure. If it throws, maintain a reference to\n    // the original error.\n    try {\n      var parseResult = type.parseValue(value);\n\n      if (isInvalid(parseResult)) {\n        return ofErrors([coercionError('Expected type ' + type.name, blameNode, path)]);\n      }\n\n      return ofValue(parseResult);\n    } catch (error) {\n      return ofErrors([coercionError('Expected type ' + type.name, blameNode, path, error.message, error)]);\n    }\n  }\n\n  if (isEnumType(type)) {\n    if (typeof value === 'string') {\n      var enumValue = type.getValue(value);\n\n      if (enumValue) {\n        return ofValue(enumValue.value);\n      }\n    }\n\n    var suggestions = suggestionList(String(value), type.getValues().map(function (enumValue) {\n      return enumValue.name;\n    }));\n    var didYouMean = suggestions.length !== 0 ? 'did you mean ' + orList(suggestions) + '?' : undefined;\n    return ofErrors([coercionError('Expected type ' + type.name, blameNode, path, didYouMean)]);\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (isCollection(value)) {\n      var _errors = void 0;\n\n      var coercedValue = [];\n      forEach(value, function (itemValue, index) {\n        var coercedItem = coerceValue(itemValue, itemType, blameNode, atPath(path, index));\n\n        if (coercedItem.errors) {\n          _errors = add(_errors, coercedItem.errors);\n        } else if (!_errors) {\n          coercedValue.push(coercedItem.value);\n        }\n      });\n      return _errors ? ofErrors(_errors) : ofValue(coercedValue);\n    } // Lists accept a non-list value as a list of one.\n\n\n    var coercedItem = coerceValue(value, itemType, blameNode);\n    return coercedItem.errors ? coercedItem : ofValue([coercedItem.value]);\n  }\n\n  if (isInputObjectType(type)) {\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {\n      return ofErrors([coercionError('Expected type ' + type.name + ' to be an object', blameNode, path)]);\n    }\n\n    var _errors2 = void 0;\n\n    var _coercedValue = {};\n    var fields = type.getFields(); // Ensure every defined field is valid.\n\n    for (var fieldName in fields) {\n      if (hasOwnProperty.call(fields, fieldName)) {\n        var field = fields[fieldName];\n        var fieldValue = value[fieldName];\n\n        if (isInvalid(fieldValue)) {\n          if (!isInvalid(field.defaultValue)) {\n            _coercedValue[fieldName] = field.defaultValue;\n          } else if (isNonNullType(field.type)) {\n            _errors2 = add(_errors2, coercionError('Field ' + printPath(atPath(path, fieldName)) + ' of required ' + ('type ' + String(field.type) + ' was not provided'), blameNode));\n          }\n        } else {\n          var coercedField = coerceValue(fieldValue, field.type, blameNode, atPath(path, fieldName));\n\n          if (coercedField.errors) {\n            _errors2 = add(_errors2, coercedField.errors);\n          } else if (!_errors2) {\n            _coercedValue[fieldName] = coercedField.value;\n          }\n        }\n      }\n    } // Ensure every provided field is defined.\n\n\n    for (var _fieldName in value) {\n      if (hasOwnProperty.call(value, _fieldName)) {\n        if (!fields[_fieldName]) {\n          var _suggestions = suggestionList(_fieldName, Object.keys(fields));\n\n          var _didYouMean = _suggestions.length !== 0 ? 'did you mean ' + orList(_suggestions) + '?' : undefined;\n\n          _errors2 = add(_errors2, coercionError('Field \"' + _fieldName + '\" is not defined by type ' + type.name, blameNode, path, _didYouMean));\n        }\n      }\n    }\n\n    return _errors2 ? ofErrors(_errors2) : ofValue(_coercedValue);\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error('Unexpected type: ' + type + '.');\n}\n\nfunction ofValue(value) {\n  return {\n    errors: undefined,\n    value: value\n  };\n}\n\nfunction ofErrors(errors) {\n  return {\n    errors: errors,\n    value: undefined\n  };\n}\n\nfunction add(errors, moreErrors) {\n  return (errors || []).concat(moreErrors);\n}\n\nfunction atPath(prev, key) {\n  return {\n    prev: prev,\n    key: key\n  };\n}\n\nfunction coercionError(message, blameNode, path, subMessage, originalError) {\n  var pathStr = printPath(path); // Return a GraphQLError instance\n\n  return new GraphQLError(message + (pathStr ? ' at ' + pathStr : '') + (subMessage ? '; ' + subMessage : '.'), blameNode, undefined, undefined, undefined, originalError);\n} // Build a string describing the path into the value where the error was found\n\n\nfunction printPath(path) {\n  var pathStr = '';\n  var currentPath = path;\n\n  while (currentPath) {\n    pathStr = (typeof currentPath.key === 'string' ? '.' + currentPath.key : '[' + String(currentPath.key) + ']') + pathStr;\n    currentPath = currentPath.prev;\n  }\n\n  return pathStr ? 'value' + pathStr : '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/coerceValue.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","forEach","isCollection","isInvalid","isNullish","orList","suggestionList","GraphQLError","isScalarType","isEnumType","isInputObjectType","isListType","isNonNullType","coerceValue","value","type","blameNode","path","ofErrors","coercionError","String","ofType","ofValue","parseResult","parseValue","name","error","message","enumValue","getValue","suggestions","getValues","map","didYouMean","length","undefined","itemType","_errors","coercedValue","itemValue","index","coercedItem","atPath","errors","add","push","_errors2","_coercedValue","fields","getFields","fieldName","hasOwnProperty","call","field","fieldValue","defaultValue","printPath","coercedField","_fieldName","_suggestions","Object","keys","_didYouMean","Error","moreErrors","concat","prev","key","subMessage","originalError","pathStr","currentPath"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { forEach, isCollection } from 'iterall';\nimport isInvalid from '../jsutils/isInvalid';\nimport isNullish from '../jsutils/isNullish';\nimport orList from '../jsutils/orList';\nimport suggestionList from '../jsutils/suggestionList';\nimport { GraphQLError } from '../error';\n\nimport { isScalarType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n\n\n/**\n * Coerces a JavaScript value given a GraphQL Type.\n *\n * Returns either a value which is valid for the provided type or a list of\n * encountered coercion errors.\n *\n */\nexport function coerceValue(value, type, blameNode, path) {\n  // A value must be provided if the type is non-null.\n  if (isNonNullType(type)) {\n    if (isNullish(value)) {\n      return ofErrors([coercionError('Expected non-nullable type ' + String(type) + ' not to be null', blameNode, path)]);\n    }\n    return coerceValue(value, type.ofType, blameNode, path);\n  }\n\n  if (isNullish(value)) {\n    // Explicitly return the value null.\n    return ofValue(null);\n  }\n\n  if (isScalarType(type)) {\n    // Scalars determine if a value is valid via parseValue(), which can\n    // throw to indicate failure. If it throws, maintain a reference to\n    // the original error.\n    try {\n      var parseResult = type.parseValue(value);\n      if (isInvalid(parseResult)) {\n        return ofErrors([coercionError('Expected type ' + type.name, blameNode, path)]);\n      }\n      return ofValue(parseResult);\n    } catch (error) {\n      return ofErrors([coercionError('Expected type ' + type.name, blameNode, path, error.message, error)]);\n    }\n  }\n\n  if (isEnumType(type)) {\n    if (typeof value === 'string') {\n      var enumValue = type.getValue(value);\n      if (enumValue) {\n        return ofValue(enumValue.value);\n      }\n    }\n    var suggestions = suggestionList(String(value), type.getValues().map(function (enumValue) {\n      return enumValue.name;\n    }));\n    var didYouMean = suggestions.length !== 0 ? 'did you mean ' + orList(suggestions) + '?' : undefined;\n    return ofErrors([coercionError('Expected type ' + type.name, blameNode, path, didYouMean)]);\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n    if (isCollection(value)) {\n      var _errors = void 0;\n      var coercedValue = [];\n      forEach(value, function (itemValue, index) {\n        var coercedItem = coerceValue(itemValue, itemType, blameNode, atPath(path, index));\n        if (coercedItem.errors) {\n          _errors = add(_errors, coercedItem.errors);\n        } else if (!_errors) {\n          coercedValue.push(coercedItem.value);\n        }\n      });\n      return _errors ? ofErrors(_errors) : ofValue(coercedValue);\n    }\n    // Lists accept a non-list value as a list of one.\n    var coercedItem = coerceValue(value, itemType, blameNode);\n    return coercedItem.errors ? coercedItem : ofValue([coercedItem.value]);\n  }\n\n  if (isInputObjectType(type)) {\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {\n      return ofErrors([coercionError('Expected type ' + type.name + ' to be an object', blameNode, path)]);\n    }\n    var _errors2 = void 0;\n    var _coercedValue = {};\n    var fields = type.getFields();\n\n    // Ensure every defined field is valid.\n    for (var fieldName in fields) {\n      if (hasOwnProperty.call(fields, fieldName)) {\n        var field = fields[fieldName];\n        var fieldValue = value[fieldName];\n        if (isInvalid(fieldValue)) {\n          if (!isInvalid(field.defaultValue)) {\n            _coercedValue[fieldName] = field.defaultValue;\n          } else if (isNonNullType(field.type)) {\n            _errors2 = add(_errors2, coercionError('Field ' + printPath(atPath(path, fieldName)) + ' of required ' + ('type ' + String(field.type) + ' was not provided'), blameNode));\n          }\n        } else {\n          var coercedField = coerceValue(fieldValue, field.type, blameNode, atPath(path, fieldName));\n          if (coercedField.errors) {\n            _errors2 = add(_errors2, coercedField.errors);\n          } else if (!_errors2) {\n            _coercedValue[fieldName] = coercedField.value;\n          }\n        }\n      }\n    }\n\n    // Ensure every provided field is defined.\n    for (var _fieldName in value) {\n      if (hasOwnProperty.call(value, _fieldName)) {\n        if (!fields[_fieldName]) {\n          var _suggestions = suggestionList(_fieldName, Object.keys(fields));\n          var _didYouMean = _suggestions.length !== 0 ? 'did you mean ' + orList(_suggestions) + '?' : undefined;\n          _errors2 = add(_errors2, coercionError('Field \"' + _fieldName + '\" is not defined by type ' + type.name, blameNode, path, _didYouMean));\n        }\n      }\n    }\n\n    return _errors2 ? ofErrors(_errors2) : ofValue(_coercedValue);\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unexpected type: ' + type + '.');\n}\n\nfunction ofValue(value) {\n  return { errors: undefined, value: value };\n}\n\nfunction ofErrors(errors) {\n  return { errors: errors, value: undefined };\n}\n\nfunction add(errors, moreErrors) {\n  return (errors || []).concat(moreErrors);\n}\n\nfunction atPath(prev, key) {\n  return { prev: prev, key: key };\n}\n\nfunction coercionError(message, blameNode, path, subMessage, originalError) {\n  var pathStr = printPath(path);\n  // Return a GraphQLError instance\n  return new GraphQLError(message + (pathStr ? ' at ' + pathStr : '') + (subMessage ? '; ' + subMessage : '.'), blameNode, undefined, undefined, undefined, originalError);\n}\n\n// Build a string describing the path into the value where the error was found\nfunction printPath(path) {\n  var pathStr = '';\n  var currentPath = path;\n  while (currentPath) {\n    pathStr = (typeof currentPath.key === 'string' ? '.' + currentPath.key : '[' + String(currentPath.key) + ']') + pathStr;\n    currentPath = currentPath.prev;\n  }\n  return pathStr ? 'value' + pathStr : '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;"]},"metadata":{},"sourceType":"module"}