{"ast":null,"code":"import { GraphQLError } from '../../error';\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/validation/rules/PossibleFragmentSpreads.js"],"names":["GraphQLError","doTypesOverlap","typeFromAST","isCompositeType","typeIncompatibleSpreadMessage","fragName","parentType","fragType","String","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","context","InlineFragment","node","getType","getParentType","getSchema","reportError","FragmentSpread","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"mappings":"AACA,SAASA,YAAT,QAA6B,aAA7B;AAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,cAAT,QAA+B,iCAA/B;AACA,SAASC,WAAT,QAA4B,6BAA5B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AAGA,OAAO,SAASC,6BAAT,CAAuCC,QAAvC,EAAiDC,UAAjD,EAA6DC,QAA7D,EAAuE;AAC5E,SAAO,eAAeF,QAAf,GAA0B,wCAA1B,IAAsE,WAAWG,MAAM,CAACF,UAAD,CAAjB,GAAgC,0BAAhC,GAA6DE,MAAM,CAACD,QAAD,CAAnE,GAAgF,IAAtJ,CAAP;AACD;AAED,OAAO,SAASE,iCAAT,CAA2CH,UAA3C,EAAuDC,QAAvD,EAAiE;AACtE,SAAO,mDAAmD,WAAWC,MAAM,CAACF,UAAD,CAAjB,GAAgC,0BAAhC,GAA6DE,MAAM,CAACD,QAAD,CAAnE,GAAgF,IAAnI,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,uBAAT,CAAiCC,OAAjC,EAA0C;AAC/C,SAAO;AACLC,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;AAC5C,UAAIN,QAAQ,GAAGI,OAAO,CAACG,OAAR,EAAf;AACA,UAAIR,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AACA,UAAIZ,eAAe,CAACI,QAAD,CAAf,IAA6BJ,eAAe,CAACG,UAAD,CAA5C,IAA4D,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA/E,EAA4H;AAC1HK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBS,iCAAiC,CAACH,UAAD,EAAaC,QAAb,CAAlD,EAA0E,CAACM,IAAD,CAA1E,CAApB;AACD;AACF,KAPI;AAQLK,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBL,IAAxB,EAA8B;AAC5C,UAAIR,QAAQ,GAAGQ,IAAI,CAACM,IAAL,CAAUC,KAAzB;AACA,UAAIb,QAAQ,GAAGc,eAAe,CAACV,OAAD,EAAUN,QAAV,CAA9B;AACA,UAAIC,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AACA,UAAIR,QAAQ,IAAID,UAAZ,IAA0B,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA7C,EAA0F;AACxFK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBI,6BAA6B,CAACC,QAAD,EAAWC,UAAX,EAAuBC,QAAvB,CAA9C,EAAgF,CAACM,IAAD,CAAhF,CAApB;AACD;AACF;AAfI,GAAP;AAiBD;;AAED,SAASQ,eAAT,CAAyBV,OAAzB,EAAkCQ,IAAlC,EAAwC;AACtC,MAAIG,IAAI,GAAGX,OAAO,CAACY,WAAR,CAAoBJ,IAApB,CAAX;;AACA,MAAIG,IAAJ,EAAU;AACR,QAAIE,IAAI,GAAGtB,WAAW,CAACS,OAAO,CAACK,SAAR,EAAD,EAAsBM,IAAI,CAACG,aAA3B,CAAtB;;AACA,QAAItB,eAAe,CAACqB,IAAD,CAAnB,EAA2B;AACzB,aAAOA,IAAP;AACD;AACF;AACF","sourcesContent":["\nimport { GraphQLError } from '../../error'; /**\n                                             * Copyright (c) 2015-present, Facebook, Inc.\n                                             *\n                                             * This source code is licensed under the MIT license found in the\n                                             * LICENSE file in the root directory of this source tree.\n                                             *\n                                             * \n                                             */\n\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\n\n\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}