{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenKind = undefined;\nexports.createLexer = createLexer;\nexports.getTokenDesc = getTokenDesc;\n\nvar _error = require('../error');\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\n\nfunction createLexer(source, options) {\n  var startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer\n  };\n  return lexer;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction advanceLexer() {\n  var token = this.lastToken = this.token;\n\n  if (token.kind !== EOF) {\n    do {\n      token = token.next = readToken(this, token);\n    } while (token.kind === COMMENT);\n\n    this.token = token;\n  }\n\n  return token;\n}\n/**\n * The return type of createLexer.\n */\n// Each kind of token.\n\n\nvar SOF = '<SOF>';\nvar EOF = '<EOF>';\nvar BANG = '!';\nvar DOLLAR = '$';\nvar PAREN_L = '(';\nvar PAREN_R = ')';\nvar SPREAD = '...';\nvar COLON = ':';\nvar EQUALS = '=';\nvar AT = '@';\nvar BRACKET_L = '[';\nvar BRACKET_R = ']';\nvar BRACE_L = '{';\nvar PIPE = '|';\nvar BRACE_R = '}';\nvar NAME = 'Name';\nvar INT = 'Int';\nvar FLOAT = 'Float';\nvar STRING = 'String';\nvar COMMENT = 'Comment';\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\n\nvar TokenKind = exports.TokenKind = {\n  SOF: SOF,\n  EOF: EOF,\n  BANG: BANG,\n  DOLLAR: DOLLAR,\n  PAREN_L: PAREN_L,\n  PAREN_R: PAREN_R,\n  SPREAD: SPREAD,\n  COLON: COLON,\n  EQUALS: EQUALS,\n  AT: AT,\n  BRACKET_L: BRACKET_L,\n  BRACKET_R: BRACKET_R,\n  BRACE_L: BRACE_L,\n  PIPE: PIPE,\n  BRACE_R: BRACE_R,\n  NAME: NAME,\n  INT: INT,\n  FLOAT: FLOAT,\n  STRING: STRING,\n  COMMENT: COMMENT\n};\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? token.kind + ' \"' + value + '\"' : token.kind;\n}\n\nvar charCodeAt = String.prototype.charCodeAt;\nvar slice = String.prototype.slice;\n/**\n * Helper function for constructing the Token object.\n */\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\nTok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n};\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? EOF : // Trust JSON for ASCII.\n    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    '\"\\\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '\"'\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + position - lexer.lineStart;\n\n  if (position >= bodyLength) {\n    return new Tok(EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = charCodeAt.call(body, position); // SourceCharacter\n\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {\n    throw (0, _error.syntaxError)(source, position, 'Cannot contain the invalid character ' + printCharCode(code) + '.');\n  }\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(BANG, position, position + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, position, line, col, prev);\n    // $\n\n    case 36:\n      return new Tok(DOLLAR, position, position + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Tok(PAREN_L, position, position + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Tok(PAREN_R, position, position + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {\n        return new Tok(SPREAD, position, position + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Tok(COLON, position, position + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Tok(EQUALS, position, position + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Tok(AT, position, position + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Tok(BRACKET_L, position, position + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Tok(BRACKET_R, position, position + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Tok(BRACE_L, position, position + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Tok(PIPE, position, position + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Tok(BRACE_R, position, position + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, position, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, position, code, line, col, prev);\n    // \"\n\n    case 34:\n      return readString(source, position, line, col, prev);\n  }\n\n  throw (0, _error.syntaxError)(source, position, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use ' + 'a double quote (\")?';\n  }\n\n  return 'Cannot parse the unexpected character ' + printCharCode(code) + '.';\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = charCodeAt.call(body, position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xFEFF) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (charCodeAt.call(body, position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code = void 0;\n  var position = start;\n\n  do {\n    code = charCodeAt.call(body, ++position);\n  } while (code !== null && ( // SourceCharacter but not LineTerminator\n  code > 0x001F || code === 0x0009));\n\n  return new Tok(COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = charCodeAt.call(body, ++position);\n\n    if (code >= 48 && code <= 57) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = charCodeAt.call(body, ++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = charCodeAt.call(body, ++position);\n    }\n\n    position = readDigits(source, position, code);\n  }\n\n  return new Tok(isFloat ? FLOAT : INT, start, position, line, col, prev, slice.call(body, start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null && // not LineTerminator\n  code !== 0x000A && code !== 0x000D && // not Quote (\")\n  code !== 34) {\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          // u\n          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));\n\n          if (charCode < 0) {\n            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\\\u' + body.slice(position + 1, position + 5) + '.'));\n          }\n\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n\n        default:\n          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\\\' + String.fromCharCode(code) + '.');\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  if (code !== 34) {\n    // quote (\")\n    throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n  }\n\n  value += slice.call(body, chunkStart, position);\n  return new Tok(STRING, start, position + 1, line, col, prev, value);\n}\n/**\n * Converts four hexidecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 : // 0-9\n  a >= 65 && a <= 70 ? a - 55 : // A-F\n  a >= 97 && a <= 102 ? a - 87 : // a-f\n  -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, position, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var end = position + 1;\n  var code = 0;\n\n  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122 // a-z\n  )) {\n    ++end;\n  }\n\n  return new Tok(NAME, position, end, line, col, prev, slice.call(body, position, end));\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/language/lexer.js"],"names":["Object","defineProperty","exports","value","TokenKind","undefined","createLexer","getTokenDesc","_error","require","source","options","startOfFileToken","Tok","SOF","lexer","lastToken","token","line","lineStart","advance","advanceLexer","kind","EOF","next","readToken","COMMENT","BANG","DOLLAR","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","NAME","INT","FLOAT","STRING","charCodeAt","String","prototype","slice","start","end","column","prev","toJSON","inspect","printCharCode","code","isNaN","JSON","stringify","fromCharCode","toString","toUpperCase","body","bodyLength","length","position","positionAfterWhitespace","col","call","syntaxError","readComment","readName","readNumber","readString","unexpectedCharacterMessage","startPosition","firstCode","isFloat","readDigits","chunkStart","charCode","uniCharCode","a","b","c","d","char2hex"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenKind = undefined;\nexports.createLexer = createLexer;\nexports.getTokenDesc = getTokenDesc;\n\nvar _error = require('../error');\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\nfunction createLexer(source, options) {\n  var startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer\n  };\n  return lexer;\n} /**\n   * Copyright (c) 2015-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */\n\nfunction advanceLexer() {\n  var token = this.lastToken = this.token;\n  if (token.kind !== EOF) {\n    do {\n      token = token.next = readToken(this, token);\n    } while (token.kind === COMMENT);\n    this.token = token;\n  }\n  return token;\n}\n\n/**\n * The return type of createLexer.\n */\n\n\n// Each kind of token.\nvar SOF = '<SOF>';\nvar EOF = '<EOF>';\nvar BANG = '!';\nvar DOLLAR = '$';\nvar PAREN_L = '(';\nvar PAREN_R = ')';\nvar SPREAD = '...';\nvar COLON = ':';\nvar EQUALS = '=';\nvar AT = '@';\nvar BRACKET_L = '[';\nvar BRACKET_R = ']';\nvar BRACE_L = '{';\nvar PIPE = '|';\nvar BRACE_R = '}';\nvar NAME = 'Name';\nvar INT = 'Int';\nvar FLOAT = 'Float';\nvar STRING = 'String';\nvar COMMENT = 'Comment';\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind = exports.TokenKind = {\n  SOF: SOF,\n  EOF: EOF,\n  BANG: BANG,\n  DOLLAR: DOLLAR,\n  PAREN_L: PAREN_L,\n  PAREN_R: PAREN_R,\n  SPREAD: SPREAD,\n  COLON: COLON,\n  EQUALS: EQUALS,\n  AT: AT,\n  BRACKET_L: BRACKET_L,\n  BRACKET_R: BRACKET_R,\n  BRACE_L: BRACE_L,\n  PIPE: PIPE,\n  BRACE_R: BRACE_R,\n  NAME: NAME,\n  INT: INT,\n  FLOAT: FLOAT,\n  STRING: STRING,\n  COMMENT: COMMENT\n};\n\n/**\n * A helper function to describe a token as a string for debugging\n */\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? token.kind + ' \"' + value + '\"' : token.kind;\n}\n\nvar charCodeAt = String.prototype.charCodeAt;\nvar slice = String.prototype.slice;\n\n/**\n * Helper function for constructing the Token object.\n */\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nTok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n};\n\nfunction printCharCode(code) {\n  return (\n    // NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? EOF :\n    // Trust JSON for ASCII.\n    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) :\n    // Otherwise print the escaped form.\n    '\"\\\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '\"'\n  );\n}\n\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n\n  var position = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + position - lexer.lineStart;\n\n  if (position >= bodyLength) {\n    return new Tok(EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = charCodeAt.call(body, position);\n\n  // SourceCharacter\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {\n    throw (0, _error.syntaxError)(source, position, 'Cannot contain the invalid character ' + printCharCode(code) + '.');\n  }\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(BANG, position, position + 1, line, col, prev);\n    // #\n    case 35:\n      return readComment(source, position, line, col, prev);\n    // $\n    case 36:\n      return new Tok(DOLLAR, position, position + 1, line, col, prev);\n    // (\n    case 40:\n      return new Tok(PAREN_L, position, position + 1, line, col, prev);\n    // )\n    case 41:\n      return new Tok(PAREN_R, position, position + 1, line, col, prev);\n    // .\n    case 46:\n      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {\n        return new Tok(SPREAD, position, position + 3, line, col, prev);\n      }\n      break;\n    // :\n    case 58:\n      return new Tok(COLON, position, position + 1, line, col, prev);\n    // =\n    case 61:\n      return new Tok(EQUALS, position, position + 1, line, col, prev);\n    // @\n    case 64:\n      return new Tok(AT, position, position + 1, line, col, prev);\n    // [\n    case 91:\n      return new Tok(BRACKET_L, position, position + 1, line, col, prev);\n    // ]\n    case 93:\n      return new Tok(BRACKET_R, position, position + 1, line, col, prev);\n    // {\n    case 123:\n      return new Tok(BRACE_L, position, position + 1, line, col, prev);\n    // |\n    case 124:\n      return new Tok(PIPE, position, position + 1, line, col, prev);\n    // }\n    case 125:\n      return new Tok(BRACE_R, position, position + 1, line, col, prev);\n    // A-Z _ a-z\n    case 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:\n    case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:\n    case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:\n    case 89:case 90:\n    case 95:\n    case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:\n    case 105:case 106:case 107:case 108:case 109:case 110:case 111:\n    case 112:case 113:case 114:case 115:case 116:case 117:case 118:\n    case 119:case 120:case 121:case 122:\n      return readName(source, position, line, col, prev);\n    // - 0-9\n    case 45:\n    case 48:case 49:case 50:case 51:case 52:\n    case 53:case 54:case 55:case 56:case 57:\n      return readNumber(source, position, code, line, col, prev);\n    // \"\n    case 34:\n      return readString(source, position, line, col, prev);\n  }\n\n  throw (0, _error.syntaxError)(source, position, unexpectedCharacterMessage(code));\n}\n\n/**\n * Report a message that an unexpected character was encountered.\n */\nfunction unexpectedCharacterMessage(code) {\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use ' + 'a double quote (\")?';\n  }\n\n  return 'Cannot parse the unexpected character ' + printCharCode(code) + '.';\n}\n\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n  while (position < bodyLength) {\n    var code = charCodeAt.call(body, position);\n    // tab | space | comma | BOM\n    if (code === 9 || code === 32 || code === 44 || code === 0xFEFF) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (charCodeAt.call(body, position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n  return position;\n}\n\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code = void 0;\n  var position = start;\n\n  do {\n    code = charCodeAt.call(body, ++position);\n  } while (code !== null && (\n  // SourceCharacter but not LineTerminator\n  code > 0x001F || code === 0x0009));\n\n  return new Tok(COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));\n}\n\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = charCodeAt.call(body, ++position);\n    if (code >= 48 && code <= 57) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    if (code === 43 || code === 45) {\n      // + -\n      code = charCodeAt.call(body, ++position);\n    }\n    position = readDigits(source, position, code);\n  }\n\n  return new Tok(isFloat ? FLOAT : INT, start, position, line, col, prev, slice.call(body, start, position));\n}\n\n/**\n * Returns the new position in the source after reading digits.\n */\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n    return position;\n  }\n  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');\n}\n\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null &&\n  // not LineTerminator\n  code !== 0x000A && code !== 0x000D &&\n  // not Quote (\")\n  code !== 34) {\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n    }\n\n    ++position;\n    if (code === 92) {\n      // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n      switch (code) {\n        case 34:\n          value += '\"';break;\n        case 47:\n          value += '/';break;\n        case 92:\n          value += '\\\\';break;\n        case 98:\n          value += '\\b';break;\n        case 102:\n          value += '\\f';break;\n        case 110:\n          value += '\\n';break;\n        case 114:\n          value += '\\r';break;\n        case 116:\n          value += '\\t';break;\n        case 117:\n          // u\n          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));\n          if (charCode < 0) {\n            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\\\u' + body.slice(position + 1, position + 5) + '.'));\n          }\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n        default:\n          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\\\' + String.fromCharCode(code) + '.');\n      }\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  if (code !== 34) {\n    // quote (\")\n    throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n  }\n\n  value += slice.call(body, chunkStart, position);\n  return new Tok(STRING, start, position + 1, line, col, prev, value);\n}\n\n/**\n * Converts four hexidecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 : // 0-9\n  a >= 65 && a <= 70 ? a - 55 : // A-F\n  a >= 97 && a <= 102 ? a - 87 : // a-f\n  -1;\n}\n\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\nfunction readName(source, position, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var end = position + 1;\n  var code = 0;\n  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122 // a-z\n  )) {\n    ++end;\n  }\n  return new Tok(NAME, position, end, line, col, prev, slice.call(body, position, end));\n}"]},"metadata":{},"sourceType":"script"}