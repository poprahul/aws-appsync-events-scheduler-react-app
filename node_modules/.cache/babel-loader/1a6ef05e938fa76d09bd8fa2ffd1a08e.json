{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport { __Schema } from './introspection';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\n/**\n * Test if the given value is a GraphQL schema.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = function () {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLSchema); // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, '\"types\" must be Array if provided but got: ' + String(config.types) + '.') : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + (String(config.directives) + '.')) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + (String(config.allowedLegacyNames) + '.')) : void 0;\n      this.__allowedLegacyNames = config.allowedLegacyNames;\n    }\n\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n    var types = config.types;\n\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    } // Keep track of all types referenced within the schema.\n\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap; // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n\n      if (isObjectType(type)) {\n        type.getInterfaces().forEach(function (iface) {\n          var impls = _this._implementations[iface.name];\n\n          if (impls) {\n            impls.push(type);\n          } else {\n            _this._implementations[iface.name] = [type];\n          }\n        });\n      }\n    });\n  } // Referenced by validateSchema().\n\n\n  GraphQLSchema.prototype.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  GraphQLSchema.prototype.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  GraphQLSchema.prototype.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name];\n  };\n\n  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      !Array.isArray(possibleTypes) ? invariant(0, 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.') : void 0;\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  GraphQLSchema.prototype.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  GraphQLSchema.prototype.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}();\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type.name + '\".')) : void 0;\n    return map;\n  }\n\n  map[type.name] = type;\n  var reducedMap = map;\n\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      if (field.args) {\n        var fieldArgTypes = field.args.map(function (arg) {\n          return arg.type;\n        });\n        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      }\n\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  if (isInputObjectType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/type/schema.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","isObjectType","isInterfaceType","isUnionType","isInputObjectType","isWrappingType","GraphQLDirective","isDirective","specifiedDirectives","__Schema","find","instanceOf","invariant","objectValues","isSchema","schema","GraphQLSchema","config","_this","assumeValid","__validationErrors","types","Array","isArray","String","directives","allowedLegacyNames","__allowedLegacyNames","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","astNode","initialTypes","getQueryType","getMutationType","getSubscriptionType","concat","typeMap","Object","create","reduce","typeMapReducer","typeMapDirectiveReducer","_typeMap","_implementations","keys","forEach","typeName","type","getInterfaces","iface","impls","name","push","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","isPossibleType","possibleType","possibleTypeMap","_possibleTypeMap","possibleTypes","map","Boolean","getDirectives","getDirective","directive","ofType","reducedMap","getFields","field","args","fieldArgTypes","arg","_map"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\n\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\n\nimport { __Schema } from './introspection';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\n\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\nexport var GraphQLSchema = function () {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLSchema);\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, '\"types\" must be Array if provided but got: ' + String(config.types) + '.') : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + (String(config.directives) + '.')) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + (String(config.allowedLegacyNames) + '.')) : void 0;\n      this.__allowedLegacyNames = config.allowedLegacyNames;\n    }\n\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription;\n    // Provide specified directives (e.g. @include and @skip) by default.\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode;\n\n    // Build type map now to detect any errors within this schema.\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n\n    var types = config.types;\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    }\n\n    // Keep track of all types referenced within the schema.\n    var typeMap = Object.create(null);\n\n    // First by deeply visiting all initial types.\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap);\n\n    // Then by deeply visiting all directive types.\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap);\n\n    // Storing the resulting map for reference by the schema.\n    this._typeMap = typeMap;\n\n    // Keep track of all implementations by interface name.\n    this._implementations = Object.create(null);\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n      if (isObjectType(type)) {\n        type.getInterfaces().forEach(function (iface) {\n          var impls = _this._implementations[iface.name];\n          if (impls) {\n            impls.push(type);\n          } else {\n            _this._implementations[iface.name] = [type];\n          }\n        });\n      }\n    });\n  }\n  // Referenced by validateSchema().\n\n\n  GraphQLSchema.prototype.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  GraphQLSchema.prototype.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  GraphQLSchema.prototype.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n    return this._implementations[abstractType.name];\n  };\n\n  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      !Array.isArray(possibleTypes) ? invariant(0, 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.') : void 0;\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  GraphQLSchema.prototype.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  GraphQLSchema.prototype.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}();\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type.name + '\".')) : void 0;\n    return map;\n  }\n  map[type.name] = type;\n\n  var reducedMap = map;\n\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      if (field.args) {\n        var fieldArgTypes = field.args.map(function (arg) {\n          return arg.type;\n        });\n        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      }\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  if (isInputObjectType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}"]},"metadata":{},"sourceType":"module"}