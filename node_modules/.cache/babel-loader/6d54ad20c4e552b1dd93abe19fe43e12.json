{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport { Kind } from '../language/kinds';\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from '../type/definition';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';\nimport { typeFromAST } from './typeFromAST';\nimport find from '../jsutils/find';\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  TypeInfo.prototype.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  TypeInfo.prototype.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  TypeInfo.prototype.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  TypeInfo.prototype.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  }; // Flow does not yet handle this case.\n\n\n  TypeInfo.prototype.enter = function enter(node\n  /* ASTNode */\n  ) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = getNamedType(this.getType());\n\n        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n        break;\n\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef = void 0;\n        var fieldType = void 0;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        var type = void 0;\n\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n\n        this._typeStack.push(isObjectType(type) ? type : undefined);\n\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = typeFromAST(schema, node.type);\n\n        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n        break;\n\n      case Kind.ARGUMENT:\n        var argDef = void 0;\n        var argType = void 0;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = find(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n        break;\n\n      case Kind.LIST:\n        var listType = getNullableType(this.getInputType());\n        var itemType = isListType(listType) ? listType.ofType : listType;\n\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n        break;\n\n      case Kind.OBJECT_FIELD:\n        var objectType = getNamedType(this.getInputType());\n        var inputFieldType = void 0;\n\n        if (isInputObjectType(objectType)) {\n          var inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n        break;\n\n      case Kind.ENUM:\n        var enumType = getNamedType(this.getInputType());\n        var enumValue = void 0;\n\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  TypeInfo.prototype.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/TypeInfo.js"],"names":["_classCallCheck","instance","Constructor","TypeError","Kind","isObjectType","isInterfaceType","isEnumType","isInputObjectType","isListType","isCompositeType","isInputType","isOutputType","getNullableType","getNamedType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","find","TypeInfo","schema","getFieldDefFn","initialType","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","prototype","getType","length","getParentType","getInputType","getParentInputType","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","value","OPERATION_DEFINITION","operation","getQueryType","getMutationType","getSubscriptionType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","argDef","argType","fieldOrDirective","args","arg","LIST","listType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","leave","pop","fieldNode"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;AAEzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASC,IAAT,QAAqB,mBAArB;AACA,SAASC,YAAT,EAAuBC,eAAvB,EAAwCC,UAAxC,EAAoDC,iBAApD,EAAuEC,UAAvE,EAAmFC,eAAnF,EAAoGC,WAApG,EAAiHC,YAAjH,EAA+HC,eAA/H,EAAgJC,YAAhJ,QAAoK,oBAApK;AAEA,SAASC,kBAAT,EAA6BC,gBAA7B,EAA+CC,oBAA/C,QAA2E,uBAA3E;AAEA,SAASC,WAAT,QAA4B,eAA5B;AACA,OAAOC,IAAP,MAAiB,iBAAjB;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,QAAQ,GAAG,YAAY;AAChC,WAASA,QAAT,CAAkBC,MAAlB,EACA;AACA;AACAC,EAAAA,aAHA,EAIA;AACAC,EAAAA,WALA,EAKa;AACXvB,IAAAA,eAAe,CAAC,IAAD,EAAOoB,QAAP,CAAf;;AAEA,SAAKI,OAAL,GAAeH,MAAf;AACA,SAAKI,UAAL,GAAkB,EAAlB;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,YAAL,GAAoBV,aAAa,IAAIW,WAArC;;AACA,QAAIV,WAAJ,EAAiB;AACf,UAAIZ,WAAW,CAACY,WAAD,CAAf,EAA8B;AAC5B,aAAKI,eAAL,CAAqBO,IAArB,CAA0BX,WAA1B;AACD;;AACD,UAAIb,eAAe,CAACa,WAAD,CAAnB,EAAkC;AAChC,aAAKG,gBAAL,CAAsBQ,IAAtB,CAA2BX,WAA3B;AACD;;AACD,UAAIX,YAAY,CAACW,WAAD,CAAhB,EAA+B;AAC7B,aAAKE,UAAL,CAAgBS,IAAhB,CAAqBX,WAArB;AACD;AACF;AACF;;AAEDH,EAAAA,QAAQ,CAACe,SAAT,CAAmBC,OAAnB,GAA6B,SAASA,OAAT,GAAmB;AAC9C,QAAI,KAAKX,UAAL,CAAgBY,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,aAAO,KAAKZ,UAAL,CAAgB,KAAKA,UAAL,CAAgBY,MAAhB,GAAyB,CAAzC,CAAP;AACD;AACF,GAJD;;AAMAjB,EAAAA,QAAQ,CAACe,SAAT,CAAmBG,aAAnB,GAAmC,SAASA,aAAT,GAAyB;AAC1D,QAAI,KAAKZ,gBAAL,CAAsBW,MAAtB,GAA+B,CAAnC,EAAsC;AACpC,aAAO,KAAKX,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBW,MAAtB,GAA+B,CAArD,CAAP;AACD;AACF,GAJD;;AAMAjB,EAAAA,QAAQ,CAACe,SAAT,CAAmBI,YAAnB,GAAkC,SAASA,YAAT,GAAwB;AACxD,QAAI,KAAKZ,eAAL,CAAqBU,MAArB,GAA8B,CAAlC,EAAqC;AACnC,aAAO,KAAKV,eAAL,CAAqB,KAAKA,eAAL,CAAqBU,MAArB,GAA8B,CAAnD,CAAP;AACD;AACF,GAJD;;AAMAjB,EAAAA,QAAQ,CAACe,SAAT,CAAmBK,kBAAnB,GAAwC,SAASA,kBAAT,GAA8B;AACpE,QAAI,KAAKb,eAAL,CAAqBU,MAArB,GAA8B,CAAlC,EAAqC;AACnC,aAAO,KAAKV,eAAL,CAAqB,KAAKA,eAAL,CAAqBU,MAArB,GAA8B,CAAnD,CAAP;AACD;AACF,GAJD;;AAMAjB,EAAAA,QAAQ,CAACe,SAAT,CAAmBF,WAAnB,GAAiC,SAASA,WAAT,GAAuB;AACtD,QAAI,KAAKL,cAAL,CAAoBS,MAApB,GAA6B,CAAjC,EAAoC;AAClC,aAAO,KAAKT,cAAL,CAAoB,KAAKA,cAAL,CAAoBS,MAApB,GAA6B,CAAjD,CAAP;AACD;AACF,GAJD;;AAMAjB,EAAAA,QAAQ,CAACe,SAAT,CAAmBM,YAAnB,GAAkC,SAASA,YAAT,GAAwB;AACxD,WAAO,KAAKZ,UAAZ;AACD,GAFD;;AAIAT,EAAAA,QAAQ,CAACe,SAAT,CAAmBO,WAAnB,GAAiC,SAASA,WAAT,GAAuB;AACtD,WAAO,KAAKZ,SAAZ;AACD,GAFD;;AAIAV,EAAAA,QAAQ,CAACe,SAAT,CAAmBQ,YAAnB,GAAkC,SAASA,YAAT,GAAwB;AACxD,WAAO,KAAKZ,UAAZ;AACD,GAFD,CArEgC,CAyEhC;;;AAGAX,EAAAA,QAAQ,CAACe,SAAT,CAAmBS,KAAnB,GAA2B,SAASA,KAAT,CAAeC;AAAK;AAApB,IAAmC;AAC5D,QAAIxB,MAAM,GAAG,KAAKG,OAAlB,CAD4D,CAE5D;AACA;AACA;AACA;;AACA,YAAQqB,IAAI,CAACC,IAAb;AACE,WAAK1C,IAAI,CAAC2C,aAAV;AACE,YAAIC,SAAS,GAAGlC,YAAY,CAAC,KAAKsB,OAAL,EAAD,CAA5B;;AACA,aAAKV,gBAAL,CAAsBQ,IAAtB,CAA2BxB,eAAe,CAACsC,SAAD,CAAf,GAA6BA,SAA7B,GAAyCC,SAApE;;AACA;;AACF,WAAK7C,IAAI,CAAC8C,KAAV;AACE,YAAIC,UAAU,GAAG,KAAKb,aAAL,EAAjB;AACA,YAAIc,QAAQ,GAAG,KAAK,CAApB;AACA,YAAIC,SAAS,GAAG,KAAK,CAArB;;AACA,YAAIF,UAAJ,EAAgB;AACdC,UAAAA,QAAQ,GAAG,KAAKpB,YAAL,CAAkBX,MAAlB,EAA0B8B,UAA1B,EAAsCN,IAAtC,CAAX;;AACA,cAAIO,QAAJ,EAAc;AACZC,YAAAA,SAAS,GAAGD,QAAQ,CAACE,IAArB;AACD;AACF;;AACD,aAAK1B,cAAL,CAAoBM,IAApB,CAAyBkB,QAAzB;;AACA,aAAK3B,UAAL,CAAgBS,IAAhB,CAAqBtB,YAAY,CAACyC,SAAD,CAAZ,GAA0BA,SAA1B,GAAsCJ,SAA3D;;AACA;;AACF,WAAK7C,IAAI,CAACmD,SAAV;AACE,aAAK1B,UAAL,GAAkBR,MAAM,CAACoB,YAAP,CAAoBI,IAAI,CAACW,IAAL,CAAUC,KAA9B,CAAlB;AACA;;AACF,WAAKrD,IAAI,CAACsD,oBAAV;AACE,YAAIJ,IAAI,GAAG,KAAK,CAAhB;;AACA,YAAIT,IAAI,CAACc,SAAL,KAAmB,OAAvB,EAAgC;AAC9BL,UAAAA,IAAI,GAAGjC,MAAM,CAACuC,YAAP,EAAP;AACD,SAFD,MAEO,IAAIf,IAAI,CAACc,SAAL,KAAmB,UAAvB,EAAmC;AACxCL,UAAAA,IAAI,GAAGjC,MAAM,CAACwC,eAAP,EAAP;AACD,SAFM,MAEA,IAAIhB,IAAI,CAACc,SAAL,KAAmB,cAAvB,EAAuC;AAC5CL,UAAAA,IAAI,GAAGjC,MAAM,CAACyC,mBAAP,EAAP;AACD;;AACD,aAAKrC,UAAL,CAAgBS,IAAhB,CAAqB7B,YAAY,CAACiD,IAAD,CAAZ,GAAqBA,IAArB,GAA4BL,SAAjD;;AACA;;AACF,WAAK7C,IAAI,CAAC2D,eAAV;AACA,WAAK3D,IAAI,CAAC4D,mBAAV;AACE,YAAIC,gBAAgB,GAAGpB,IAAI,CAACqB,aAA5B;AACA,YAAIC,UAAU,GAAGF,gBAAgB,GAAG/C,WAAW,CAACG,MAAD,EAAS4C,gBAAT,CAAd,GAA2CnD,YAAY,CAAC,KAAKsB,OAAL,EAAD,CAAxF;;AACA,aAAKX,UAAL,CAAgBS,IAAhB,CAAqBtB,YAAY,CAACuD,UAAD,CAAZ,GAA2BA,UAA3B,GAAwClB,SAA7D;;AACA;;AACF,WAAK7C,IAAI,CAACgE,mBAAV;AACE,YAAIC,SAAS,GAAGnD,WAAW,CAACG,MAAD,EAASwB,IAAI,CAACS,IAAd,CAA3B;;AACA,aAAK3B,eAAL,CAAqBO,IAArB,CAA0BvB,WAAW,CAAC0D,SAAD,CAAX,GAAyBA,SAAzB,GAAqCpB,SAA/D;;AACA;;AACF,WAAK7C,IAAI,CAACkE,QAAV;AACE,YAAIC,MAAM,GAAG,KAAK,CAAlB;AACA,YAAIC,OAAO,GAAG,KAAK,CAAnB;AACA,YAAIC,gBAAgB,GAAG,KAAKhC,YAAL,MAAuB,KAAKR,WAAL,EAA9C;;AACA,YAAIwC,gBAAJ,EAAsB;AACpBF,UAAAA,MAAM,GAAGpD,IAAI,CAACsD,gBAAgB,CAACC,IAAlB,EAAwB,UAAUC,GAAV,EAAe;AAClD,mBAAOA,GAAG,CAACnB,IAAJ,KAAaX,IAAI,CAACW,IAAL,CAAUC,KAA9B;AACD,WAFY,CAAb;;AAGA,cAAIc,MAAJ,EAAY;AACVC,YAAAA,OAAO,GAAGD,MAAM,CAACjB,IAAjB;AACD;AACF;;AACD,aAAKxB,SAAL,GAAiByC,MAAjB;;AACA,aAAK5C,eAAL,CAAqBO,IAArB,CAA0BvB,WAAW,CAAC6D,OAAD,CAAX,GAAuBA,OAAvB,GAAiCvB,SAA3D;;AACA;;AACF,WAAK7C,IAAI,CAACwE,IAAV;AACE,YAAIC,QAAQ,GAAGhE,eAAe,CAAC,KAAK0B,YAAL,EAAD,CAA9B;AACA,YAAIuC,QAAQ,GAAGrE,UAAU,CAACoE,QAAD,CAAV,GAAuBA,QAAQ,CAACE,MAAhC,GAAyCF,QAAxD;;AACA,aAAKlD,eAAL,CAAqBO,IAArB,CAA0BvB,WAAW,CAACmE,QAAD,CAAX,GAAwBA,QAAxB,GAAmC7B,SAA7D;;AACA;;AACF,WAAK7C,IAAI,CAAC4E,YAAV;AACE,YAAIC,UAAU,GAAGnE,YAAY,CAAC,KAAKyB,YAAL,EAAD,CAA7B;AACA,YAAI2C,cAAc,GAAG,KAAK,CAA1B;;AACA,YAAI1E,iBAAiB,CAACyE,UAAD,CAArB,EAAmC;AACjC,cAAIE,UAAU,GAAGF,UAAU,CAACG,SAAX,GAAuBvC,IAAI,CAACW,IAAL,CAAUC,KAAjC,CAAjB;;AACA,cAAI0B,UAAJ,EAAgB;AACdD,YAAAA,cAAc,GAAGC,UAAU,CAAC7B,IAA5B;AACD;AACF;;AACD,aAAK3B,eAAL,CAAqBO,IAArB,CAA0BvB,WAAW,CAACuE,cAAD,CAAX,GAA8BA,cAA9B,GAA+CjC,SAAzE;;AACA;;AACF,WAAK7C,IAAI,CAACiF,IAAV;AACE,YAAIC,QAAQ,GAAGxE,YAAY,CAAC,KAAKyB,YAAL,EAAD,CAA3B;AACA,YAAIgD,SAAS,GAAG,KAAK,CAArB;;AACA,YAAIhF,UAAU,CAAC+E,QAAD,CAAd,EAA0B;AACxBC,UAAAA,SAAS,GAAGD,QAAQ,CAACE,QAAT,CAAkB3C,IAAI,CAACY,KAAvB,CAAZ;AACD;;AACD,aAAK1B,UAAL,GAAkBwD,SAAlB;AACA;AAhFJ;AAkFD,GAxFD;;AA0FAnE,EAAAA,QAAQ,CAACe,SAAT,CAAmBsD,KAAnB,GAA2B,SAASA,KAAT,CAAe5C,IAAf,EAAqB;AAC9C,YAAQA,IAAI,CAACC,IAAb;AACE,WAAK1C,IAAI,CAAC2C,aAAV;AACE,aAAKrB,gBAAL,CAAsBgE,GAAtB;;AACA;;AACF,WAAKtF,IAAI,CAAC8C,KAAV;AACE,aAAKtB,cAAL,CAAoB8D,GAApB;;AACA,aAAKjE,UAAL,CAAgBiE,GAAhB;;AACA;;AACF,WAAKtF,IAAI,CAACmD,SAAV;AACE,aAAK1B,UAAL,GAAkB,IAAlB;AACA;;AACF,WAAKzB,IAAI,CAACsD,oBAAV;AACA,WAAKtD,IAAI,CAAC2D,eAAV;AACA,WAAK3D,IAAI,CAAC4D,mBAAV;AACE,aAAKvC,UAAL,CAAgBiE,GAAhB;;AACA;;AACF,WAAKtF,IAAI,CAACgE,mBAAV;AACE,aAAKzC,eAAL,CAAqB+D,GAArB;;AACA;;AACF,WAAKtF,IAAI,CAACkE,QAAV;AACE,aAAKxC,SAAL,GAAiB,IAAjB;;AACA,aAAKH,eAAL,CAAqB+D,GAArB;;AACA;;AACF,WAAKtF,IAAI,CAACwE,IAAV;AACA,WAAKxE,IAAI,CAAC4E,YAAV;AACE,aAAKrD,eAAL,CAAqB+D,GAArB;;AACA;;AACF,WAAKtF,IAAI,CAACiF,IAAV;AACE,aAAKtD,UAAL,GAAkB,IAAlB;AACA;AA7BJ;AA+BD,GAhCD;;AAkCA,SAAOX,QAAP;AACD,CAzMqB,EAAf;AA2MP;AACA;AACA;AACA;AACA;;AACA,SAASa,WAAT,CAAqBZ,MAArB,EAA6B8B,UAA7B,EAAyCwC,SAAzC,EAAoD;AAClD,MAAInC,IAAI,GAAGmC,SAAS,CAACnC,IAAV,CAAeC,KAA1B;;AACA,MAAID,IAAI,KAAKzC,kBAAkB,CAACyC,IAA5B,IAAoCnC,MAAM,CAACuC,YAAP,OAA0BT,UAAlE,EAA8E;AAC5E,WAAOpC,kBAAP;AACD;;AACD,MAAIyC,IAAI,KAAKxC,gBAAgB,CAACwC,IAA1B,IAAkCnC,MAAM,CAACuC,YAAP,OAA0BT,UAAhE,EAA4E;AAC1E,WAAOnC,gBAAP;AACD;;AACD,MAAIwC,IAAI,KAAKvC,oBAAoB,CAACuC,IAA9B,IAAsC9C,eAAe,CAACyC,UAAD,CAAzD,EAAuE;AACrE,WAAOlC,oBAAP;AACD;;AACD,MAAIZ,YAAY,CAAC8C,UAAD,CAAZ,IAA4B7C,eAAe,CAAC6C,UAAD,CAA/C,EAA6D;AAC3D,WAAOA,UAAU,CAACiC,SAAX,GAAuB5B,IAAvB,CAAP;AACD;AACF","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { Kind } from '../language/kinds';\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from '../type/definition';\n\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';\n\nimport { typeFromAST } from './typeFromAST';\nimport find from '../jsutils/find';\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nexport var TypeInfo = function () {\n  function TypeInfo(schema,\n  // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn,\n  // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  TypeInfo.prototype.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  TypeInfo.prototype.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  TypeInfo.prototype.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  TypeInfo.prototype.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  // Flow does not yet handle this case.\n\n\n  TypeInfo.prototype.enter = function enter(node /* ASTNode */) {\n    var schema = this._schema;\n    // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = getNamedType(this.getType());\n        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n        break;\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef = void 0;\n        var fieldType = void 0;\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n        this._fieldDefStack.push(fieldDef);\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n        break;\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n      case Kind.OPERATION_DEFINITION:\n        var type = void 0;\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n        this._typeStack.push(isObjectType(type) ? type : undefined);\n        break;\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n        break;\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = typeFromAST(schema, node.type);\n        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n        break;\n      case Kind.ARGUMENT:\n        var argDef = void 0;\n        var argType = void 0;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n        if (fieldOrDirective) {\n          argDef = find(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n        this._argument = argDef;\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n        break;\n      case Kind.LIST:\n        var listType = getNullableType(this.getInputType());\n        var itemType = isListType(listType) ? listType.ofType : listType;\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n        break;\n      case Kind.OBJECT_FIELD:\n        var objectType = getNamedType(this.getInputType());\n        var inputFieldType = void 0;\n        if (isInputObjectType(objectType)) {\n          var inputField = objectType.getFields()[node.name.value];\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n        break;\n      case Kind.ENUM:\n        var enumType = getNamedType(this.getInputType());\n        var enumValue = void 0;\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  TypeInfo.prototype.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n        break;\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n        this._typeStack.pop();\n        break;\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n        break;\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ARGUMENT:\n        this._argument = null;\n        this._inputTypeStack.pop();\n        break;\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}"]},"metadata":{},"sourceType":"module"}