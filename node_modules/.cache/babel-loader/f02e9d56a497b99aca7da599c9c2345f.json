{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fieldsConflictMessage = fieldsConflictMessage;\nexports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;\n\nvar _error = require('../../error');\n\nvar _find = require('../../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _kinds = require('../../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _printer = require('../../language/printer');\n\nvar _definition = require('../../type/definition');\n\nvar _typeFromAST = require('../../utilities/typeFromAST');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction fieldsConflictMessage(responseName, reason) {\n  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nfunction OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragments = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, context.getParentType(), selectionSet);\n      conflicts.forEach(function (_ref2) {\n        var _ref2$ = _ref2[0],\n            responseName = _ref2$[0],\n            reason = _ref2$[1],\n            fields1 = _ref2[1],\n            fields2 = _ref2[2];\n        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      });\n    }\n  };\n} // Field name and reason.\n// Reason is a string, or a nested list of conflicts.\n// Tuple defining a field node in a context.\n// Map of array of those.\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\n\n\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap); // (B) Then collect conflicts between these fields and those represented by\n  // each spread fragment name found.\n\n  for (var i = 0; i < fragmentNames.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n    // selection set to collect conflicts between fragments spread together.\n    // This compares each item in the list of fragment names to every other item\n    // in that same list (except for itself).\n\n    for (var j = i + 1; j < fragmentNames.length; j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fragmentNames[i], fragmentNames[j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  } // No need to compare a fragment to itself.\n\n\n  if (fragment1 === fragment2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragments.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragments.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i = 0; _i < fragmentNames1.length; _i++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  Object.keys(fieldMap).forEach(function (responseName) {\n    var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  Object.keys(fieldMap1).forEach(function (responseName) {\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && parentType1 instanceof _definition.GraphQLObjectType && parentType2 instanceof _definition.GraphQLObjectType; // The return type for each field.\n\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = (0, _find2.default)(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (type1 instanceof _definition.GraphQLList) {\n    return type2 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (type2 instanceof _definition.GraphQLList) {\n    return type1 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (type1 instanceof _definition.GraphQLNonNull) {\n    return type2 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (type2 instanceof _definition.GraphQLNonNull) {\n    return type1 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n\n        if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;\n\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n        break;\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var reason = _ref3[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref4) {\n      var fields1 = _ref4[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref5) {\n      var fields2 = _ref5[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = Object.create(null);\n  }\n\n  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js"],"names":["Object","defineProperty","exports","value","fieldsConflictMessage","OverlappingFieldsCanBeMerged","_error","require","_find","_find2","_interopRequireDefault","_kinds","Kind","_interopRequireWildcard","_printer","_definition","_typeFromAST","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","_classCallCheck","instance","Constructor","TypeError","responseName","reason","reasonMessage","Array","isArray","map","_ref","subreason","join","context","comparedFragments","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","forEach","_ref2","_ref2$","fields1","fields2","reportError","GraphQLError","concat","parentType","_getFieldsAndFragment","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","i","length","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","fragmentName1","fragmentName2","fragment1","fragment2","has","add","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","_getFieldsAndFragment2","_getFieldsAndFragment3","_i","_j","keys","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","field1","field2","node1","def1","node2","def2","GraphQLObjectType","type1","type","type2","name1","name","name2","sameArguments","arguments","doTypesConflict","String","getNamedType","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","argument","sameValue","value1","value2","print","GraphQLList","ofType","GraphQLNonNull","isLeafType","cached","get","nodeAndDefs","create","_collectFieldsAndFragmentNames","set","fragmentType","typeFromAST","getSchema","typeCondition","selections","selection","kind","FIELD","fieldName","fieldDef","GraphQLInterfaceType","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref3","reduce","allFields","_ref4","_ref5","_data","a","b","first","result","undefined","_pairSetAdd","data"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fieldsConflictMessage = fieldsConflictMessage;\nexports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;\n\nvar _error = require('../../error');\n\nvar _find = require('../../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _kinds = require('../../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _printer = require('../../language/printer');\n\nvar _definition = require('../../type/definition');\n\nvar _typeFromAST = require('../../utilities/typeFromAST');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           * \n                                                                                                                                                           */\n\nfunction fieldsConflictMessage(responseName, reason) {\n  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n    }).join(' and ');\n  }\n  return reason;\n}\n\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\nfunction OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragments = new PairSet();\n\n  // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n  var cachedFieldsAndFragmentNames = new Map();\n\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, context.getParentType(), selectionSet);\n      conflicts.forEach(function (_ref2) {\n        var _ref2$ = _ref2[0],\n            responseName = _ref2$[0],\n            reason = _ref2$[1],\n            fields1 = _ref2[1],\n            fields2 = _ref2[2];\n        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      });\n    }\n  };\n}\n// Field name and reason.\n\n// Reason is a string, or a nested list of conflicts.\n\n// Tuple defining a field node in a context.\n\n// Map of array of those.\n\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1];\n\n  // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap);\n\n  // (B) Then collect conflicts between these fields and those represented by\n  // each spread fragment name found.\n  for (var i = 0; i < fragmentNames.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fieldMap, fragmentNames[i]);\n    // (C) Then compare this fragment with all other fragments found in this\n    // selection set to collect conflicts between fragments spread together.\n    // This compares each item in the list of fragment names to every other item\n    // in that same list (except for itself).\n    for (var j = i + 1; j < fragmentNames.length; j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fragmentNames[i], fragmentNames[j]);\n    }\n  }\n  return conflicts;\n}\n\n// Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1];\n\n  // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fieldMap2);\n\n  // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n}\n\n// Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  // No need to compare a fragment to itself.\n  if (fragment1 === fragment2) {\n    return;\n  }\n\n  // Memoize so two fragments are not compared for conflicts more than once.\n  if (comparedFragments.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragments.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1];\n\n  // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  }\n\n  // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n}\n\n// Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1];\n\n  // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n  }\n\n  // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n  }\n\n  // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n  for (var _i = 0; _i < fragmentNames1.length; _i++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);\n    }\n  }\n  return conflicts;\n}\n\n// Collect all Conflicts \"within\" one collection of fields.\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  Object.keys(fieldMap).forEach(function (responseName) {\n    var fields = fieldMap[responseName];\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  Object.keys(fieldMap1).forEach(function (responseName) {\n    var fields2 = fieldMap2[responseName];\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2];\n\n  // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && parentType1 instanceof _definition.GraphQLObjectType && parentType2 instanceof _definition.GraphQLObjectType;\n\n  // The return type for each field.\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];\n    }\n\n    // Two field calls must have the same arguments.\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];\n  }\n\n  // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(function (argument1) {\n    var argument2 = (0, _find2.default)(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);\n}\n\n// Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\nfunction doTypesConflict(type1, type2) {\n  if (type1 instanceof _definition.GraphQLList) {\n    return type2 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (type2 instanceof _definition.GraphQLList) {\n    return type1 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (type1 instanceof _definition.GraphQLNonNull) {\n    return type2 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (type2 instanceof _definition.GraphQLNonNull) {\n    return type1 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n}\n\n// Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n  return cached;\n}\n\n// Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n        if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n        break;\n    }\n  }\n}\n\n// Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var reason = _ref3[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref4) {\n      var fields1 = _ref4[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref5) {\n      var fields2 = _ref5[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\nvar PairSet = function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = Object.create(null);\n  }\n\n  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n    if (result === undefined) {\n      return false;\n    }\n    // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n    return true;\n  };\n\n  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n  map[b] = areMutuallyExclusive;\n}"]},"metadata":{},"sourceType":"script"}