{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyMap = require('../jsutils/keyMap');\n\nvar _keyMap2 = _interopRequireDefault(_keyMap);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _buildASTSchema = require('./buildASTSchema');\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _schema = require('../type/schema');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nvar _scalars = require('../type/scalars');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction extendSchema(schema, documentAST) {\n  !(schema instanceof _schema.GraphQLSchema) ? (0, _invariant2.default)(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? (0, _invariant2.default)(0, 'Must provide valid Document AST') : void 0; // Collect the type definitions and extensions found in the document.\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n\n        if (schema.getType(typeName)) {\n          throw new _GraphQLError.GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n\n        typeDefinitionMap[typeName] = def;\n        break;\n\n      case Kind.TYPE_EXTENSION_DEFINITION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.definition.name.value;\n        var existingType = schema.getType(extendedTypeName);\n\n        if (!existingType) {\n          throw new _GraphQLError.GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def.definition]);\n        }\n\n        if (!(existingType instanceof _definition.GraphQLObjectType)) {\n          throw new _GraphQLError.GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def.definition]);\n        }\n\n        var extensions = typeExtensionsMap[extendedTypeName];\n\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n\n        if (existingDirective) {\n          throw new _GraphQLError.GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n\n        directiveDefinitions.push(def);\n        break;\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  } // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars and introspection types. All\n  // functions below are inline so that this type def cache is within the scope\n  // of the closure.\n\n\n  var typeDefCache = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  }; // Get the root Query, Mutation, and Subscription object types.\n\n  var queryType = getTypeFromDef(schema.getQueryType());\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null; // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return getTypeFromDef(typeMap[typeName]);\n  }); // Do the same with new types, appending to the list of defined types.\n\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(getTypeFromAST(typeDefinitionMap[typeName]));\n  }); // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? (0, _invariant2.default)(0, 'schema must have default directives') : void 0;\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return getDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = _getNamedType(typeDef.name);\n\n    !type ? (0, _invariant2.default)(0, 'Missing type from schema') : void 0;\n    return type;\n  }\n\n  function getTypeFromAST(node) {\n    var type = _getNamedType(node.name.value);\n\n    if (!type) {\n      throw new _GraphQLError.GraphQLError('Unknown type: \"' + node.name.value + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n\n    return type;\n  }\n\n  function getObjectTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Must be Object type.') : void 0;\n    return type;\n  }\n\n  function getInterfaceTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Must be Interface type.') : void 0;\n    return type;\n  }\n\n  function getInputTypeFromAST(node) {\n    return (0, _definition.assertInputType)(getTypeFromAST(node));\n  }\n\n  function getOutputTypeFromAST(node) {\n    return (0, _definition.assertOutputType)(getTypeFromAST(node));\n  } // Given a name, returns a type from either the existing schema or an\n  // added type.\n\n\n  function _getNamedType(typeName) {\n    var cachedTypeDef = typeDefCache[typeName];\n\n    if (cachedTypeDef) {\n      return cachedTypeDef;\n    }\n\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      var typeDef = extendType(existingType);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n\n    var typeNode = typeDefinitionMap[typeName];\n\n    if (typeNode) {\n      var _typeDef = buildType(typeNode);\n\n      typeDefCache[typeName] = _typeDef;\n      return _typeDef;\n    }\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function extendType(type) {\n    if (type instanceof _definition.GraphQLObjectType) {\n      return extendObjectType(type);\n    }\n\n    if (type instanceof _definition.GraphQLInterfaceType) {\n      return extendInterfaceType(type);\n    }\n\n    if (type instanceof _definition.GraphQLUnionType) {\n      return extendUnionType(type);\n    }\n\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = type.extensionASTNodes;\n\n    if (typeExtensionsMap[name]) {\n      extensionASTNodes = extensionASTNodes.concat(typeExtensionsMap[name]);\n    }\n\n    return new _definition.GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new _definition.GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new _definition.GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.interfaces.forEach(function (namedType) {\n          var interfaceName = namedType.name.value;\n\n          if (interfaces.some(function (def) {\n            return def.name === interfaceName;\n          })) {\n            throw new _GraphQLError.GraphQLError('Type \"' + type.name + '\" already implements \"' + interfaceName + '\". ' + 'It cannot also be implemented in this type extension.', [namedType]);\n          }\n\n          interfaces.push(getInterfaceTypeFromAST(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: (0, _keyMap2.default)(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    }); // If there are any extensions to the fields, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n\n          if (oldFieldMap[fieldName]) {\n            throw new _GraphQLError.GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n\n          newFieldMap[fieldName] = {\n            description: (0, _buildASTSchema.getDescription)(field),\n            type: buildOutputFieldType(field.type),\n            args: buildInputValues(field.arguments),\n            deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n            astNode: field\n          };\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (typeDef instanceof _definition.GraphQLList) {\n      return new _definition.GraphQLList(extendFieldType(typeDef.ofType));\n    }\n\n    if (typeDef instanceof _definition.GraphQLNonNull) {\n      return new _definition.GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n\n    return getTypeFromDef(typeDef);\n  }\n\n  function buildType(typeNode) {\n    switch (typeNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return buildObjectType(typeNode);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return buildInterfaceType(typeNode);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return buildUnionType(typeNode);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return buildScalarType(typeNode);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return buildEnumType(typeNode);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return buildInputObjectType(typeNode);\n    }\n\n    throw new TypeError('Unknown type kind ' + typeNode.kind);\n  }\n\n  function buildObjectType(typeNode) {\n    return new _definition.GraphQLObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      interfaces: function interfaces() {\n        return buildImplementedInterfaces(typeNode);\n      },\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function buildInterfaceType(typeNode) {\n    return new _definition.GraphQLInterfaceType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildUnionType(typeNode) {\n    return new _definition.GraphQLUnionType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      types: typeNode.types.map(getObjectTypeFromAST),\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildScalarType(typeNode) {\n    return new _definition.GraphQLScalarType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      astNode: typeNode,\n      serialize: function serialize(id) {\n        return id;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildEnumType(typeNode) {\n    return new _definition.GraphQLEnumType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      values: (0, _keyValMap2.default)(typeNode.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: (0, _buildASTSchema.getDescription)(enumValue),\n          deprecationReason: (0, _buildASTSchema.getDeprecationReason)(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: typeNode\n    });\n  }\n\n  function buildInputObjectType(typeNode) {\n    return new _definition.GraphQLInputObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildInputValues(typeNode.fields);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && buildInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function buildImplementedInterfaces(typeNode) {\n    return typeNode.interfaces && typeNode.interfaces.map(getInterfaceTypeFromAST);\n  }\n\n  function buildFieldMap(typeNode) {\n    return (0, _keyValMap2.default)(typeNode.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: buildOutputFieldType(field.type),\n        description: (0, _buildASTSchema.getDescription)(field),\n        args: buildInputValues(field.arguments),\n        deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n        astNode: field\n      };\n    });\n  }\n\n  function buildInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = buildInputFieldType(value.type);\n      return {\n        type: type,\n        description: (0, _buildASTSchema.getDescription)(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function buildInputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildInputFieldType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildInputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n\n    return getInputTypeFromAST(typeNode);\n  }\n\n  function buildOutputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildOutputFieldType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildOutputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n\n    return getOutputTypeFromAST(typeNode);\n  }\n}\n\nfunction cannotExecuteExtendedSchema() {\n  throw new Error('Extended Schema cannot use Interface or Union types for execution.');\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/utilities/extendSchema.js"],"names":["Object","defineProperty","exports","value","extendSchema","_invariant","require","_invariant2","_interopRequireDefault","_keyMap","_keyMap2","_keyValMap","_keyValMap2","_buildASTSchema","_valueFromAST","_GraphQLError","_schema","_definition","_directives","_introspection","_scalars","_kinds","Kind","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","schema","documentAST","GraphQLSchema","kind","DOCUMENT","typeDefinitionMap","create","typeExtensionsMap","directiveDefinitions","i","definitions","length","def","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","typeName","name","getType","GraphQLError","TYPE_EXTENSION_DEFINITION","extendedTypeName","definition","existingType","GraphQLObjectType","extensions","push","DIRECTIVE_DEFINITION","directiveName","existingDirective","getDirective","keys","typeDefCache","String","GraphQLString","Int","GraphQLInt","Float","GraphQLFloat","Boolean","GraphQLBoolean","ID","GraphQLID","__Schema","__Directive","__DirectiveLocation","__Type","__Field","__InputValue","__EnumValue","__TypeKind","queryType","getTypeFromDef","getQueryType","existingMutationType","getMutationType","mutationType","existingSubscriptionType","getSubscriptionType","subscriptionType","typeMap","getTypeMap","types","map","forEach","getTypeFromAST","query","mutation","subscription","directives","getMergedDirectives","astNode","existingDirectives","getDirectives","newDirectives","directiveNode","concat","typeDef","type","_getNamedType","node","getObjectTypeFromAST","getInterfaceTypeFromAST","GraphQLInterfaceType","getInputTypeFromAST","assertInputType","getOutputTypeFromAST","assertOutputType","cachedTypeDef","extendType","typeNode","_typeDef","buildType","extendObjectType","extendInterfaceType","GraphQLUnionType","extendUnionType","extensionASTNodes","description","interfaces","extendImplementedInterfaces","fields","extendFieldMap","isTypeOf","resolveType","getTypes","getInterfaces","extension","namedType","interfaceName","some","newFieldMap","oldFieldMap","getFields","fieldName","field","deprecationReason","extendFieldType","args","arg","resolve","getDescription","buildOutputFieldType","buildInputValues","arguments","getDeprecationReason","GraphQLList","ofType","GraphQLNonNull","buildObjectType","buildInterfaceType","buildUnionType","buildScalarType","buildEnumType","buildInputObjectType","TypeError","buildImplementedInterfaces","buildFieldMap","cannotExecuteExtendedSchema","GraphQLScalarType","serialize","id","parseValue","parseLiteral","GraphQLEnumType","values","enumValue","GraphQLInputObjectType","GraphQLDirective","locations","buildInputFieldType","defaultValue","valueFromAST","LIST_TYPE","NON_NULL_TYPE","nullableType","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyMap = require('../jsutils/keyMap');\n\nvar _keyMap2 = _interopRequireDefault(_keyMap);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _buildASTSchema = require('./buildASTSchema');\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _schema = require('../type/schema');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nvar _scalars = require('../type/scalars');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction extendSchema(schema, documentAST) {\n  !(schema instanceof _schema.GraphQLSchema) ? (0, _invariant2.default)(0, 'Must provide valid GraphQLSchema') : void 0;\n\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? (0, _invariant2.default)(0, 'Must provide valid Document AST') : void 0;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null);\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n        if (schema.getType(typeName)) {\n          throw new _GraphQLError.GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n        typeDefinitionMap[typeName] = def;\n        break;\n      case Kind.TYPE_EXTENSION_DEFINITION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.definition.name.value;\n        var existingType = schema.getType(extendedTypeName);\n        if (!existingType) {\n          throw new _GraphQLError.GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def.definition]);\n        }\n        if (!(existingType instanceof _definition.GraphQLObjectType)) {\n          throw new _GraphQLError.GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def.definition]);\n        }\n        var extensions = typeExtensionsMap[extendedTypeName];\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n        if (existingDirective) {\n          throw new _GraphQLError.GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n        directiveDefinitions.push(def);\n        break;\n    }\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars and introspection types. All\n  // functions below are inline so that this type def cache is within the scope\n  // of the closure.\n  var typeDefCache = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  };\n\n  // Get the root Query, Mutation, and Subscription object types.\n  var queryType = getTypeFromDef(schema.getQueryType());\n\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;\n\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null;\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return getTypeFromDef(typeMap[typeName]);\n  });\n\n  // Do the same with new types, appending to the list of defined types.\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(getTypeFromAST(typeDefinitionMap[typeName]));\n  });\n\n  // Then produce and return a Schema with these types.\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode\n  });\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? (0, _invariant2.default)(0, 'schema must have default directives') : void 0;\n\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return getDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = _getNamedType(typeDef.name);\n    !type ? (0, _invariant2.default)(0, 'Missing type from schema') : void 0;\n    return type;\n  }\n\n  function getTypeFromAST(node) {\n    var type = _getNamedType(node.name.value);\n    if (!type) {\n      throw new _GraphQLError.GraphQLError('Unknown type: \"' + node.name.value + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n    return type;\n  }\n\n  function getObjectTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Must be Object type.') : void 0;\n    return type;\n  }\n\n  function getInterfaceTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Must be Interface type.') : void 0;\n    return type;\n  }\n\n  function getInputTypeFromAST(node) {\n    return (0, _definition.assertInputType)(getTypeFromAST(node));\n  }\n\n  function getOutputTypeFromAST(node) {\n    return (0, _definition.assertOutputType)(getTypeFromAST(node));\n  }\n\n  // Given a name, returns a type from either the existing schema or an\n  // added type.\n  function _getNamedType(typeName) {\n    var cachedTypeDef = typeDefCache[typeName];\n    if (cachedTypeDef) {\n      return cachedTypeDef;\n    }\n\n    var existingType = schema.getType(typeName);\n    if (existingType) {\n      var typeDef = extendType(existingType);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n\n    var typeNode = typeDefinitionMap[typeName];\n    if (typeNode) {\n      var _typeDef = buildType(typeNode);\n      typeDefCache[typeName] = _typeDef;\n      return _typeDef;\n    }\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function extendType(type) {\n    if (type instanceof _definition.GraphQLObjectType) {\n      return extendObjectType(type);\n    }\n    if (type instanceof _definition.GraphQLInterfaceType) {\n      return extendInterfaceType(type);\n    }\n    if (type instanceof _definition.GraphQLUnionType) {\n      return extendUnionType(type);\n    }\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = type.extensionASTNodes;\n    if (typeExtensionsMap[name]) {\n      extensionASTNodes = extensionASTNodes.concat(typeExtensionsMap[name]);\n    }\n\n    return new _definition.GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new _definition.GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new _definition.GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef);\n\n    // If there are any extensions to the interfaces, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.interfaces.forEach(function (namedType) {\n          var interfaceName = namedType.name.value;\n          if (interfaces.some(function (def) {\n            return def.name === interfaceName;\n          })) {\n            throw new _GraphQLError.GraphQLError('Type \"' + type.name + '\" already implements \"' + interfaceName + '\". ' + 'It cannot also be implemented in this type extension.', [namedType]);\n          }\n          interfaces.push(getInterfaceTypeFromAST(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: (0, _keyMap2.default)(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    });\n\n    // If there are any extensions to the fields, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n          if (oldFieldMap[fieldName]) {\n            throw new _GraphQLError.GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n          newFieldMap[fieldName] = {\n            description: (0, _buildASTSchema.getDescription)(field),\n            type: buildOutputFieldType(field.type),\n            args: buildInputValues(field.arguments),\n            deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n            astNode: field\n          };\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (typeDef instanceof _definition.GraphQLList) {\n      return new _definition.GraphQLList(extendFieldType(typeDef.ofType));\n    }\n    if (typeDef instanceof _definition.GraphQLNonNull) {\n      return new _definition.GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n    return getTypeFromDef(typeDef);\n  }\n\n  function buildType(typeNode) {\n    switch (typeNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return buildObjectType(typeNode);\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return buildInterfaceType(typeNode);\n      case Kind.UNION_TYPE_DEFINITION:\n        return buildUnionType(typeNode);\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return buildScalarType(typeNode);\n      case Kind.ENUM_TYPE_DEFINITION:\n        return buildEnumType(typeNode);\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return buildInputObjectType(typeNode);\n    }\n    throw new TypeError('Unknown type kind ' + typeNode.kind);\n  }\n\n  function buildObjectType(typeNode) {\n    return new _definition.GraphQLObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      interfaces: function interfaces() {\n        return buildImplementedInterfaces(typeNode);\n      },\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function buildInterfaceType(typeNode) {\n    return new _definition.GraphQLInterfaceType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildUnionType(typeNode) {\n    return new _definition.GraphQLUnionType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      types: typeNode.types.map(getObjectTypeFromAST),\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildScalarType(typeNode) {\n    return new _definition.GraphQLScalarType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      astNode: typeNode,\n      serialize: function serialize(id) {\n        return id;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildEnumType(typeNode) {\n    return new _definition.GraphQLEnumType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      values: (0, _keyValMap2.default)(typeNode.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: (0, _buildASTSchema.getDescription)(enumValue),\n          deprecationReason: (0, _buildASTSchema.getDeprecationReason)(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: typeNode\n    });\n  }\n\n  function buildInputObjectType(typeNode) {\n    return new _definition.GraphQLInputObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildInputValues(typeNode.fields);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && buildInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function buildImplementedInterfaces(typeNode) {\n    return typeNode.interfaces && typeNode.interfaces.map(getInterfaceTypeFromAST);\n  }\n\n  function buildFieldMap(typeNode) {\n    return (0, _keyValMap2.default)(typeNode.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: buildOutputFieldType(field.type),\n        description: (0, _buildASTSchema.getDescription)(field),\n        args: buildInputValues(field.arguments),\n        deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n        astNode: field\n      };\n    });\n  }\n\n  function buildInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = buildInputFieldType(value.type);\n      return {\n        type: type,\n        description: (0, _buildASTSchema.getDescription)(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function buildInputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildInputFieldType(typeNode.type));\n    }\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildInputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n    return getInputTypeFromAST(typeNode);\n  }\n\n  function buildOutputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildOutputFieldType(typeNode.type));\n    }\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildOutputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n    return getOutputTypeFromAST(typeNode);\n  }\n}\n\nfunction cannotExecuteExtendedSchema() {\n  throw new Error('Extended Schema cannot use Interface or Union types for execution.');\n}"]},"metadata":{},"sourceType":"script"}