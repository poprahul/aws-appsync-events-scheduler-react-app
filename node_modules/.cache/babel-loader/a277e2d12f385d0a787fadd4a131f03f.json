{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { GraphQLError } from '../error';\nimport find from '../jsutils/find';\nimport isInvalid from '../jsutils/isInvalid';\nimport keyMap from '../jsutils/keyMap';\nimport { coerceValue } from '../utilities/coerceValue';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { valueFromAST } from '../utilities/valueFromAST';\nimport { Kind } from '../language/kinds';\nimport { print } from '../language/printer';\nimport { isInputType, isNonNullType } from '../type/definition';\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getVariableValues(schema, varDefNodes, inputs) {\n  var errors = [];\n  var coercedValues = {};\n\n  for (var i = 0; i < varDefNodes.length; i++) {\n    var varDefNode = varDefNodes[i];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      errors.push(new GraphQLError('Variable \"$' + varName + '\" expected value of type ' + ('\"' + print(varDefNode.type) + '\" which cannot be used as an input type.'), [varDefNode.type]));\n    } else {\n      var value = inputs[varName];\n\n      if (isInvalid(value)) {\n        if (isNonNullType(varType)) {\n          errors.push(new GraphQLError('Variable \"$' + varName + '\" of required type ' + ('\"' + String(varType) + '\" was not provided.'), [varDefNode]));\n        } else if (varDefNode.defaultValue) {\n          coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n        }\n      } else {\n        var _coerced = coerceValue(value, varType, varDefNode);\n\n        var coercionErrors = _coerced.errors;\n\n        if (coercionErrors) {\n          (function () {\n            var messagePrelude = 'Variable \"$' + varName + '\" got invalid value ' + JSON.stringify(value) + '; ';\n            coercionErrors.forEach(function (error) {\n              error.message = messagePrelude + error.message;\n            });\n            errors.push.apply(errors, coercionErrors);\n          })();\n        } else {\n          coercedValues[varName] = _coerced.value;\n        }\n      }\n    }\n  }\n\n  return errors.length === 0 ? {\n    errors: undefined,\n    coerced: coercedValues\n  } : {\n    errors: errors,\n    coerced: undefined\n  };\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argDefs = def.args;\n  var argNodes = node.arguments;\n\n  if (!argDefs || !argNodes) {\n    return coercedValues;\n  }\n\n  var argNodeMap = keyMap(argNodes, function (arg) {\n    return arg.name.value;\n  });\n\n  for (var i = 0; i < argDefs.length; i++) {\n    var argDef = argDefs[i];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n    var defaultValue = argDef.defaultValue;\n\n    if (!argumentNode) {\n      if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type ' + ('\"' + String(argType) + '\" was not provided.'), [node]);\n      }\n    } else if (argumentNode.value.kind === Kind.VARIABLE) {\n      var variableName = argumentNode.value.name.value;\n\n      if (variableValues && Object.prototype.hasOwnProperty.call(variableValues, variableName) && !isInvalid(variableValues[variableName])) {\n        // Note: this does not check that this variable value is correct.\n        // This assumes that this query has been validated and the variable\n        // usage here is of the correct type.\n        coercedValues[name] = variableValues[variableName];\n      } else if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type \"' + String(argType) + '\" was ' + ('provided the variable \"$' + variableName + '\" which was not provided ') + 'a runtime value.', [argumentNode.value]);\n      }\n    } else {\n      var valueNode = argumentNode.value;\n      var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n      if (isInvalid(coercedValue)) {\n        // Note: ValuesOfCorrectType validation should catch this before\n        // execution. This is a runtime check to ensure execution does not\n        // continue with an invalid argument value.\n        throw new GraphQLError('Argument \"' + name + '\" has invalid value ' + print(valueNode) + '.', [argumentNode.value]);\n      }\n\n      coercedValues[name] = coercedValue;\n    }\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/execution/values.js"],"names":["GraphQLError","find","isInvalid","keyMap","coerceValue","typeFromAST","valueFromAST","Kind","print","isInputType","isNonNullType","getVariableValues","schema","varDefNodes","inputs","errors","coercedValues","i","length","varDefNode","varName","variable","name","value","varType","type","push","String","defaultValue","_coerced","coercionErrors","messagePrelude","JSON","stringify","forEach","error","message","apply","undefined","coerced","getArgumentValues","def","node","variableValues","argDefs","args","argNodes","arguments","argNodeMap","arg","argDef","argType","argumentNode","kind","VARIABLE","variableName","Object","prototype","hasOwnProperty","call","valueNode","coercedValue","getDirectiveValues","directiveDef","directiveNode","directives","directive"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { GraphQLError } from '../error';\nimport find from '../jsutils/find';\nimport isInvalid from '../jsutils/isInvalid';\nimport keyMap from '../jsutils/keyMap';\nimport { coerceValue } from '../utilities/coerceValue';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { valueFromAST } from '../utilities/valueFromAST';\nimport { Kind } from '../language/kinds';\nimport { print } from '../language/printer';\nimport { isInputType, isNonNullType } from '../type/definition';\n\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs) {\n  var errors = [];\n  var coercedValues = {};\n  for (var i = 0; i < varDefNodes.length; i++) {\n    var varDefNode = varDefNodes[i];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n    if (!isInputType(varType)) {\n      errors.push(new GraphQLError('Variable \"$' + varName + '\" expected value of type ' + ('\"' + print(varDefNode.type) + '\" which cannot be used as an input type.'), [varDefNode.type]));\n    } else {\n      var value = inputs[varName];\n      if (isInvalid(value)) {\n        if (isNonNullType(varType)) {\n          errors.push(new GraphQLError('Variable \"$' + varName + '\" of required type ' + ('\"' + String(varType) + '\" was not provided.'), [varDefNode]));\n        } else if (varDefNode.defaultValue) {\n          coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n        }\n      } else {\n        var _coerced = coerceValue(value, varType, varDefNode);\n        var coercionErrors = _coerced.errors;\n        if (coercionErrors) {\n          (function () {\n            var messagePrelude = 'Variable \"$' + varName + '\" got invalid value ' + JSON.stringify(value) + '; ';\n            coercionErrors.forEach(function (error) {\n              error.message = messagePrelude + error.message;\n            });\n            errors.push.apply(errors, coercionErrors);\n          })();\n        } else {\n          coercedValues[varName] = _coerced.value;\n        }\n      }\n    }\n  }\n  return errors.length === 0 ? { errors: undefined, coerced: coercedValues } : { errors: errors, coerced: undefined };\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argDefs = def.args;\n  var argNodes = node.arguments;\n  if (!argDefs || !argNodes) {\n    return coercedValues;\n  }\n  var argNodeMap = keyMap(argNodes, function (arg) {\n    return arg.name.value;\n  });\n  for (var i = 0; i < argDefs.length; i++) {\n    var argDef = argDefs[i];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n    var defaultValue = argDef.defaultValue;\n    if (!argumentNode) {\n      if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type ' + ('\"' + String(argType) + '\" was not provided.'), [node]);\n      }\n    } else if (argumentNode.value.kind === Kind.VARIABLE) {\n      var variableName = argumentNode.value.name.value;\n      if (variableValues && Object.prototype.hasOwnProperty.call(variableValues, variableName) && !isInvalid(variableValues[variableName])) {\n        // Note: this does not check that this variable value is correct.\n        // This assumes that this query has been validated and the variable\n        // usage here is of the correct type.\n        coercedValues[name] = variableValues[variableName];\n      } else if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type \"' + String(argType) + '\" was ' + ('provided the variable \"$' + variableName + '\" which was not provided ') + 'a runtime value.', [argumentNode.value]);\n      }\n    } else {\n      var valueNode = argumentNode.value;\n      var coercedValue = valueFromAST(valueNode, argType, variableValues);\n      if (isInvalid(coercedValue)) {\n        // Note: ValuesOfCorrectType validation should catch this before\n        // execution. This is a runtime check to ensure execution does not\n        // continue with an invalid argument value.\n        throw new GraphQLError('Argument \"' + name + '\" has invalid value ' + print(valueNode) + '.', [argumentNode.value]);\n      }\n      coercedValues[name] = coercedValue;\n    }\n  }\n  return coercedValues;\n}\n\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}"]},"metadata":{},"sourceType":"module"}