{"ast":null,"code":"\"use strict\";\n\nvar Cache = require(\"./cache.js\").Cache;\n\nvar tuple = require(\"immutable-tuple\").tuple;\n\nvar Entry = require(\"./entry.js\").Entry;\n\nvar getLocal = require(\"./local.js\").get; // Exported so that custom makeCacheKey functions can easily reuse the\n// default implementation (with different arguments).\n\n\nexports.defaultMakeCacheKey = tuple;\n\nfunction normalizeOptions(options) {\n  options = options || Object.create(null);\n\n  if (typeof options.makeCacheKey !== \"function\") {\n    options.makeCacheKey = tuple;\n  }\n\n  if (typeof options.max !== \"number\") {\n    options.max = Math.pow(2, 16);\n  }\n\n  return options;\n}\n\nfunction wrap(fn, options) {\n  options = normalizeOptions(options); // If this wrapped function is disposable, then its creator does not\n  // care about its return value, and it should be removed from the cache\n  // immediately when it no longer has any parents that depend on it.\n\n  var disposable = !!options.disposable;\n  var cache = new Cache({\n    max: options.max,\n    dispose: function (key, entry) {\n      entry.dispose();\n    }\n  });\n\n  function reportOrphan(entry) {\n    if (disposable) {\n      // Triggers the entry.dispose() call above.\n      cache.delete(entry.key);\n      return true;\n    }\n  }\n\n  function optimistic() {\n    if (disposable && !getLocal().currentParentEntry) {\n      // If there's no current parent computation, and this wrapped\n      // function is disposable (meaning we don't care about entry.value,\n      // just dependency tracking), then we can short-cut everything else\n      // in this function, because entry.recompute() is going to recycle\n      // the entry object without recomputing anything, anyway.\n      return;\n    }\n\n    var key = options.makeCacheKey.apply(null, arguments);\n\n    if (!key) {\n      return fn.apply(null, arguments);\n    }\n\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    var entry = cache.get(key);\n\n    if (entry) {\n      entry.args = args;\n    } else {\n      cache.set(key, entry = Entry.acquire(fn, key, args));\n      entry.subscribe = options.subscribe;\n\n      if (disposable) {\n        entry.reportOrphan = reportOrphan;\n      }\n    }\n\n    var value = entry.recompute(); // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n\n    cache.set(key, entry); // Clean up any excess entries in the cache, but only if this entry\n    // has no parents, which means we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n\n    if (entry.parents.size === 0) {\n      cache.clean();\n    } // If options.disposable is truthy, the caller of wrap is telling us\n    // they don't care about the result of entry.recompute(), so we should\n    // avoid returning the value, so it won't be accidentally used.\n\n\n    if (!disposable) {\n      return value;\n    }\n  }\n\n  optimistic.dirty = function () {\n    var key = options.makeCacheKey.apply(null, arguments);\n\n    if (!key) {\n      return;\n    }\n\n    if (!cache.has(key)) {\n      return;\n    }\n\n    cache.get(key).setDirty();\n  };\n\n  return optimistic;\n}\n\nexports.wrap = wrap;","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/optimism/lib/index.js"],"names":["Cache","require","tuple","Entry","getLocal","get","exports","defaultMakeCacheKey","normalizeOptions","options","Object","create","makeCacheKey","max","Math","pow","wrap","fn","disposable","cache","dispose","key","entry","reportOrphan","delete","optimistic","currentParentEntry","apply","arguments","args","len","length","set","acquire","subscribe","value","recompute","parents","size","clean","dirty","has","setDirty"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar Cache = require(\"./cache.js\").Cache;\nvar tuple = require(\"immutable-tuple\").tuple;\nvar Entry = require(\"./entry.js\").Entry;\nvar getLocal = require(\"./local.js\").get;\n\n// Exported so that custom makeCacheKey functions can easily reuse the\n// default implementation (with different arguments).\nexports.defaultMakeCacheKey = tuple;\n\nfunction normalizeOptions(options) {\n  options = options || Object.create(null);\n\n  if (typeof options.makeCacheKey !== \"function\") {\n    options.makeCacheKey = tuple;\n  }\n\n  if (typeof options.max !== \"number\") {\n    options.max = Math.pow(2, 16);\n  }\n\n  return options;\n}\n\nfunction wrap(fn, options) {\n  options = normalizeOptions(options);\n\n  // If this wrapped function is disposable, then its creator does not\n  // care about its return value, and it should be removed from the cache\n  // immediately when it no longer has any parents that depend on it.\n  var disposable = !! options.disposable;\n\n  var cache = new Cache({\n    max: options.max,\n    dispose: function (key, entry) {\n      entry.dispose();\n    }\n  });\n\n  function reportOrphan(entry) {\n    if (disposable) {\n      // Triggers the entry.dispose() call above.\n      cache.delete(entry.key);\n      return true;\n    }\n  }\n\n  function optimistic() {\n    if (disposable && ! getLocal().currentParentEntry) {\n      // If there's no current parent computation, and this wrapped\n      // function is disposable (meaning we don't care about entry.value,\n      // just dependency tracking), then we can short-cut everything else\n      // in this function, because entry.recompute() is going to recycle\n      // the entry object without recomputing anything, anyway.\n      return;\n    }\n\n    var key = options.makeCacheKey.apply(null, arguments);\n    if (! key) {\n      return fn.apply(null, arguments);\n    }\n\n    var args = [], len = arguments.length;\n    while (len--) args[len] = arguments[len];\n\n    var entry = cache.get(key);\n    if (entry) {\n      entry.args = args;\n    } else {\n      cache.set(key, entry = Entry.acquire(fn, key, args));\n      entry.subscribe = options.subscribe;\n      if (disposable) {\n        entry.reportOrphan = reportOrphan;\n      }\n    }\n\n    var value = entry.recompute();\n\n    // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n    cache.set(key, entry);\n\n    // Clean up any excess entries in the cache, but only if this entry\n    // has no parents, which means we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n    if (entry.parents.size === 0) {\n      cache.clean();\n    }\n\n    // If options.disposable is truthy, the caller of wrap is telling us\n    // they don't care about the result of entry.recompute(), so we should\n    // avoid returning the value, so it won't be accidentally used.\n    if (! disposable) {\n      return value;\n    }\n  }\n\n  optimistic.dirty = function () {\n    var key = options.makeCacheKey.apply(null, arguments);\n    if (! key) {\n      return;\n    }\n\n    if (! cache.has(key)) {\n      return;\n    }\n\n    cache.get(key).setDirty();\n  };\n\n  return optimistic;\n}\n\nexports.wrap = wrap;\n"]},"metadata":{},"sourceType":"script"}