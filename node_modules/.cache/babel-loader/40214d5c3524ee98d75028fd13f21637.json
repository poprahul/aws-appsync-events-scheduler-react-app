{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeInfo = undefined;\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _definition = require('../type/definition');\n\nvar _introspection = require('../type/introspection');\n\nvar _typeFromAST = require('./typeFromAST');\n\nvar _find = require('../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\n\nvar TypeInfo = exports.TypeInfo = function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n  }\n\n  TypeInfo.prototype.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  TypeInfo.prototype.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  TypeInfo.prototype.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  }; // Flow does not yet handle this case.\n\n\n  TypeInfo.prototype.enter = function enter(node\n  /* ASTNode */\n  ) {\n    var schema = this._schema;\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = (0, _definition.getNamedType)(this.getType());\n\n        this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n\n        break;\n\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef = void 0;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(fieldDef && fieldDef.type);\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        var type = void 0;\n\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n\n        this._typeStack.push(type);\n\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : this.getType();\n\n        this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n        this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n\n        break;\n\n      case Kind.ARGUMENT:\n        var argDef = void 0;\n        var argType = void 0;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = (0, _find2.default)(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._inputTypeStack.push(argType);\n\n        break;\n\n      case Kind.LIST:\n        var listType = (0, _definition.getNullableType)(this.getInputType());\n\n        this._inputTypeStack.push(listType instanceof _definition.GraphQLList ? listType.ofType : undefined);\n\n        break;\n\n      case Kind.OBJECT_FIELD:\n        var objectType = (0, _definition.getNamedType)(this.getInputType());\n        var fieldType = void 0;\n\n        if (objectType instanceof _definition.GraphQLInputObjectType) {\n          var inputField = objectType.getFields()[node.name.value];\n          fieldType = inputField ? inputField.type : undefined;\n        }\n\n        this._inputTypeStack.push(fieldType);\n\n        break;\n\n      case Kind.ENUM:\n        var enumType = (0, _definition.getNamedType)(this.getInputType());\n        var enumValue = void 0;\n\n        if (enumType instanceof _definition.GraphQLEnumType) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  TypeInfo.prototype.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {\n    return parentType.getFields()[name];\n  }\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/graphql/utilities/TypeInfo.js"],"names":["Object","defineProperty","exports","value","TypeInfo","undefined","_kinds","require","Kind","_interopRequireWildcard","_definition","_introspection","_typeFromAST","_find","_find2","_interopRequireDefault","obj","__esModule","default","newObj","key","prototype","hasOwnProperty","call","_classCallCheck","instance","Constructor","TypeError","schema","getFieldDefFn","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","getType","length","getParentType","getInputType","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","getNamedType","push","isCompositeType","FIELD","parentType","fieldDef","type","DIRECTIVE","name","OPERATION_DEFINITION","operation","getQueryType","getMutationType","getSubscriptionType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","typeFromAST","isOutputType","VARIABLE_DEFINITION","inputType","isInputType","ARGUMENT","argDef","argType","fieldOrDirective","args","arg","LIST","listType","getNullableType","GraphQLList","ofType","OBJECT_FIELD","objectType","fieldType","GraphQLInputObjectType","inputField","getFields","ENUM","enumType","enumValue","GraphQLEnumType","getValue","leave","pop","fieldNode","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","GraphQLObjectType","GraphQLInterfaceType"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeInfo = undefined;\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _definition = require('../type/definition');\n\nvar _introspection = require('../type/introspection');\n\nvar _typeFromAST = require('./typeFromAST');\n\nvar _find = require('../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           * \n                                                                                                                                                           */\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nvar TypeInfo = exports.TypeInfo = function () {\n  function TypeInfo(schema,\n  // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n  }\n\n  TypeInfo.prototype.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  TypeInfo.prototype.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  TypeInfo.prototype.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  // Flow does not yet handle this case.\n\n\n  TypeInfo.prototype.enter = function enter(node /* ASTNode */) {\n    var schema = this._schema;\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = (0, _definition.getNamedType)(this.getType());\n        this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n        break;\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef = void 0;\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n        }\n        this._fieldDefStack.push(fieldDef);\n        this._typeStack.push(fieldDef && fieldDef.type);\n        break;\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n      case Kind.OPERATION_DEFINITION:\n        var type = void 0;\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n        this._typeStack.push(type);\n        break;\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : this.getType();\n        this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n        break;\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n        this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n        break;\n      case Kind.ARGUMENT:\n        var argDef = void 0;\n        var argType = void 0;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n        if (fieldOrDirective) {\n          argDef = (0, _find2.default)(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n        this._argument = argDef;\n        this._inputTypeStack.push(argType);\n        break;\n      case Kind.LIST:\n        var listType = (0, _definition.getNullableType)(this.getInputType());\n        this._inputTypeStack.push(listType instanceof _definition.GraphQLList ? listType.ofType : undefined);\n        break;\n      case Kind.OBJECT_FIELD:\n        var objectType = (0, _definition.getNamedType)(this.getInputType());\n        var fieldType = void 0;\n        if (objectType instanceof _definition.GraphQLInputObjectType) {\n          var inputField = objectType.getFields()[node.name.value];\n          fieldType = inputField ? inputField.type : undefined;\n        }\n        this._inputTypeStack.push(fieldType);\n        break;\n      case Kind.ENUM:\n        var enumType = (0, _definition.getNamedType)(this.getInputType());\n        var enumValue = void 0;\n        if (enumType instanceof _definition.GraphQLEnumType) {\n          enumValue = enumType.getValue(node.value);\n        }\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  TypeInfo.prototype.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n        break;\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n        this._typeStack.pop();\n        break;\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n        break;\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ARGUMENT:\n        this._argument = null;\n        this._inputTypeStack.pop();\n        break;\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n  if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {\n    return parentType.getFields()[name];\n  }\n}"]},"metadata":{},"sourceType":"script"}