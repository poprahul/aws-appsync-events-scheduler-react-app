{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isNamedType, isInputType, isOutputType } from './definition';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, 'Expected ' + String(schema) + ' to be a GraphQL schema.') : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = function () {\n  function SchemaValidationContext(schema) {\n    _classCallCheck(this, SchemaValidationContext);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  SchemaValidationContext.prototype.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  SchemaValidationContext.prototype.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  SchemaValidationContext.prototype.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError('Query root type must be Object type, it cannot be ' + String(queryType) + '.', getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + (String(mutationType) + '.'), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + (String(subscriptionType) + '.'), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var astNode = schema.astNode;\n  var operationTypeNode = astNode && astNode.operationTypes.find(function (operationType) {\n    return operationType.operation === operation;\n  });\n  return operationTypeNode ? operationTypeNode.type : type && type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var directives = context.schema.getDirectives();\n  directives.forEach(function (directive) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError('Expected directive but got: ' + String(directive) + '.', directive && directive.astNode);\n      return;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    var argNames = Object.create(null);\n    directive.args.forEach(function (arg) {\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per directive.\n\n      if (argNames[argName]) {\n        context.reportError('Argument @' + directive.name + '(' + argName + ':) can only be defined once.', getAllDirectiveArgNodes(directive, argName));\n        return; // continue loop\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError('The type of @' + directive.name + '(' + argName + ':) must be Input Type ' + ('but got: ' + String(arg.type) + '.'), getDirectiveArgTypeNode(directive, argName));\n      }\n    });\n  });\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames && context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  objectValues(typeMap).forEach(function (type) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError('Expected GraphQL named type but got: ' + String(type) + '.', type && type.astNode);\n      return;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateObjectInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type);\n    }\n  });\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError('Type ' + type.name + ' must define one or more fields.', getAllObjectOrInterfaceNodes(type));\n  }\n\n  fields.forEach(function (field) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure they were defined at most once.\n\n    var fieldNodes = getAllFieldNodes(type, field.name);\n\n    if (fieldNodes.length > 1) {\n      context.reportError('Field ' + type.name + '.' + field.name + ' can only be defined once.', fieldNodes);\n      return; // continue loop\n    } // Ensure the type is an output type\n\n\n    if (!isOutputType(field.type)) {\n      context.reportError('The type of ' + type.name + '.' + field.name + ' must be Output Type ' + ('but got: ' + String(field.type) + '.'), getFieldTypeNode(type, field.name));\n    } // Ensure the arguments are valid\n\n\n    var argNames = Object.create(null);\n    field.args.forEach(function (arg) {\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure they are unique per field.\n\n      if (argNames[argName]) {\n        context.reportError('Field argument ' + type.name + '.' + field.name + '(' + argName + ':) can only ' + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n      }\n\n      argNames[argName] = true; // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        context.reportError('The type of ' + type.name + '.' + field.name + '(' + argName + ':) must be Input ' + ('Type but got: ' + String(arg.type) + '.'), getFieldArgTypeNode(type, field.name, argName));\n      }\n    });\n  });\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  object.getInterfaces().forEach(function (iface) {\n    if (implementedTypeNames[iface.name]) {\n      context.reportError('Type ' + object.name + ' can only implement ' + iface.name + ' once.', getAllImplementsInterfaceNodes(object, iface));\n      return; // continue loop\n    }\n\n    implementedTypeNames[iface.name] = true;\n    validateObjectImplementsInterface(context, object, iface);\n  });\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  if (!isInterfaceType(iface)) {\n    context.reportError('Type ' + String(object) + ' must only implement Interface types, ' + ('it cannot implement ' + String(iface) + '.'), getImplementsInterfaceNode(object, iface));\n    return;\n  }\n\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  Object.keys(ifaceFieldMap).forEach(function (fieldName) {\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError('Interface field ' + iface.name + '.' + fieldName + ' expected but ' + (object.name + ' does not provide it.'), [getFieldNode(iface, fieldName), object.astNode]); // Continue loop over fields.\n\n      return;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError('Interface field ' + iface.name + '.' + fieldName + ' expects type ' + (String(ifaceField.type) + ' but ' + object.name + '.' + fieldName + ' ') + ('is type ' + String(objectField.type) + '.'), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n\n    ifaceField.args.forEach(function (ifaceArg) {\n      var argName = ifaceArg.name;\n      var objectArg = find(objectField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!objectArg) {\n        context.reportError('Interface field argument ' + iface.name + '.' + fieldName + '(' + argName + ':) ' + ('expected but ' + object.name + '.' + fieldName + ' does not provide it.'), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]); // Continue loop over arguments.\n\n        return;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, objectArg.type)) {\n        context.reportError('Interface field argument ' + iface.name + '.' + fieldName + '(' + argName + ':) ' + ('expects type ' + String(ifaceArg.type) + ' but ') + (object.name + '.' + fieldName + '(' + argName + ':) is type ') + (String(objectArg.type) + '.'), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n      } // TODO: validate default values?\n\n    }); // Assert additional arguments must not be required.\n\n    objectField.args.forEach(function (objectArg) {\n      var argName = objectArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isNonNullType(objectArg.type)) {\n        context.reportError('Object field argument ' + object.name + '.' + fieldName + '(' + argName + ':) ' + ('is of required type ' + String(objectArg.type) + ' but is not also ') + ('provided by the Interface field ' + iface.name + '.' + fieldName + '.'), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n      }\n    });\n  });\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError('Union type ' + union.name + ' must define one or more member types.', union.astNode);\n  }\n\n  var includedTypeNames = Object.create(null);\n  memberTypes.forEach(function (memberType) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError('Union type ' + union.name + ' can only include type ' + (memberType.name + ' once.'), getUnionMemberTypeNodes(union, memberType.name));\n      return; // continue loop\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError('Union type ' + union.name + ' can only include Object types, ' + ('it cannot include ' + String(memberType) + '.'), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  });\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError('Enum type ' + enumType.name + ' must define one or more values.', enumType.astNode);\n  }\n\n  enumValues.forEach(function (enumValue) {\n    var valueName = enumValue.name; // Ensure no duplicates.\n\n    var allNodes = getEnumValueNodes(enumType, valueName);\n\n    if (allNodes && allNodes.length > 1) {\n      context.reportError('Enum type ' + enumType.name + ' can include value ' + valueName + ' only once.', allNodes);\n    } // Ensure valid name.\n\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError('Enum type ' + enumType.name + ' cannot include value: ' + valueName + '.', enumValue.astNode);\n    }\n  });\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError('Input Object type ' + inputObj.name + ' must define one or more fields.', inputObj.astNode);\n  } // Ensure the arguments are valid\n\n\n  fields.forEach(function (field) {\n    // Ensure they are named correctly.\n    validateName(context, field); // TODO: Ensure they are unique per field.\n    // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      context.reportError('The type of ' + inputObj.name + '.' + field.name + ' must be Input Type ' + ('but got: ' + String(field.type) + '.'), field.astNode && field.astNode.type);\n    }\n  });\n}\n\nfunction getAllObjectNodes(type) {\n  return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];\n}\n\nfunction getAllObjectOrInterfaceNodes(type) {\n  return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  var implementsNodes = [];\n  var astNodes = getAllObjectNodes(type);\n\n  for (var i = 0; i < astNodes.length; i++) {\n    var _astNode = astNodes[i];\n\n    if (_astNode && _astNode.interfaces) {\n      _astNode.interfaces.forEach(function (node) {\n        if (node.name.value === iface.name) {\n          implementsNodes.push(node);\n        }\n      });\n    }\n  }\n\n  return implementsNodes;\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  var fieldNodes = [];\n  var astNodes = getAllObjectOrInterfaceNodes(type);\n\n  for (var i = 0; i < astNodes.length; i++) {\n    var _astNode2 = astNodes[i];\n\n    if (_astNode2 && _astNode2.fields) {\n      _astNode2.fields.forEach(function (node) {\n        if (node.name.value === fieldName) {\n          fieldNodes.push(node);\n        }\n      });\n    }\n  }\n\n  return fieldNodes;\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n\n  if (fieldNode && fieldNode.arguments) {\n    fieldNode.arguments.forEach(function (node) {\n      if (node.name.value === argName) {\n        argNodes.push(node);\n      }\n    });\n  }\n\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  var argNodes = [];\n  var directiveNode = directive.astNode;\n\n  if (directiveNode && directiveNode.arguments) {\n    directiveNode.arguments.forEach(function (node) {\n      if (node.name.value === argName) {\n        argNodes.push(node);\n      }\n    });\n  }\n\n  return argNodes;\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return union.astNode && union.astNode.types && union.astNode.types.filter(function (type) {\n    return type.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return enumType.astNode && enumType.astNode.values && enumType.astNode.values.filter(function (value) {\n    return value.name.value === valueName;\n  });\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/type/validate.js"],"names":["_classCallCheck","instance","Constructor","TypeError","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNonNullType","isNamedType","isInputType","isOutputType","isDirective","isIntrospectionType","isSchema","find","invariant","objectValues","GraphQLError","isValidNameError","isEqualType","isTypeSubTypeOf","validateSchema","schema","String","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","getOperationTypeNode","mutationType","getMutationType","subscriptionType","getSubscriptionType","type","operation","operationTypeNode","operationTypes","operationType","directives","getDirectives","forEach","directive","validateName","argNames","Object","create","args","arg","argName","name","getAllDirectiveArgNodes","getDirectiveArgTypeNode","node","__allowedLegacyNames","indexOf","undefined","typeMap","getTypeMap","validateFields","validateObjectInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllObjectOrInterfaceNodes","field","fieldNodes","getAllFieldNodes","getFieldTypeNode","getAllFieldArgNodes","getFieldArgTypeNode","object","implementedTypeNames","getInterfaces","iface","getAllImplementsInterfaceNodes","validateObjectImplementsInterface","getImplementsInterfaceNode","objectFieldMap","ifaceFieldMap","keys","fieldName","objectField","ifaceField","getFieldNode","ifaceArg","objectArg","getFieldArgNode","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","enumType","enumValues","getValues","enumValue","valueName","allNodes","getEnumValueNodes","inputObj","getAllObjectNodes","extensionASTNodes","concat","implementsNodes","astNodes","i","_astNode","interfaces","value","_astNode2","fieldNode","argNodes","arguments","fieldArgNode","directiveNode","argNode","typeName","types","values"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isNamedType, isInputType, isOutputType } from './definition';\n\nimport { isDirective } from './directives';\n\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\n\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\n\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, 'Expected ' + String(schema) + ' to be a GraphQL schema.') : void 0;\n\n  // If this Schema has already been validated, return the previous results.\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  }\n\n  // Validate the schema, producing a list of errors.\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context);\n\n  // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = function () {\n  function SchemaValidationContext(schema) {\n    _classCallCheck(this, SchemaValidationContext);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  SchemaValidationContext.prototype.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  SchemaValidationContext.prototype.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  SchemaValidationContext.prototype.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError('Query root type must be Object type, it cannot be ' + String(queryType) + '.', getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + (String(mutationType) + '.'), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + (String(subscriptionType) + '.'), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var astNode = schema.astNode;\n  var operationTypeNode = astNode && astNode.operationTypes.find(function (operationType) {\n    return operationType.operation === operation;\n  });\n  return operationTypeNode ? operationTypeNode.type : type && type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var directives = context.schema.getDirectives();\n  directives.forEach(function (directive) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError('Expected directive but got: ' + String(directive) + '.', directive && directive.astNode);\n      return;\n    }\n\n    // Ensure they are named correctly.\n    validateName(context, directive);\n\n    // TODO: Ensure proper locations.\n\n    // Ensure the arguments are valid.\n    var argNames = Object.create(null);\n    directive.args.forEach(function (arg) {\n      var argName = arg.name;\n\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      // Ensure they are unique per directive.\n      if (argNames[argName]) {\n        context.reportError('Argument @' + directive.name + '(' + argName + ':) can only be defined once.', getAllDirectiveArgNodes(directive, argName));\n        return; // continue loop\n      }\n      argNames[argName] = true;\n\n      // Ensure the type is an input type.\n      if (!isInputType(arg.type)) {\n        context.reportError('The type of @' + directive.name + '(' + argName + ':) must be Input Type ' + ('but got: ' + String(arg.type) + '.'), getDirectiveArgTypeNode(directive, argName));\n      }\n    });\n  });\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames && context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  }\n  // Ensure names are valid, however introspection types opt out.\n  var error = isValidNameError(node.name, node.astNode || undefined);\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  objectValues(typeMap).forEach(function (type) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError('Expected GraphQL named type but got: ' + String(type) + '.', type && type.astNode);\n      return;\n    }\n\n    // Ensure it is named correctly (excluding introspection types).\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type);\n\n      // Ensure objects implement the interfaces they claim to.\n      validateObjectInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type);\n    }\n  });\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields());\n\n  // Objects and Interfaces both must define one or more fields.\n  if (fields.length === 0) {\n    context.reportError('Type ' + type.name + ' must define one or more fields.', getAllObjectOrInterfaceNodes(type));\n  }\n\n  fields.forEach(function (field) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // Ensure they were defined at most once.\n    var fieldNodes = getAllFieldNodes(type, field.name);\n    if (fieldNodes.length > 1) {\n      context.reportError('Field ' + type.name + '.' + field.name + ' can only be defined once.', fieldNodes);\n      return; // continue loop\n    }\n\n    // Ensure the type is an output type\n    if (!isOutputType(field.type)) {\n      context.reportError('The type of ' + type.name + '.' + field.name + ' must be Output Type ' + ('but got: ' + String(field.type) + '.'), getFieldTypeNode(type, field.name));\n    }\n\n    // Ensure the arguments are valid\n    var argNames = Object.create(null);\n    field.args.forEach(function (arg) {\n      var argName = arg.name;\n\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      // Ensure they are unique per field.\n      if (argNames[argName]) {\n        context.reportError('Field argument ' + type.name + '.' + field.name + '(' + argName + ':) can only ' + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n      }\n      argNames[argName] = true;\n\n      // Ensure the type is an input type\n      if (!isInputType(arg.type)) {\n        context.reportError('The type of ' + type.name + '.' + field.name + '(' + argName + ':) must be Input ' + ('Type but got: ' + String(arg.type) + '.'), getFieldArgTypeNode(type, field.name, argName));\n      }\n    });\n  });\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  object.getInterfaces().forEach(function (iface) {\n    if (implementedTypeNames[iface.name]) {\n      context.reportError('Type ' + object.name + ' can only implement ' + iface.name + ' once.', getAllImplementsInterfaceNodes(object, iface));\n      return; // continue loop\n    }\n    implementedTypeNames[iface.name] = true;\n    validateObjectImplementsInterface(context, object, iface);\n  });\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  if (!isInterfaceType(iface)) {\n    context.reportError('Type ' + String(object) + ' must only implement Interface types, ' + ('it cannot implement ' + String(iface) + '.'), getImplementsInterfaceNode(object, iface));\n    return;\n  }\n\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields();\n\n  // Assert each interface field is implemented.\n  Object.keys(ifaceFieldMap).forEach(function (fieldName) {\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName];\n\n    // Assert interface field exists on object.\n    if (!objectField) {\n      context.reportError('Interface field ' + iface.name + '.' + fieldName + ' expected but ' + (object.name + ' does not provide it.'), [getFieldNode(iface, fieldName), object.astNode]);\n      // Continue loop over fields.\n      return;\n    }\n\n    // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError('Interface field ' + iface.name + '.' + fieldName + ' expects type ' + (String(ifaceField.type) + ' but ' + object.name + '.' + fieldName + ' ') + ('is type ' + String(objectField.type) + '.'), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    }\n\n    // Assert each interface field arg is implemented.\n    ifaceField.args.forEach(function (ifaceArg) {\n      var argName = ifaceArg.name;\n      var objectArg = find(objectField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      // Assert interface field arg exists on object field.\n      if (!objectArg) {\n        context.reportError('Interface field argument ' + iface.name + '.' + fieldName + '(' + argName + ':) ' + ('expected but ' + object.name + '.' + fieldName + ' does not provide it.'), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n        // Continue loop over arguments.\n        return;\n      }\n\n      // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n      if (!isEqualType(ifaceArg.type, objectArg.type)) {\n        context.reportError('Interface field argument ' + iface.name + '.' + fieldName + '(' + argName + ':) ' + ('expects type ' + String(ifaceArg.type) + ' but ') + (object.name + '.' + fieldName + '(' + argName + ':) is type ') + (String(objectArg.type) + '.'), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n      }\n\n      // TODO: validate default values?\n    });\n\n    // Assert additional arguments must not be required.\n    objectField.args.forEach(function (objectArg) {\n      var argName = objectArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n      if (!ifaceArg && isNonNullType(objectArg.type)) {\n        context.reportError('Object field argument ' + object.name + '.' + fieldName + '(' + argName + ':) ' + ('is of required type ' + String(objectArg.type) + ' but is not also ') + ('provided by the Interface field ' + iface.name + '.' + fieldName + '.'), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n      }\n    });\n  });\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError('Union type ' + union.name + ' must define one or more member types.', union.astNode);\n  }\n\n  var includedTypeNames = Object.create(null);\n  memberTypes.forEach(function (memberType) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError('Union type ' + union.name + ' can only include type ' + (memberType.name + ' once.'), getUnionMemberTypeNodes(union, memberType.name));\n      return; // continue loop\n    }\n    includedTypeNames[memberType.name] = true;\n    if (!isObjectType(memberType)) {\n      context.reportError('Union type ' + union.name + ' can only include Object types, ' + ('it cannot include ' + String(memberType) + '.'), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  });\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError('Enum type ' + enumType.name + ' must define one or more values.', enumType.astNode);\n  }\n\n  enumValues.forEach(function (enumValue) {\n    var valueName = enumValue.name;\n\n    // Ensure no duplicates.\n    var allNodes = getEnumValueNodes(enumType, valueName);\n    if (allNodes && allNodes.length > 1) {\n      context.reportError('Enum type ' + enumType.name + ' can include value ' + valueName + ' only once.', allNodes);\n    }\n\n    // Ensure valid name.\n    validateName(context, enumValue);\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError('Enum type ' + enumType.name + ' cannot include value: ' + valueName + '.', enumValue.astNode);\n    }\n  });\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError('Input Object type ' + inputObj.name + ' must define one or more fields.', inputObj.astNode);\n  }\n\n  // Ensure the arguments are valid\n  fields.forEach(function (field) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // TODO: Ensure they are unique per field.\n\n    // Ensure the type is an input type\n    if (!isInputType(field.type)) {\n      context.reportError('The type of ' + inputObj.name + '.' + field.name + ' must be Input Type ' + ('but got: ' + String(field.type) + '.'), field.astNode && field.astNode.type);\n    }\n  });\n}\n\nfunction getAllObjectNodes(type) {\n  return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];\n}\n\nfunction getAllObjectOrInterfaceNodes(type) {\n  return type.astNode ? type.extensionASTNodes ? [type.astNode].concat(type.extensionASTNodes) : [type.astNode] : type.extensionASTNodes || [];\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  var implementsNodes = [];\n  var astNodes = getAllObjectNodes(type);\n  for (var i = 0; i < astNodes.length; i++) {\n    var _astNode = astNodes[i];\n    if (_astNode && _astNode.interfaces) {\n      _astNode.interfaces.forEach(function (node) {\n        if (node.name.value === iface.name) {\n          implementsNodes.push(node);\n        }\n      });\n    }\n  }\n  return implementsNodes;\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  var fieldNodes = [];\n  var astNodes = getAllObjectOrInterfaceNodes(type);\n  for (var i = 0; i < astNodes.length; i++) {\n    var _astNode2 = astNodes[i];\n    if (_astNode2 && _astNode2.fields) {\n      _astNode2.fields.forEach(function (node) {\n        if (node.name.value === fieldName) {\n          fieldNodes.push(node);\n        }\n      });\n    }\n  }\n  return fieldNodes;\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n  if (fieldNode && fieldNode.arguments) {\n    fieldNode.arguments.forEach(function (node) {\n      if (node.name.value === argName) {\n        argNodes.push(node);\n      }\n    });\n  }\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  var argNodes = [];\n  var directiveNode = directive.astNode;\n  if (directiveNode && directiveNode.arguments) {\n    directiveNode.arguments.forEach(function (node) {\n      if (node.name.value === argName) {\n        argNodes.push(node);\n      }\n    });\n  }\n  return argNodes;\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return union.astNode && union.astNode.types && union.astNode.types.filter(function (type) {\n    return type.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return enumType.astNode && enumType.astNode.values && enumType.astNode.values.filter(function (value) {\n    return value.name.value === valueName;\n  });\n}"]},"metadata":{},"sourceType":"module"}