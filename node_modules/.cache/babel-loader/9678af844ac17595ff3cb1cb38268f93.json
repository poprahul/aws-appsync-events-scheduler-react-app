{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport keyMap from '../jsutils/keyMap';\nimport isInvalid from '../jsutils/isInvalid';\nimport objectValues from '../jsutils/objectValues';\nimport { Kind } from '../language/kinds';\nimport { isScalarType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\n\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n\n    if (!variables || isInvalid(variables[variableName])) {\n      // No valid return value.\n      return;\n    } // Note: we're not doing any checking that this variable is correct. We're\n    // assuming that this query has been validated and the variable usage here\n    // is of the correct type.\n\n\n    return variables[variableName];\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (valueNode.kind === Kind.LIST) {\n      var coercedValues = [];\n      var itemNodes = valueNode.values;\n\n      for (var i = 0; i < itemNodes.length; i++) {\n        if (isMissingVariable(itemNodes[i], variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNodes[i], itemType, variables);\n\n          if (isInvalid(itemValue)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (isInvalid(coercedValue)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var coercedObj = Object.create(null);\n    var fieldNodes = keyMap(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n    var fields = objectValues(type.getFields());\n\n    for (var _i = 0; _i < fields.length; _i++) {\n      var field = fields[_i];\n      var fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (!isInvalid(field.defaultValue)) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (isInvalid(fieldValue)) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if (isEnumType(type)) {\n    if (valueNode.kind !== Kind.ENUM) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var enumValue = type.getValue(valueNode.value);\n\n    if (!enumValue) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return enumValue.value;\n  }\n\n  if (isScalarType(type)) {\n    // Scalars fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result = void 0;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (isInvalid(result)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error('Unknown type: ' + type + '.');\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (!variables || isInvalid(variables[valueNode.name.value]));\n}","map":{"version":3,"sources":["/Users/poprahul/workspace/frontend/amplify-apps/calandarApp/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/valueFromAST.js"],"names":["keyMap","isInvalid","objectValues","Kind","isScalarType","isEnumType","isInputObjectType","isListType","isNonNullType","valueFromAST","valueNode","type","variables","kind","NULL","ofType","VARIABLE","variableName","name","value","itemType","LIST","coercedValues","itemNodes","values","i","length","isMissingVariable","push","itemValue","coercedValue","OBJECT","coercedObj","Object","create","fieldNodes","fields","field","getFields","_i","fieldNode","defaultValue","fieldValue","ENUM","enumValue","getValue","result","parseLiteral","_error","Error"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport keyMap from '../jsutils/keyMap';\nimport isInvalid from '../jsutils/isInvalid';\nimport objectValues from '../jsutils/objectValues';\n\nimport { Kind } from '../language/kinds';\nimport { isScalarType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n    if (!variables || isInvalid(variables[variableName])) {\n      // No valid return value.\n      return;\n    }\n    // Note: we're not doing any checking that this variable is correct. We're\n    // assuming that this query has been validated and the variable usage here\n    // is of the correct type.\n    return variables[variableName];\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n    if (valueNode.kind === Kind.LIST) {\n      var coercedValues = [];\n      var itemNodes = valueNode.values;\n      for (var i = 0; i < itemNodes.length; i++) {\n        if (isMissingVariable(itemNodes[i], variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNodes[i], itemType, variables);\n          if (isInvalid(itemValue)) {\n            return; // Invalid: intentionally return no value.\n          }\n          coercedValues.push(itemValue);\n        }\n      }\n      return coercedValues;\n    }\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n    if (isInvalid(coercedValue)) {\n      return; // Invalid: intentionally return no value.\n    }\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n    var coercedObj = Object.create(null);\n    var fieldNodes = keyMap(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n    var fields = objectValues(type.getFields());\n    for (var _i = 0; _i < fields.length; _i++) {\n      var field = fields[_i];\n      var fieldNode = fieldNodes[field.name];\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (!isInvalid(field.defaultValue)) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n        continue;\n      }\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n      if (isInvalid(fieldValue)) {\n        return; // Invalid: intentionally return no value.\n      }\n      coercedObj[field.name] = fieldValue;\n    }\n    return coercedObj;\n  }\n\n  if (isEnumType(type)) {\n    if (valueNode.kind !== Kind.ENUM) {\n      return; // Invalid: intentionally return no value.\n    }\n    var enumValue = type.getValue(valueNode.value);\n    if (!enumValue) {\n      return; // Invalid: intentionally return no value.\n    }\n    return enumValue.value;\n  }\n\n  if (isScalarType(type)) {\n    // Scalars fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result = void 0;\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n    if (isInvalid(result)) {\n      return; // Invalid: intentionally return no value.\n    }\n    return result;\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unknown type: ' + type + '.');\n}\n\n// Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (!variables || isInvalid(variables[valueNode.name.value]));\n}"]},"metadata":{},"sourceType":"module"}